{"meta":{"title":"四叶草的个人博客","subtitle":"联系方式：15854388082","description":"个人整理的数据和学习资料，碰到问题及时记录，以方便查看，以及应用","author":"四叶草","url":"https://a-lyc.github.io","root":"/A-lyc/"},"pages":[{"title":"","date":"2022-03-03T08:33:28.764Z","updated":"2022-03-03T08:33:28.764Z","comments":true,"path":"404.html","permalink":"https://a-lyc.github.io/404.html","excerpt":"","text":"Title"},{"title":"个人简历","date":"2020-03-21T15:49:57.000Z","updated":"2022-03-03T08:33:28.876Z","comments":false,"path":"about/index.html","permalink":"https://a-lyc.github.io/about/index.html","excerpt":"","text":"响应式网站开发，移动端开发，Html5+Css，js，以及vue，使用服务器端渲染next开发web网站，使用uniapp建立功能性小程序，也可使用微信原生编写功能性小程序。熟悉ps，ai等设计工具，可完成独立排版，审美，以及合理的用户体验。了解熟悉node.js + express框架 + egg + mysql + mongoose数据库 可自己搭建服务器,了解熟悉node的框架以及各个插件 求职意向 意向薪资 工作经验 年龄 电话 邮箱 web前端 9k+ 5年 1998年 15854388082 2294016229@qq.com 网站设计 8k+ 5年 1998年 15854388082 2294016229@qq.com 工作经历 2020-5–至今；————公司：智慧鸟网络科技；————职位：wen前端，平面设计……；工作内容：1：前端切图（vue，js，html，css……），数据交互，计划数据结构。2：设计小程序以及网站页面，根据网站功能和使用，设计出用户习惯使用的网站（ps出图，ai图标）。3：设计网站小程序以及app页面4：使用AE做简单的动画，网站可被使用的动画，如：svga，gif……。 2018-5–2020-5；————公司：力图数字科技；————职位：网站设计；工作内容：1：根据客户需求设计出相应的响应式网站页面，以及页面之间的动效交互，和方便用户使用感（熟练使用ps，ai等设计工具）。2：前端使用基于webpack的脚手架维护项目，以及项目切图（熟悉vue.js，uniapp，HTML5+CSS3，js……）。3：网站维护以及运维（可使用织梦系统自主建站，了解wordpress）。4：微信文章编排（使用ps等软件编排，剪辑视频，微信H5等）。5：可使用Axure制作原型图， 2017-10-2018-5；————公司：欣毅壁布壁画；工作内容：1：根据客户需求，设计出合适的壁画。2：维护网站以及微信公众号和微信小店 技术栈 熟悉vue开发流程，可使用vue的大部分框架， 可开发服务器端渲染项目，使用nuxt.js，进行开发，保持seo优化 使用nuiapp开发具有功能行的小程序(熟悉uniapp支持的大部分框架)，以及导出其它端的小程序以及app（不了解app上架程序）。 了解node.js，可使用node.js搭建程序 node.js + express框架 + egg + mysql + mongoose数据库， 响应式网站开发，移动端开发，了解Html5+Css，js，以及vue和uniapp。 熟悉ps，ai等设计工具，可完成独立排版，审美，以及合理的用户体验。 熟悉原型图制作Axure，了解微信H5（借助易企秀等工具）页面制作，了解剪辑视频合成。 作品案例 小程序制作:· 致学网，单独开发前端页面，H5 和致学网APP（使用uniapp）· 海信地产小程序（团队合作，使用uniapp），· 海信地产微网站（团队合作/已停用） 功能型网站:· 滨州致学网址：www.zhixue88.com（已停止运营）· CSGO开箱网站：http://100steam.com（自适应网站）· CSGO开箱网站：http://www.97skins.cn（自适应网站）· CSGO开箱网站：http://www.92skins.com/（手机端）· 缪克发卡官网：https://www.miuke.net/· CSGO（手机端）：http://m.skinworld.cc/（已关站） 前端web网站：· 门户网站：海信网络科技，海信地产，澳科软件，国运集团，兴和石墨，luxxan，20+…… 页面设计:· 海信网络科技，海信宽带多媒体，国运集团，炎一科技，海信商显，江南内容，睿林假发，20+… 后台项目:· 天德科技软件安全（使用vue进行构建）· 缪克发卡官网：https://www.miuke.net/（layui 纯html，css，js）"},{"title":"","date":"2020-10-08T06:15:47.000Z","updated":"2022-03-03T08:33:28.876Z","comments":false,"path":"categories/index.html","permalink":"https://a-lyc.github.io/categories/index.html","excerpt":"","text":""},{"title":"设计作品","date":"2020-03-21T17:35:46.000Z","updated":"2022-03-03T08:33:28.888Z","comments":false,"path":"production/index.html","permalink":"https://a-lyc.github.io/production/index.html","excerpt":"","text":"欢迎观看我的作品前端使用：使用webpack + node.js 脚手架写出的，使用HTML+CSS+js等技术，模块化思想，实现自适应布局，兼容手机端，小程序：使用的uniapp框架进行，使用npm引入进行的方式编写；部分网站：使用nuxt.js 实现服务器端渲染（利于seo优化，和新技术实现）设计方面使用：ps和ai等设计工具完成页面的展示效果以及适合自适应的布局方式 项目名称 备注 网址 CSGO vue，element，老虎机，web端，手机端， 网址：//www.100steam.com/ CSGO vue，element，老虎机，web端，手机端， 网址：//www.92skins.com/ CSGO vue，element，老虎机，自适应， 网址：//www.97skins.cn/ 缪克发卡 原生html，css，js，含有layui后台 网址：//www.miuke.net/ CS:GO开箱 uniappp，h5，实时通讯，渣渣老虎机，无PC端 网址：http://m.skinworld.cc 滨州致学 服务器端渲染，nuxt.js 网址：https://www.zhixue88.com/ 滨州致学小程序 小程序，微信搜索致学网，即可 网址：http://m.zhixue88.com/ 海信地产 海信地产小程序（合作完成）微信搜索海信家，即可 网址：https://www.haixindichan.com/ 海洋投资集团 （已上线）搜索地址即可 网址：https://www.qdoi.com.cn/ techking （已上线）搜索地址即可 网址：http://www.techking.com/ 奥科科技 （已上线）搜索地址即可 网址：http://www.oket-cn.com/ 海信网络科技 （已上线）搜索地址即可 网址：https://www.hisense-transtech.com.cn/ 海信商显（中英文） （已上线）搜索地址即可 网址：https://www.hisense-syxs.com/ 海信宽带多媒体中英文同步 （已上线）搜索地址即可 网址：http://hbmt.hisense.com/ 尼欧迪克 （已上线）搜索地址即可 网址：http://www.neotechnik-china.com/ 吉宝生物 （已上线）搜索地址即可 网址：http://keppelbio.com/ 兴和石墨 （已上线）搜索地址即可 网址：http://www.qdxhsm.com/ 山东万得福 （已上线）搜索地址即可 网址：http://www.chinaprotein.com.cn/ 正爱 （已上线）搜索地址即可 网址：http://suppoly.com/ 瑞林假发 （已上线）搜索地址即可 网址：https://www.ruilinhair.com/ IRIS官网 （已上线）搜索地址即可 网址：http://irisbrilliantco.com/ …… …… ……"},{"title":"","date":"2022-03-03T08:33:28.888Z","updated":"2022-03-03T08:33:28.888Z","comments":false,"path":"tags/index.html","permalink":"https://a-lyc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue-element-admin","slug":"vue/vue-element-admin","date":"2099-11-12T13:00:25.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2099/11/12/vue/vue-element-admin/","link":"","permalink":"https://a-lyc.github.io/2099/11/12/vue/vue-element-admin/","excerpt":"","text":"这是一个极简的 vue admin 管理后台。它只包含了 Element UI &amp; axios &amp; iconfont &amp; permission control &amp; lint，这些搭建后台必要的东西 安装方法这是一个极简的 vue admin 管理后台。它只包含了 Element UI &amp; axios &amp; iconfont &amp; permission control &amp; lint，这些搭建后台必要的东西。下载安装vue-elenemt-admin 下载admin和template，需要使用npm进行安装使用,访问地址：https://panjiachen.gitee.io/vue-admin-template/#/login?redirect=%2Fdashboard 123456789101112131415// vue-elenemt-admin# 克隆项目git clone https://github.com/PanJiaChen/vue-element-admin.git# 进入项目目录cd vue-element-admin# 安装依赖npm install# 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题npm install --registry=https://registry.npm.taobao.org# 本地开发 启动项目npm run dev 发布12345# 构建测试环境npm run build:stage# 构建生产环境npm run build:prod 其他1234567891011# 预览发布环境效果npm run preview# 预览发布环境效果 + 静态资源分析npm run preview -- --report# 代码格式检查npm run lint# 代码格式检查并自动修复npm run lint -- --fix 登录注册删除一些请求，在vue.config.js中删除，删除之后会导致登录不上去的， 1before: require('./mock/mock-server.js') 配置跨域123456789101112131415161718devServer: &#123; proxy: &#123; '/dev-api': &#123; // 重点 target: 'http://localhost:3000',// 重点 ws: true, changeOrigin: true, pathRewrite: &#123; '^/dev-api': '' &#125; &#125; &#125;, port: port, open: true, overlay: &#123; warnings: false, errors: true &#125;&#125;, 请求请求是在vuex中发出的之后保存token到浏览器，由于在router的导航首位中重复获取所以保证了一直处于登录状态请求之前保证数据库内有这个用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// login - indexthis.$store.dispatch('user/login', this.loginForm).then(() =&gt; &#123; this.$router.push(&#123; path: this.redirect || '/' &#125;) this.loading = false &#125;).catch(() =&gt; &#123; this.loading = false &#125;)// store - modules - user// 导入了请求方式import &#123; login, logout, getInfo &#125; from '@/api/user'import &#123; getToken, setToken, removeToken &#125; from '@/utils/auth' login(&#123; commit &#125;, userInfo) &#123; const &#123; username, password &#125; = userInfo return new Promise((resolve, reject) =&gt; &#123; // 网络请求 .trim()去除空格 login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123; const &#123; data &#125; = response console.log('---- 登录成功 ----') commit('SET_TOKEN', data.token) // 保存token 方便使用token来获取用户的信息 setToken(data.token) resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;,// 获取用户信息 // get user info getInfo(&#123; commit, state &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; // 网络请求获取数据 getInfo(state.token).then(response =&gt; &#123; console.log('---- 获取用户信息 ----') const &#123; data &#125; = response if (!data) &#123; return reject('验证失败，请重新登录。') &#125; const &#123; name, avatar &#125; = data // 更改数据 commit('SET_NAME', name) commit('SET_AVATAR', avatar) resolve(data) &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;, axios请求在api文件夹中创建user.js之后关于用户的请求在这 12345678910import request from '@/utils/request'// 传输账号密码，获取tokenexport function login(data) &#123; return request(&#123; url: '/users/login', method: 'post', data &#125;)&#125; layout自己理解的机制在layout文件夹：是一个公共文件这个文件属于公共信息，之后可以直接引入类似于nuxt.js这个layout作为父级其他的作为子集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)/* Layout */import Layout from '@/layout' &#123; path: '/example', // 名称 component: Layout, // 父组件 组件 redirect: '/example/table', // 重定向 name: 'example', meta: &#123; title: '展示列表', icon: 'el-icon-s-help' &#125;, children: [ // 组件的孩子 &#123; path: 'edit', name: 'edit', component: () =&gt; import('@/views/table/edit'), meta: &#123; title: '新闻添加', icon: 'el-icon-s-help' &#125; &#125;, &#123; path: 'table', name: 'table', component: () =&gt; import('@/views/table/index'), meta: &#123; title: '新闻列表', icon: 'table' &#125; &#125; ] &#125;, &#123; path: '/nested', component: Layout, redirect: '/nested/menu1', name: 'nested', meta: &#123; title: '内容', icon: 'nested' &#125;, children: [ &#123; path: 'menu1', component: () =&gt; import('@/views/nested/menu1/index'), // Parent router-view name: 'menu1', meta: &#123; title: 'Menu1' &#125;, children: [ &#123; path: 'menu1-2', component: () =&gt; import('@/views/nested/menu1/menu1-2'), name: 'menu1-2', meta: &#123; title: '菜单-2' &#125;, children: [ &#123; path: 'menu1-2-1', component: () =&gt; import('@/views/nested/menu1/menu1-2/menu1-2-1'), name: 'menu1-2-1', meta: &#123; title: '菜单-2-1' &#125; &#125;, &#123; path: 'menu1-2-2', component: () =&gt; import('@/views/nested/menu1/menu1-2/menu1-2-2'), name: 'menu1-2-2', meta: &#123; title: '菜单-2-2' &#125; &#125; ] &#125; ] &#125;, ] &#125;, h2全局导航首位 router在这个文件permission.js组件生命周期操作路由 1234567891011121314// 路由进入的时候beforeRouteEnter(to, from, next) &#123; console.log('---- 4 ----') console.log(to) console.log(from) next()&#125;,// 路由离开之前beforeRouteLeave(to, from, next) &#123; console.log('---- 5 ----') console.log(to) console.log(from) next()&#125;, element上传图片上传插件：:before-upload=’beforeUpload’ 12345678910111213141516beforeUpload(file) &#123; console.log('用户上传之前') let param = new FormData() param.append('files', file) getUpImage(param).then(res =&gt; &#123; this.tempUrl = res.data.url this.dataObj = &#123; url: res.data.url, name: res.data.originalname, filename: res.data.filename, uid: file.uid &#125; this.emitInput(res.data.url) &#125;) return true &#125; 例子templatetemplate自己定义模板这个需要有后端的支持 template自己定义模板 选要后端支持 npm i node+express+mongoose后端模板","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue-element-admin","slug":"vue-element-admin","permalink":"https://a-lyc.github.io/tags/vue-element-admin/"}]},{"title":"vue3.0X更新文档","slug":"vue/vue3.0X更新文档","date":"2099-10-24T03:04:50.000Z","updated":"2022-03-03T08:33:28.840Z","comments":true,"path":"2099/10/24/vue/vue3.0X更新文档/","link":"","permalink":"https://a-lyc.github.io/2099/10/24/vue/vue3.0X%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3/","excerpt":"","text":"Vue 3.0 项目初始化第一步，安装 vue-cli：1npm install -g @vue/cli 安装成功后，我们即可使用 vue 命令，测试方法 12$ vue -V@vue/cli 4.3.1 第二步，初始化 vue 项目： 1vue create vue-next-test 输入命令后，会出现命令行交互窗口，这里我们选择 Manually select features： 1234Vue CLI v4.3.1? Please pick a preset: default (babel, eslint) ❯ Manually select features 随后我们勾选：Router、Vuex、CSS Pre-processors 和 Linter / Formatter，这些都是开发商业级项目必须的： 123456789101112Vue CLI v4.3.1? Please pick a preset: Manually select features? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◉ Vuex ◉ CSS Pre-processors❯◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 注意：Vue 3.0 项目目前需要从 Vue 2.0 项目升级而来，所以为了直接升级到 Vue 3.0 全家桶，我们需要在 Vue 项目创建过程中勾选 Router 和 Vuex，所以避免手动写初始化代码 Vue 3.0 基本特性体验 创建路由 router/index123456789101112131415161718192021222324252627282930import &#123; createRouter, createWebHashHistory &#125; from 'vue-router'import Home from '../views/Home.vue'const routes = [ &#123; path: '/home', name: 'Home', component: Home,// 父组件模板 Layout 机制 redirect: '/dashboard', // 重定向 meta: &#123; title: '标题', icon: 'dashboard' &#125; // mate标签， 可做权限设置 children:[&#123; path: 'dashboard',// 连接是/home/dashboard name: 'Dashboard', // 和模板文件最好对应 component: () =&gt; import('@/views/dashboard/index'), // 模板文件路径 meta: &#123; title: '标题', icon: 'dashboard' &#125; // mate标签， 可做权限设置 &#125;] &#125;, &#123; path: '/about', name: 'About', component: () =&gt; import(/* webpackChunkName: \"about\" */ '../views/About.vue') &#125;]const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes&#125;)export default router 初始化 Vue Router 的过程与 3.0 版本变化不大，只是之前采用构造函数的方式，这里改为使用 createRouter 来创建 Vue Router 实例，建一个公共的layout文件是一个公共的文件header和footer公用 都是home的子文件所以改变的是router-view这个状态可以使用循环来便利路由内的标题1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;div class=\"nav\"&gt; &lt;router-link to=\"/home/dashboard\"&gt;首页&lt;/router-link&gt; | &lt;router-link to=\"/home/index\"&gt;关于我们&lt;/router-link&gt; | &lt;router-link to=\"/home/Content\"&gt;内容 - Content&lt;/router-link&gt; &lt;/div&gt; ==========================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;router-view :key=\"key\"/&gt; // key() &#123;return this.$route.path&#125;, ==========================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;h1&gt;footer&lt;/h1&gt; &lt;div class=\"nav\"&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; | &lt;router-link to=\"/about/index\"&gt;关于我们&lt;/router-link&gt; | &lt;router-link to=\"/about/Content\"&gt;内容 - Content&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; app.vue 放置内容的一个12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt; watch的应用· watch监听器可以监听一个getter函数 这个getter要返回一个响应式对象 当该对象更新后，会执行对应的回调函 123456import &#123; reactive, watch &#125; from 'vue'const state = reactive(&#123; count: 0 &#125;)watch(() =&gt; state.count, (newValue, oldValue) =&gt; &#123; // 因为watch被观察的对象只能是getter/effect函数、ref、热active对象或者这些类型是数组 // 所以需要将state.count变成getter函数&#125;) · watch可以监听响应式对象 1234import &#123; ref, watch &#125; from 'vue' const count = ref(0) watch(count, (newValue, oldValue) =&gt; &#123;&#125;) · watch可以监听多个响应式对线，任何一个响应式对象更新，就会执行回调函数 12345678910import &#123; ref, watch &#125; from 'vue' const count = ref(0) const count2 = ref(1) watch([count, count2], ([newCount, newCount2], [oldCount, oldCount2]) =&gt; &#123; &#125;)//还有第二种写法watch([count, count2], (newValue, oldVlaue) =&gt; &#123; console.log(newValue)//[newCount, newCount2] console.log(oldValue)//[oldCount, oldCount2]&#125;) 状态和事件绑定Vue 3.0 中定义状态的方法改为类似 React Hooks 的方法，下面我们在 Test.vue 中定义一个状态 count：setup(){}函数内return 出的值可以使用this访问的到 这里面无法访问methods和data中的内容点击事件@click=“click” 获取ref的时候和vue2.0一样 ref=‘refs’ 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=\"test\"&gt; &lt;h1 :ref='countOne'&gt;test count: &#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref &#125; from 'vue' export default &#123; setup () &#123;// 设置默认值位0 const count = ref(0) return &#123; count &#125; &#125;, methods:&#123; countOne(el)&#123; // 组件返回的是一个Proxy 可以直接点后面跟着方法即可 // 非组件返回dom console.log(el) // 直接点可以直接调出来即可 console.log(el.message) &#125; &#125; &#125;&lt;/script&gt; Vue 3.0 中初始化状态通过 setup 方法，组件也可使用定义状态需要调用 ref 方法。接下来我们定义一个事件，用来更新 count 状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;template&gt; &lt;div class=\"about\"&gt;&lt;input type=\"text\" v-model=\"text\"&gt; &lt;h3&gt;&#123;&#123;text&#125;&#125;&lt;/h3&gt; &lt;h1&gt;&#123;&#123;count02&#125;&#125;&lt;/h1&gt; &lt;h1&gt; 关于我们 &#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;div&gt;count, test： &#123;&#123;test&#125;&#125;, doubleCount：&#123;&#123;doubleCount&#125;&#125;, a：&#123;&#123;a&#125;&#125; &lt;/div&gt; &lt;h1 @click=\"add\"&gt;add&lt;/h1&gt; &lt;h1 @click=\"update\"&gt;update&lt;/h1&gt; &lt;h1 @click=\"getgreet\"&gt;methods ====&gt;&gt;&gt;&gt; getgreet&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, computed, watch, getCurrentInstance, onMounted,onRenderTracked,onRenderTriggered, onBeforeMount,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted, onErrorCaptured &#125; from \"vue\"; export default &#123; name:'about', // 初始化数据使用，生命周期使用 需要在里面定义请求函数，来请求初始化数据 // 监听不到data和methods内的数据 setup() &#123; // 方法获取当前组件的实例 console.log(getCurrentInstance()); const &#123; ctx &#125; = getCurrentInstance(); // 获取当前实例 onBeforeMount(()=&gt;&#123; console.log(\"在挂载开始之前被调用\") &#125;) onRenderTracked(() =&gt; &#123; console.log('渲染跟踪'); &#125;); onBeforeUnmount(()=&gt;&#123; console.log(\"实例销毁之前调用\") &#125;) onBeforeUpdate(()=&gt;&#123; console.log(\"数据更新时调用\") &#125;) onUnmounted(()=&gt;&#123; console.log(\"组件已完成了销毁\") &#125;) onErrorCaptured(()=&gt;&#123; console.log(\"在错误捕获\") &#125;) onUpdated(()=&gt;&#123; console.log(\"页面也完成了更新\") &#125;) onMounted(() =&gt; &#123; console.log(\"挂载后 &gt;&gt;&gt;&gt;&gt;&gt;01\"); &#125;); onRenderTriggered(() =&gt; &#123; console.log('渲染 - 触发') &#125;); // 页面加载的时候触发 const count = ref(0); const count02 = ref('文字'); const text = ref('文字'); let test = ref(\"我们都是好孩子\"); // 定义test默认显示内容 // 获取当前路由 console.log(ctx.$router.currentRoute.value); // 页面加载前计算属性获取vuex上的属性 const a = computed(() =&gt; ctx.$store.state.test.a); const update = () =&gt; &#123; // 修改vuex的信息 ctx.$store.commit(\"setTestA\", count.value * 10); count.value = count.value*10 console.log(ctx.$store.state.test.a); &#125;; const add = () =&gt; &#123; // 点击动作 test.value = \"我是好人\"; // 修改值 count.value++; // count加一 &#125;; watch(() =&gt; &#123; // 页面加载就读取这个信息 监听属性的变化 console.log(\"---- 页面加载就读取这个信息 监听属性的变化 ----\"); console.log(count); count.value; &#125;,(val) =&gt; &#123; console.log(\"---- 页面加载就读取这个信息 ----\"); console.log(`count is $&#123;val&#125;`); &#125; ); // 计算属性获取和写入 const doubleCount = computed(()=&gt;&#123; // 计算属性获取 count.value * 2 return count.value * 2; &#125;); return &#123; // 和vue2的data 默认在上面ref('')定义 返回定义的对象 count, count02, test, doubleCount, add, a, update, text &#125;; &#125;, // 数据改变的时候使用，事件数据，表单数据 - 和原先的data一样 data()&#123; return &#123; &#125; &#125;, mounted() &#123; // 这个比上面的on要晚 console.log('挂载后 &gt;&gt;&gt;&gt;&gt;&gt;02') &#125;, methods: &#123; getgreet() &#123; console.log(\"---- methods的点击动作 ----\"); this.count02 = \"四叶草02\" console.log(this.doubleCount) this.count = 10 console.log(\"---- end methods的点击动作 ----\"); &#125;, &#125;, watch:&#123; count(old,newVal)&#123; console.log(old,newVal) &#125; &#125; &#125;;&lt;/script&gt; 这里的 add(点击动作的方法) 方法不再需要定义在 methods 中，这样会造成setup内代码复杂化，找不到那个但注意更新 count 值的时候不能直接使用 count++，而应使用 count.value++，更新代码后，点击按钮，count 的值就会更新了：在 methods 中不需要count.value++ 直接 count++ 即可 计算属性和监听器Vue 3.0 中计算属性和监听器的实现依赖 computed 和 watch 方法： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=\"test\"&gt; &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;div&gt;count * 2 = &#123;&#123;doubleCount&#125;&#125;&lt;/div&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, computed, watch &#125; from 'vue' export default &#123; setup () &#123; const count = ref(0) const add = () =&gt; &#123; count.value++ &#125; watch(() =&gt; count.value, val =&gt; &#123; console.log(`count is $&#123;val&#125;`) &#125;) const doubleCount = computed(() =&gt; count.value * 2) return &#123; count, doubleCount, add &#125; &#125; &#125;&lt;/script&gt; 计算属性 computed 是一个方法，里面需要包含一个回调函数，当我们访问计算属性返回结果时，会自动获取回调函数的值： 1const doubleCount = computed(() =&gt; count.value * 2) 监听器 watch 同样是一个方法，它包含 2 个参数，2 个参数都是 function： script1234watch(() =&gt; count.value, val =&gt; &#123; console.log(`count is $&#123;val&#125;`) &#125;) 第一个参数是监听的值，count.value 表示当 count.value 发生变化就会触发监听器的回调函数，即第二个参数，第二个参数可以执行监听时候的回调 如果是2 个以上的监听属性 就这样 1234567watch( [refA, () &#x3D;&gt; refB.value], ([a, b], [prevA, prevB]) &#x3D;&gt; &#123; console.log(&#96;a is: $&#123;a&#125;&#96;) console.log(&#96;b is: $&#123;b&#125;&#96;) &#125;) 获取路由Vue 3.0 中通过 getCurrentInstance 方法获取当前组件的实例，然后通过 ctx 属性获得当前上下文， ctx.$router 是 Vue Router 实例，里面包含了 currentRoute 可以获取到当前的路由信息 12345678910&lt;script&gt; import &#123; getCurrentInstance &#125; from &#39;vue&#39; export default &#123; setup () &#123; const &#123; ctx &#125; &#x3D; getCurrentInstance() console.log(ctx.$router.currentRoute.value) &#125; &#125;&lt;&#x2F;script&gt; axios配置axios 123456789101112131415161718192021222324252627282930313233343536373839404142434445const axios = require('axios')//git请求export function request(config) &#123; // 定义一个url为空，开发环境为‘/api’，非开发环境为线上地址 let apiurl = '' // 判断环境 if(process.env.NODE_ENV === 'development')&#123; apiurl = '/api'; &#125;else &#123; apiurl = 'http://www.baidu.com/api' &#125; // 1.1.创建axios的实例 const instance = axios.create(&#123; baseURL: apiurl, &#125;) // 2.axios的拦截器 // 2.1.请求拦截的作用 instance.interceptors.request.use(config =&gt; &#123; /** * 在这里写请求时候的token，等添加到请求之前的信息 * 在此之前可以通过路由导航首位获取token，之后根据vuex来去添加token * 也可以保存到浏览器内，在浏览器内获取 */ console.log(\"请求拦截器\") return config &#125;,err =&gt; &#123; return err.data &#125;) // 2.2.响应拦截 instance.interceptors.response.use(res =&gt; &#123; console.log(\"响应拦截\") /** * 返回来的数据，由于返回数据很多，截取code和data重要输出数据返回到页面进行渲染 **/ return res.data &#125;,err =&gt; &#123; return err.data &#125;) // 3.发送真正的网络请求 return instance(config)&#125; vue.confing.js - 跨域配置 12345678910111213141516module.exports = &#123; devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://localhost:3000/', //接口域名 changeOrigin: true, //是否跨域 ws: true, //是否代理 websockets secure: true, //是否https接口 pathRewrite: &#123; //路径重置 '^/api': '' &#125; &#125; &#125; &#125;&#125;; 配置请求方式 12345678910111213141516import &#123;request&#125; from \"./index\";export function del(id)&#123; return request(&#123; url: `/goods/del?id=$&#123;id&#125;`, method:'get' &#125;)&#125;export function amend(data)&#123; return request(&#123; url: `/goods/amend`, data:data, method:'post' &#125;)&#125; 组件中使用 1234const $api = require('@/api/ceshi.js')$api.getHomeMultidata().then(res=&gt;&#123; message.value = res.data&#125;) 开放api接口 需要建一个api.js文件，之后把全部的api接口导入进去，之后在min.js进行导入，之后开放这个api接口 1234// 导入api内容import api from './api/api'// 开放api接口Vue.prototype.$api = api Vuex 的集成方法如下：定义 Vuex 状态第一步，修改 src/store/index.js 文件： 123456789101112131415161718192021import Vuex from &#39;vuex&#39;export default Vuex.createStore(&#123; state: &#123; test: &#123; a: 1 &#125; &#125;, mutations: &#123; setTestA(state, value) &#123; state.test.a &#x3D; value &#125; &#125;, actions: &#123; ceshi()&#123; console.log(&#39;我是一直存在的，在这获取token和用户信息&#39;) &#125; &#125;, modules: &#123; &#125;&#125;) Vuex 的语法和 API 基本没有改变,我们在 state 中创建了一个 test.a 状态，在 mutations 中添加了修改 state.test.a 状态的方法： setTestAactions s是调用就执行的一个，可以在router的导航守卫的时候进入之前巧用，期间在这获取token和用户信息，之后保存到state中，这样即可保证刷新不会没有数据等使用方法：store.dispatch(‘ceshi’)（需要先导入 imputed store from ‘vuex的路径’） 引用 Vuex 状态第二步，在 Test.vue 中，通过计算属性使用 Vuex 状态： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class&#x3D;&quot;test&quot;&gt; &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;&#x2F;h1&gt; &lt;div&gt;count * 2 &#x3D; &#123;&#123;doubleCount&#125;&#125;&lt;&#x2F;div&gt; &lt;div&gt;state from vuex &#123;&#123;a&#125;&#125;&lt;&#x2F;div&gt; &lt;button @click&#x3D;&quot;add&quot;&gt;add&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; ref, computed, watch, getCurrentInstance &#125; from &#39;vue&#39; export default &#123; setup () &#123; const count &#x3D; ref(0) const add &#x3D; () &#x3D;&gt; &#123; count.value++ &#125; watch(() &#x3D;&gt; count.value, val &#x3D;&gt; &#123; console.log(&#96;count is $&#123;val&#125;&#96;) &#125;) const doubleCount &#x3D; computed(() &#x3D;&gt; count.value * 2) const &#123; ctx &#125; &#x3D; getCurrentInstance() console.log(ctx.$router.currentRoute.value) &#x2F;&#x2F; 更改vuex的值：ctx.$store.state.test.a const a &#x3D; computed(() &#x3D;&gt; ctx.$store.state.test.a) return &#123; count, doubleCount, add, a &#125; &#125; &#125;&lt;&#x2F;script&gt; 这里我们通过计算属性来引用 Vuex 中的状态：const a = computed(() =&gt; ctx.$store.state.test.a)ctx 是上节中我们提到的当前组件实例 更新 Vuex 状态更新 Vuex 状态仍然使用 commit 方法，这点和 Vuex 3.0 版本一致： 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class&#x3D;&quot;test&quot;&gt; &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;&#x2F;h1&gt; &lt;div&gt;count * 2 &#x3D; &#123;&#123;doubleCount&#125;&#125;&lt;&#x2F;div&gt; &lt;div&gt;state from vuex &#123;&#123;a&#125;&#125;&lt;&#x2F;div&gt; &lt;button @click&#x3D;&quot;add&quot;&gt;add&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;update&quot;&gt;update a&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; ref, computed, watch, getCurrentInstance &#125; from &#39;vue&#39; export default &#123; setup () &#123; const count &#x3D; ref(0) const add &#x3D; () &#x3D;&gt; &#123; count.value++ &#125; watch(() &#x3D;&gt; count.value, val &#x3D;&gt; &#123; console.log(&#96;count is $&#123;val&#125;&#96;) &#125;) const doubleCount &#x3D; computed(() &#x3D;&gt; count.value * 2) const &#123; ctx &#125; &#x3D; getCurrentInstance() console.log(ctx.$router.currentRoute.value) const a &#x3D; computed(() &#x3D;&gt; ctx.$store.state.test.a) const update &#x3D; () &#x3D;&gt; &#123; ctx.$store.commit(&#39;setTestA&#39;, count) &#125; return &#123; count, doubleCount, add, a, update &#125; &#125; &#125;&lt;&#x2F;script&gt; 这里我们点击 update a 按钮后，会触发 update 方法，此时会通过 ctx.$store.commit 调用 setTestA 方法，将 count 的值覆盖 state.test.a 的值 render函数新建一个js文件之后直接写js即可 1234567891011121314151617// jsx 写法，很多需要自己去查写法，比如文字在div中显示不出来，在span标签中显示出来export default &#123; data()&#123; return &#123; red:'red', cont:1 &#125; &#125;, render() &#123;let text = `&lt;div class=\"works-wrapper\" class=\"$&#123;this.red&#125;\"&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;/div&gt;` return text &#125;, methods: &#123; &#125;,&#125; 使用方法1import 命名的名称 from \"@/components/render的js文件.js\"; 在render中使用在模板中导入直接使用 - 和模板一个使用方式 遇到的问题背景图片问题如果背景在div的style标签上显示不出来的时候，需要添加 require(‘图片的路径’)，下面由魔法字符串组成 1234&lt;div class=\"machine-bg\" :style=\"&#123; backgroundImage:`url($&#123;require('../common/sprite-map.jpg')&#125;)` &#125;\"&gt; &lt;/div&gt; 如何让使用ref在vue3.0之后的是 :ref=’fangfa’;这个是在方法内获取需要区别，第一个不带：是点页面加载没有直接打印出来的，:ref=’’ 是页面加载的时候同时加载了 12345678910&lt;div class=\"machine-bg\" ref='refss' @click='click' :ref='fangfa'&gt; &lt;/div&gt; methods: &#123; click()&#123; console.log(this.$refs['refss']) &#125;, fangfa(el)&#123; console.log(el) &#125; &#125;, 组件上使用v-model默认情况下，v-model在组件上modelValue用作道具和update:modelValue事件。我们可以通过将参数传递给来修改这些名称v-model：监听组件内v-model 的input属性title值的变化 1&lt;my-component v-model:title=\"bookTitle\"&gt;&lt;/my-component&gt; 在这种情况下，子组件将期望一个title prop并发出update:title事件以进行同步update是input更新事件，这个为标识 123456789101112app.component('my-component', &#123; props: &#123; title: String &#125;, emits: ['update:title'], template: ` &lt;input type=\"text\" :value=\"title\" @input=\"$emit('update:title', $event.target.value)\"&gt; `&#125;) 1&lt;my-component v-model:title=\"bookTitle\"&gt;&lt;/my-component&gt; 通过利用我们以前通过v-model参数来针对特定道具和事件的能力，我们现在可以在单个组件实例上创建多个v-model绑定。 每个v模型将同步到不同的prop，而无需在组件中使用其他选项： 123456789101112131415161718192021222324 // 使用&lt;user-name v-model:first-name=\"firstName\" v-model:last-name=\"lastName\"&gt;&lt;/user-name&gt; // 组件app.component('user-name', &#123; props: &#123; firstName: String, lastName: String &#125;, emits: ['update:firstName', 'update:lastName'], template: ` &lt;input type=\"text\" :value=\"firstName\" @input=\"$emit('update:firstName', $event.target.value)\"&gt; &lt;input type=\"text\" :value=\"lastName\" @input=\"$emit('update:lastName', $event.target.value)\"&gt; `&#125;) 全局依赖注入 对所有子组件作用title：vue的依赖注入provide，injectprovide传输实例的时候需要传输一个function()provide(){return {than:this}}即可把当前实例传输进去使用的时候，inject: [‘than’],this.than即可获取注入的实例，父子孙组件使用，非父组件下的不能使用注入 script123provide: &#123; user: 'John Doe'&#125;, 使用： script1inject: ['user'], 更新之后有一个setuo script12345import &#123; provide,inject &#125; from 'vue'setup()&#123; provide('注入名称','注入属性，不能使用this，注入的是setup的内容') inject('注入来的名称')&#125; Tags: 全局依赖注入 全局挂在的类型： [key: string]: any默认： undefined用法： script123456app.config.globalProperties.foo = 'bar'// 使用 mounted()&#123; console.log(this.foo) // 'bar' &#125; 添加可以在应用程序内的任何组件实例中访问的全局属性。当键冲突时，组件的属性将具有优先权。这可以代替Vue 2.xVue.prototype扩展： 123456// vue2.0Vue.prototype.$http = () =&gt; &#123;&#125;// After vue3.0const app = createApp(&#123;&#125;)app.config.globalProperties.$http = () =&gt; &#123;&#125; 事件传输像组件和道具一样，事件名称提供了自动的大小写转换。如果在驼峰情况下从子组件发出事件，则可以在父组件中添加kebab大小的侦听器： script12this.$emit('myEvent')&lt;my-component @my-event=\"doSomething\"&gt;&lt;/my-component&gt; 可在js内定义一个emits: [‘inFocus’, ‘submit’]// 数组内是向外提供的事件名称 script123app.component('custom-form', &#123; emits: ['inFocus', 'submit']&#125;) 与props外壳一样，我们建议您在使用in-DOM模板时使用kebab-cased事件监听器。如果您使用的是字符串模板，则此限制不适用。 mixins12345678910111213141516171819202122const myMixin = &#123; data() &#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;&#125;const app = Vue.createApp(&#123; mixins: [myMixin], data() &#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created() &#123; console.log(this.$data) // =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125; &#125;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"vue3.0","slug":"vue3-0","permalink":"https://a-lyc.github.io/tags/vue3-0/"}]},{"title":"node基本插件","slug":"node/node基本插件","date":"2099-10-19T13:35:13.000Z","updated":"2022-03-03T08:33:28.812Z","comments":true,"path":"2099/10/19/node/node基本插件/","link":"","permalink":"https://a-lyc.github.io/2099/10/19/node/node%E5%9F%BA%E6%9C%AC%E6%8F%92%E4%BB%B6/","excerpt":"","text":"后端：Strapi 非常好的后端框架官网：https://strapi.io/ 使用npm1npx create-strapi-app my-project --quickstart express node框架可查官网 官网：https://www.expressjs.com.cn/starter/installing.html1npm i --save express art-template 模板插件 官网：https://aui.github.io/art-template/zh-cn/index.html1npm install --save art-template express-art-template nodemon 修改自动更新代码 node自带应该 最好全局安装1npm i nodemon -g 解析post请求体的插件1npm i --save body-parser 在Node中操作mongod数据库 使用官方的mongod包来操作· 网址gethup：https://github.com/mongodb/node-mongodb-native 使用第三方mongoose框架来操作mongoDB操作数据库 第三方包，基于mongoDB官方第三方包做了封装，名字交mongoose· 官网：http://www.mongoosejs.net/ 安装使用1npm i --save mongoose 处理excel文件的读写一、读取1. 安装 node-xlsx1npm install node-xlsx --save 2. 解析代码123456789101112131415const xlsx = require('node-xlsx'); // 解析得到文档中的所有 sheetlet sheets = xlsx.parse('xxx.xls'); // 遍历 sheetsheets.forEach(function(sheet)&#123; console.log(sheet['name']); // 读取每行内容 for(let rowId in sheet['data'])&#123; console.log(rowId); let row=sheet['data'][rowId]; console.log(row); &#125;&#125;); 二、写入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var data = [ &#123; name: 'sheet1', data: [ [ 'ID', 'Name', 'Score' ], [ '1', 'Michael', '99' ], [ '2', 'Jordan', '98' ] ] &#125;, &#123; name: 'sheet2', data: [ [ 'AA', 'BB' ], [ '23', '24' ] ] &#125;]var buffer = xlsx.build(data);// 写入文件fs.writeFile('a.xlsx', buffer, function(err) &#123; if (err) &#123; console.log(\"Write failed: \" + err); return; &#125; console.log(\"Write completed.\");&#125;); 文件解压安装node-stream-zip1npm i --save node-stream-zip 新建文件夹为fileType内有files-1605681955440.zip文件同级别的新建unapi.js,代码如下，这个是导出了一个Promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 导入压缩包const StreamZip = require('node-stream-zip');// 导入文件模块const fs = require('fs');// 插件字写 格式化时间const &#123; getNowFormatDate &#125; = require('./common/dateTime')let time = getNowFormatDate('')// 手动删除压缩包/** * path:传入路径压缩包的路径，包括文件夹和文件名 * */module.exports = function unzipCompress(path,) &#123; // 文件路径，固定的 let filesType = './fileType/' // 根据路径裁切出文件名 // let name = path.split(filesType)[1] // 查找 某个文件 测试使用 const zip = new StreamZip(&#123; file: './fileType/files-1605681955440.zip', storeEntries: true &#125;); // 返回一个promise return new Promise((res,rej)=&gt; &#123; // 错误的时候 zip.on('error', err =&gt; &#123; rej(err) &#125;); // 返回一个数组，但是会少去一个文件 let arr = [] // 在解压文件夹时，您可以侦听解压事件 - 图片重命名 zip.on('extract', (entry, file) =&gt; &#123; console.log(`Extracted $&#123;entry.name&#125; to $&#123;file&#125;`); let name = file.split('.')[1] /** * 1：旧文件所在的目录，包括文件名，2：新文件所在的目录，包括文件名，3：回调 */ fs.rename(`$&#123;file&#125;`, `./fileType/files-$&#123;Date.now()&#125;$&#123;time&#125;.$&#123;name&#125;`, err =&gt; &#123; if (err) throw err; console.log('重命名完成') arr.push(`./fileType/files-$&#123;Date.now()&#125;$&#123;time&#125;.$&#123;name&#125;`) &#125;) &#125;); // 提取所有 zip.on('ready', () =&gt; &#123; // 创建目录 // fs.mkdirSync('extracted'); // 1：unll ，2：文件路径， 3：回调函数 zip.extract(null, './fileType', (err, count) =&gt; &#123; console.log(err ? 'Extract error' : `Extracted $&#123;count&#125; entries`); res(arr) zip.close(); &#125;); &#125;); // 在加载期间为每个条目生成条目事件 zip.on('entry', entry =&gt; &#123; console.log('在加载期间为每个条目生成条目事件') // you can already stream this entry, // without waiting until all entry descriptions are read (suitable for very large archives) console.log(`XXX ： $&#123;entry.name.split('.')[1]&#125; + ./fileType/$&#123;entry.name&#125;`); &#125;); &#125;)&#125; 新建文件使用12345678910const xlsxCompress = require('./xlsx');async function name(params) &#123; xlsxCompress().then(res =&gt; &#123; console.log('---- 1 ----') console.log(res) console.log('---- 2 ----') &#125;) &#125; name() 图片批处理插件 images首先先安装npm install images文件夹：models内建立一个上传图片插件文件夹例如名字：uploadimguploadimg.js 123456789101112131415161718192021222324252627282930313233343536373839// 导入可接收图片的插件const multer = require('multer')const fs = require('fs')// 插件字写 格式化时间const &#123; getNowFormatDate &#125; = require('../common/dateTime')let time = getNowFormatDate('')// 定义图片中间件的内容const storage = multer.diskStorage(&#123; // 定义保存图片的地址 destination: function (req, file, cb) &#123; // 某个文件夹下的日期文件下的图片目录 let path = __dirname + '/../uploads/' + time // 返回这个目录 file.time = time let ifFile = fs.existsSync(path) if (ifFile)&#123; cb(null, path) &#125;else&#123; fs.mkdirSync(path) cb(null, path) &#125; &#125;, // 定义保存图片的名称，默认没有后缀名，需要添加后缀名 filename: function (req, file, cb) &#123; let suffix = file.originalname.split('.') suffix = suffix[suffix.length - 1] // console.log(suffix) // 图片使用 // let mimetype = file.mimetype.split('/')[1] cb(null, file.fieldname + '-' + Date.now() + time + '.' + suffix) &#125;&#125;)module.exports = multer(&#123; storage &#125;) router之后在router路由文件内写上传的图片批处理的过程内有一个批量压缩的文件，可以直接去除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 导入expressconst express = require('express')// 导入文件系统const fs = require('fs')// 导入路径const path = require('path')// 压缩图片插件var images = require(\"images\");// 导入压缩图片 - 批量压缩图片const imageCompress = require('../img.js')// 使用Routerconst router = express.Router()// 导入上面的图片压缩插件const upload = require('../models/uploadimg') // 上传图片并进行压缩 upload.single('files') - 必选router.post('/', upload.single('files'), async (req, res) =&gt; &#123; try &#123; let file = req.file console.log(file) // 返回的线上地址 file.url = `http://localhost:3000/uploads/$&#123;file.filename&#125;` /** *压缩图片的比例 * 上传之后直接进行压缩 *file.path：图片路径 *size：图片宽高 *save：（保存路径 - quality：保存质量） */ images(file.path).size(500).save(file.path, &#123; quality: 90&#125;) // 返回json数据 res.json(&#123; code: 20000, data: file,// 返回数据的名称 &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125;)// 删除图片router.delete('/', async (req, res) =&gt; &#123; try &#123; // 传来的数据 let body = req.body // 传来的名称 let name = body.filename // 使用node的fs删除当前图片，可以直接传路径 fs.unlinkSync(path.join(__dirname, '../uploads/' + name)) // 返回数据 res.json(&#123; code: 20000, data: [],// 返回数据的名称 message: '文件已删除',// 返回数据的名称 &#125;) &#125; catch (e) &#123; console.log('错误') console.log(e) &#125;&#125;)// 批量压缩图片router.get('/compress',async (req,res)=&gt;&#123; try&#123; // 插件时导入的 const imageCompress = require('../img.js') // 需要传入压缩路径 imageCompress('uploads') &#125; catch (e) &#123; console.log('错误') console.log(e) &#125;&#125;)// 导出这个路由module.exports = router; 批量压缩图片 - img.js1234567891011121314151617181920212223242526272829303132333435363738394041424344const images = require(\"images\");const fs = require(\"fs\");// 导入路径const WithPath = require('path')// 需要传入一个参数是文件目录const path = \"uploads\"; // 压缩后的文件夹，是否保存源文件的问题const outpath = \"compress\"; module.exports = function compress(path) &#123; // 操作文件 读取目录的内容 fs.readdir(path, function (err, files) &#123; if (err) &#123; console.log('error:\\n' + err); return; &#125; // 循环遍历当前文件目录 files.forEach(function (file) &#123; fs.stat(WithPath.join(__dirname, path + '/' + file), function (err, stat) &#123; if (err) &#123; console.log(err); return; &#125; if (stat.isDirectory()) &#123; // 如果是文件夹遍历 compress(path + '/' + file); &#125; else &#123; //遍历图片 // console.log(__dirname + '文件名:' + path + '/' + file); // console.log(WithPath.join(__dirname, path + '/' + file)) // 要处理的文件夹 var name = path + '/' + file; // 处理之后另保存的文件夹 var outName = outpath + '/' + file /** * 压缩图片的比例 * name：图片路径 * size：图片宽高 * save：（保存路径 - quality：保存质量） */ images(name).size(20).save(name, &#123; &#125;); quality: 82 &#125; &#125;); &#125;); &#125;);&#125; 附注：api接口images(file)Load and decode image from file从指定文件加载并解码图像 images(width, height)Create a new transparent image创建一个指定宽高的透明图像 images(buffer[, start[, end]])Load and decode image from a buffer从Buffer数据中解码图像 images(image[, x, y, width, height])Copy from another image从另一个图像中复制区域来创建图像 .fill(red, green, blue[, alpha])eg:images(200, 100).fill(0xff, 0x00, 0x00, 0.5) Fill image with color以指定颜色填充图像 .draw(image, x, y)Draw image on the current image position( x , y )在当前图像( x , y )上绘制 image 图像 .encode(type[, config])eg:images(“input.png”).encode(“jpg”, {operation:50}) Encode image to buffer, config is image setting.以指定格式编码当前图像到Buffer，config为图片设置，目前支持设置JPG图像质量Return buffer返回填充好的BufferNote:The operation will cut off the chain注意:该操作将会切断调用链See:.save(file[, type[, config]]) 参考:.save(file[, type[, config]]) .save(file[, type[, config]])eg:images(“input.png”).encode(“output.jpg”, {operation:50}) Encoding and save the current image to a file, if the type is not specified, type well be automatically determined according to the file, config is image setting. eg: { operation:50 }编码并保存当前图像到 file ,如果type未指定,则根据 file 自动判断文件类型，config为图片设置，目前支持设置JPG图像质量 .size([width[, height]])Get size of the image or set the size of the image,if the height is not specified, then scaling based on the current width and height获取或者设置图像宽高，如果height未指定，则根据当前宽高等比缩放 .resize(width[, height])Set the size of the image,if the height is not specified, then scaling based on the current width and height设置图像宽高，如果height未指定，则根据当前宽高等比缩放, 默认采用 bicubic 算法。 .width([width])Get width for the image or set width of the image获取或设置图像宽度 .height([height])Get height for the image or set height of the image获取或设置图像高度 images.setLimit(width, height)Set the limit size of each image设置库处理图片的大小限制,设置后对所有新的操作生效(如果超限则抛出异常) images.setGCThreshold(value)Set the garbage collection threshold设置图像处理库自动gc的阈值(当新增内存使用超过该阈值时，执行垃圾回收) images.getUsedMemory()Get used memory (in bytes)得到图像处理库占用的内存大小(单位为字节) images.gc()Forced garbage collection强制调用V8的垃圾回收机制 node的实时通讯socket.io1npm i --save socket.io 需要研究一下 。。。。。。 pdf-lib 模块可让你处理PDF，后台文件的functionLife中的psfLid.js中 sharp 可让您处理几乎所有带有图像的东西，暂时为使用。。。。。。 pkg 将Node项目捆绑到独立的可执行文件中暂时为使用。。。。。。 qrcode生成二维码前端直接使用，之后把图传给后端，或者前端把需要生成的东西传给后端后端进行生成之后返回图片 12345let canvas = this.$refs['canvas'] QRCode.toCanvas(canvas, 'sample text', function (error) &#123; if (error) console.error(error) console.log('success!')&#125;) 百度图表安装 1npm install echarts --save 简单使用： 123456789101112131415161718192021222324252627282930313233343536373839// 此方法是挂载dom之后 mounted() &#123; // 图表 - 需要页面挂在之后完成 let echart = this.$refs['echarts'] var myChart = echarts.init(echart) var option = &#123; legend: &#123;&#125;, tooltip: &#123;&#125;, dataset: &#123; // 提供一份数据。 source: [ ['product', '2015', '2016', '2017', '2018'], ['Matcha', 43.3, 85.8, 93.7], ['Milk', 83.1, 73.4, 55.1], ['Cheese', 86.4, 65.2, 82.5], ['W', 72.4, 53.9, 39.1], ['Wal=', 70, 1, 90,100], ['Waln', 70, 1, 90,100], ['Walnu', 70, 1, 90,100], ['Walnut', 70, 1, 90,100], ] &#125;, // 声明一个 X 轴，类目轴（category）。默认情况下， // 类目轴对应到 dataset 第一列。 xAxis: &#123;type: 'category'&#125;, // 声明一个 Y 轴，数值轴。 yAxis: &#123;&#125;, // 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。 series: [ &#123;type: 'bar'&#125;, &#123;type: 'bar'&#125;, &#123;type: 'bar'&#125;, &#123;type: 'bar'&#125;, ] &#125; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option) &#125;&#125;","categories":[{"name":"node","slug":"node","permalink":"https://a-lyc.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://a-lyc.github.io/tags/node/"},{"name":"node服务器，node插件","slug":"node服务器，node插件","permalink":"https://a-lyc.github.io/tags/node%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cnode%E6%8F%92%E4%BB%B6/"}]},{"title":"mongodDB数据库","slug":"node/mongodDB数据库","date":"2099-10-11T01:43:18.000Z","updated":"2022-03-03T08:33:28.812Z","comments":true,"path":"2099/10/11/node/mongodDB数据库/","link":"","permalink":"https://a-lyc.github.io/2099/10/11/node/mongodDB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"安装 网址：https://www.mongodb.com/try/download/community 下载社区级别的，免费 也就是本地的第二个 根绝菜鸟教程进行安装 网址：https://www.runoob.com/mongodb/mongodb-window-install.html 环境变量配置，把mongod的路径给到path添加上即可 我的电脑右键属性。。。。。 mongod –version =&gt; 查看是否安装很成功 启动 打开控制台输入 mongod· mongod 默认使用执行mongod命令所处盘符根目录下的/data/db作为自己的数据存储· 第一次执行mongod时候需要在根盘符创建/data/db文件夹· 在那个盘符输入，需要在哪一个盘符中创建一个/data/db 文件夹· 修改默认的储存目录 1mongod --dbpath-数据存储目录路径 停止数据库 开启服务的控制台ctrl+c，或者直接关闭数据库 停止 开启服务的控制台ctrl+c，或者直接关闭 连接数据库和退出数据库 连接之前确保开启数据库 重新打开控制台· 使用命令mongo 默认打开本机的数据库mongod服务 退出· exit 在连接状态输入exit 就是退出连接 基本命令 show dbs· 查看当前数据库列表 db· 查看当前操作的数据库 use 数据库名称· 切换到指定的数据库（如果没有会新建,没有数据show dbs命令显示不出来） db.student.insertOne({‘name’:’syc’})· 插入数据库 名称为student 插入数据 show collections· 查看数据库名称 db.student.find()· 查看数据库内容 db.dropDatabase()· 删除数据库 db.createCollection(name, options)· 创建集合 db.名称.drop()· 删除集合 在show collections查看之后删出 在Node中操作mongod数据库 使用官方的mongod包来操作· 网址gethup：https://github.com/mongodb/node-mongodb-native 使用第三方mongoose框架来操作mongoDB操作数据库 第三方包，基于mongoDB官方第三方包做了封装，名字交mongoose· 官网：http://www.mongoosejs.net/ 安装使用· npm i –save mongoose· 引入mongoose· 设计Schema· 发布model（得到模型构造函数） 所有操作基于model操作 查询，增加，修改，删除12345678910111213141516// 加载包const mongoose = require('mongoose');// 连接mongoDB数据库mongoose.connect('mongodb://localhost/test',&#123;useMongoClient:true&#125;);// 创建一个模型，设计数据库// mongoDB时动态的，非常灵活，只需要在代码中设计你的数据库就可以了// mongoose这个包就可以让你的设计编写过程变得简单// 第一个参数：表名(生成小写复数表明)，第二个参数：数据结构 表中存储的文档，有个name时字符串格式const Cat = mongoose.model('Cat', &#123; name: String &#125;);// 实例化一个Catconst kitty = new Cat(&#123; name: '四叶草' + i &#125;);// 持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow,成功')).catch(e=&gt;&#123;console.log(e)&#125;); 查看是否存进去了· 数据库的名叫test· use test中去· show collections 查看数据库名· db.cats.find() 问题 如何让在数据库中出来到最初始目录 mongoDB的基本概念 多个数据库 - 最外层的对象是数据库 一个数据库中可以有多个集合 - 是里面对象中的数组（user:[]） 一个集合当中可以有多个文档 - 是集合里面的每一个对象 文档结构没有任何限制 mongodb多个数据库表123456789101112131415&#123; QQ:&#123; users:[ &#123;dom:\"文档\"&#125;,&#123;&#125;,&#123;&#125;... ], products:[], ... &#125;, taobao:&#123; &#125;, baidu:&#123; &#125;,&#125; mongoose router文件加内的路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const express = require('express')// 引用数据模块const mongoose = require('mongoose')// 导入可接收图片的插件var multer = require('multer')// 使用Routerconst router = express.Router()// 定义图片中间件的内容var storage = multer.diskStorage(&#123; // 定义保存图片的地址 destination: function (req, file, cb) &#123; cb(null, __dirname + '/../uploads') &#125;, // 定义保存图片的名称，默认没有后缀名，需要添加后缀名 filename: function (req, file, cb) &#123; let mimetype = file.mimetype.split('/')[1] cb(null, file.fieldname + '-' + Date.now() + '.' + mimetype) &#125;&#125;)// 使用图片中间见var upload = multer(&#123; storage &#125;)const Goods = require('../models/goods')// 连接数据库 数据库的表名叫shop mongoose.connect('mongodb://localhost/shop', &#123;useNewUrlParser: true&#125;)//下面就进行判断，（连接成功，连接失败，连接断开）mongoose.connection.on('connected', function () &#123; console.log(\"连接成功 - 1\");&#125;)mongoose.connection.on('error', function () &#123; console.log(\"连接失败 - 2\");&#125;)mongoose.connection.on('disconnected', function () &#123; console.log(\"断开连接 - 3\");&#125;)//路由获取 列表router.get('/', function (req, res, next) &#123; //查询mongoDB的goods数据 Goods.find().then((doc) =&gt;&#123; res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;) &#125;).catch(err=&gt;&#123; res.json(&#123; status: '1', msg: err.message &#125;) &#125;)&#125;);// 添加router.get('/add', function (req, res, next) &#123; //查询mongoDB的goods数据 let obj = new Goods(&#123; name:'四叶草', title:'这是内容信息' &#125;) obj.save().then(doc =&gt;&#123; res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;) &#125;)&#125;);// 删除router.get('/del',(req, res, next) =&gt; &#123; let id = req.query.id Goods.remove(&#123;_id: id&#125;).then(data=&gt;&#123; res.json(&#123; data:data,// 返回数据的名称 &#125;) &#125;)&#125;)// 修改router.post('/amend',(req,res)=&gt;&#123; let data = req.body Goods.findByIdAndUpdate(data.id,&#123; name: data.name, &#125;).then(data =&gt; &#123; res.json(&#123; data: data,// 返回数据的名称 &#125;) &#125;)&#125;)// 上传upload.single('files') files上传文件类型router.post('/upImage',upload.single('files'),async (req,res)=&gt;&#123; try&#123; // 接收传来的信息 let file = req.file // 传来之后返回数据 定义返回数据的 url，方便线上访问 file.url = `http://localhost:3000/uploads/$&#123;file.filename&#125;` console.log('---- 1 ----') console.log(file) res.json(&#123; data: file,// 返回数据的名称 &#125;) &#125;catch(e)&#123; console.log(e) &#125;&#125;)module.exports = router; //暴露路由 官方指南设计Scheme，发布model Schema({opstion})：· required: 布尔值或函数 如果值为真，为此属性添加 required 验证器· default: 任何值或函数 设置此路径默认值。如果是函数，函数返回值为默认值· select: 布尔值 指定 query 的默认 projections· validate: 函数 adds a validator function for this property· get: 函数 使用 Object.defineProperty() 定义自定义 getter· set: 函数 使用 Object.defineProperty() 定义自定义 setter· alias: 字符串 仅mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets 索引· index: 布尔值 是否对这个属性创建索引· unique: 布尔值 是否对这个属性创建唯一索引· sparse: 布尔值 是否对这个属性创建稀疏索引 Stringlowercase: 布尔值 是否在保存前对此值调用 .toLowerCase()uppercase: 布尔值 是否在保存前对此值调用 .toUpperCase()trim: 布尔值 是否在保存前对此值调用 .trim()match: 正则表达式 创建验证器检查这个值是否匹配给定正则表达式enum: 数组 创建验证器检查这个值是否包含于给定数组 Numbermin: 数值 创建验证器检查属性是否大于或等于该值max: 数值 创建验证器检查属性是否小于或等于该值 Datemin: Datemax: Date网址：http://www.mongoosejs.net/docs/schematypes.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const mongoose = require('mongoose');//拿到mongoose的架构const &#123; Schema &#125; = mongoose;// 1 连接mongoDB数据库mongoose.createConnection('mongodb://localhost/test');// 2 设计文档结构 （表结构）// 就是常见的js数据类型 就是属性名称// 要求每个文档是下面的类型 Date：是日期 default: Date.now： 默认值const userSchema = new Schema(&#123; title: String, email:&#123; type:String &#125;,// 名字是title，类型String 可以不填写 userName:&#123; type:String,// 类型 default:true, // 默认值 age:&#123; type: Number, min: 18, max: 65 &#125;,//最大最小值 test: &#123; type: String, index: true, // 索引值 unique: true // Unique index. If you specify `unique: true` // specifying `index: true` is optional if you do `unique: true` &#125; &#125;, password:&#123; type:String,// 类型String,Number,Date,Buffer,Boolean,Mixed,Obj,Array required:true, // 必选项required required: [true, 'Why no bacon?'] binary: Buffer, //binary = new Buffer(0); default:'12', // 默认default date: Date.now, enum: ['Coffee', 'Tea'],// 可选项 age:&#123; // 最大值最小值 type:String, min:18, max:60 &#125;, stuff: &#123; type: String, lowercase: true, trim: true &#125; // lowercase：小写字体，trim：修剪 &#125;&#125;);// 3 将文档结构发布为模型 - 第一个参数为字符串，第二个为表架构// mongoose.model用来将一个架构发布为model// 第一个参数：传入一个大写名词但数字字符串表示你的数据库名称// mongoose会将自动大写名词的字符串生成小写复数集合名称// 举例：这里的User会变成users集合名称// 第二个参数：是架构 Schema// 返回值：模型构造函数module.exports = mongoose.model('User', userSchema);// 4 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据操作了（增删改查） 增加数据123456789101112131415161718// 4 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据操作了（增删改查）let admin = new User(&#123; userName:\"admin\", password: \"12345\", email: \"admin@admin.com\", title:\"user\"&#125;)admin.save().then((ret) =&gt; &#123; console.log(ret) res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 查询数据12345678910// 查询所有User.find().then(res=&gt;&#123; console.log('查询') res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;)&#125;).catch(err=&gt; &#123; console.log('失败')&#125;) 12345678910111213141516// 显示翻页// 根据query获取page后的参数为1，2.。。。。 let page = req.query.page let data = &#123;&#125; // page*5 - 5 = 0 =&gt;页码*也页显示条数 - 也页显示条数 // page为1的时候结果为0 page为2的时候结果为limit内的参数 // limit：一页显示多少个 skip跳过多少个显示 公式：(page-1)*5 User.find().limit(5).skip((page-1)*5).then(doc =&gt; &#123; data.doc = doc return active.find() &#125;).then(doc =&gt;&#123; data.doc2 = doc res.json(&#123; data, &#125;) &#125;) 1234567// 按条件查询 - 得到一个数组。查询多个User.find(&#123;userName:'admin'&#125;).then(res=&gt;&#123; console.log('查询') console.log(ret)&#125;).catch(err=&gt; &#123; console.log('失败')&#125;) 12345678910// 得到一个对象。直接找到第一个直接返回，没有返回第一个User.findOne(&#123;userName:'张三'&#125;).then(res=&gt;&#123; console.log('查询') res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;)&#125;).catch(err=&gt; &#123; console.log('失败')&#125;) 删除数据123456789101112131415// 删除数据User.remove(&#123;_id:'5f82a84a875939195ceff0e3'&#125;).then(res=&gt;&#123; console.log('---- 1 ----') res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;)&#125;).catch(err=&gt;&#123; console.log('---- 2 ----') console.log(err)&#125;)//根据条件删除一个User.findOneAndRemove(conditions,[options],callback)// 根据id删除一个User.findByIdAndRemove(id,[options],callback) 修改数据123456789101112131415161718// conditions:条件// 根据条件更新所有User.update(conditions,doc,[options],callback)// 根据条件更新一个User.findOneAndUpdate(conditions,doc,[options],callback)// 根据ID更新User.findByIdAndUpdate('5f82a8741c097b40345a29f6',&#123; password: '1111'&#125;).then(res=&gt;&#123; res.json(&#123; data:doc,// 返回数据的名称 count:doc.length // 返回数据的长度 &#125;)&#125;).catch(err=&gt;&#123; console.log('shibai')&#125;) express + mongoose 上传图片12345678910111213141516171819202122232425262728293031// 安装：npm i multer //express插件上有/** 在路由文件内 **/// 初始化安装var multer = require('multer')var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123;// 图片上传路径 根目录下的/../uploads 需要公开这个目录 // 返回路径：F:\\ceshiXM\\demo01\\routes/../uploads cb(null, __dirname + '/../uploads') &#125;, filename: function (req, file, cb) &#123;// 图片默认上传没有后缀的，添加后缀名称 let mimetype = file.mimetype.split('/')[1] cb(null, file.fieldname + '-' + Date.now() + '.' + mimetype) &#125;&#125;)// 导出storage 为upload// 上传 upload.single('files') 可以req结构出filerouter.post('/upImage',upload.single('files'),async (req,res)=&gt;&#123; try&#123; let file = req.file // 返回的线上地址 file.url = `http://localhost:3000/uploads/$&#123;file.filename&#125;` // 返回json数据 res.json(&#123; data: file,// 返回数据的名称 &#125;) &#125;catch(e)&#123; console.log(e) &#125;&#125;)","categories":[{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/categories/node%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/tags/node%E5%85%A5%E9%97%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://a-lyc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"node","slug":"node","permalink":"https://a-lyc.github.io/tags/node/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://a-lyc.github.io/tags/mongoDB/"}]},{"title":"数组字符串方法","slug":"js/数组字符串方法","date":"2099-05-18T13:56:36.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2099/05/18/js/数组字符串方法/","link":"","permalink":"https://a-lyc.github.io/2099/05/18/js/%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/","excerpt":"","text":"总结的数组字符串的基本应用 数组：.concat(数组名称)—–拼接数组 .filter(函数三个参数)—–返回满足函数的新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。不会改变原始数组 .forEach(函数三个参数) ———–遍历数组数组中都是执行个函数，返回这个数组 .every(函数三个参数)—– 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测 .some() 方法用于检测数组中的元素是否满足指定条件（函数提供）如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 .map(函数三个参数) 数组中的值都执行这个函数，执行后的结果，返回新的数组 .find(item =&gt; !ture)—-找到一个元素之后停止掉。方法返回数组中符合测试函数条件的第一个元素。否则返回undefined .findIndex()找到一个元素之后停止掉。方法返回数组中符合测试函数条件的第一个索引。否则返回-1 .push(值) ————— 把值追加到数组中最后一个，返回值是追加后的数组 arr.push(…arr),返回数组 let a = arr.push(…arr)返回数组长度 .pop() ————— 删除最后一个元素，并且返回删除的这个值 .shift() ———–删除数组中第一个元素的 返回值是删除的这个值 .unshift() —————像数组的前面第一个元素插入值，返回值是追加后的数组 .indexOf(元素值,开始位置) —-有这个元素值，返回的是这个元素值所在的索引，没有返回-1 .slice(x,y) 前拷贝，在x的位置开始到y的位置结束，截取后的值放置新的数组中，不包含结束索引包含的值。返回一个新数组 .splice(开始的位置，删除的个数，替换元素的值)； 一般用于删除数组中的元素或者替换元素，或者替换元素 .reduce((a,b)=&gt;{return a + b})：计算这个数组中所有数字的和，如果有字符串后面的将进行拼接 .from属性可以把对象键是索引的的对象转换成数组，可以把字符传转成数组 .includes();传入一个数组内有的值，返回true，反之返回false Array.of(3, 11, 8) // [3,11,8]将一组值转化为数组 Array.prototype.copyWithin(target, start = 0, end = this.length)它接受三个参数。target（必需）：从该位置开始替换数据。如果为负值，表示倒数。start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。这三个参数都应该是数值，如果不是，会自动转为数值。[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5]会修改当前数组 fill方法使用给定值，填充一个数组。fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 // 过滤重复的数组 123456789101112var s = new Set(); ['asdasdasdas','adsdasdasd','gggg','aaaa','gggg'].forEach(x =&gt; s.add(x)); console.log(s) for (let i of s) &#123; console.log(i); &#125;// Set转数组let set4 = new Set([4, 5, 6])//方法一 es6的...解构let arr1 = [...set4];//方法二 Array.from()解析类数组为数组let arr2 = Array.from(set4) 字符串.charAt(索引) //返回值是指定索引的字符串，超出索引结果是空字符串 .formCharCode(数值，可以是多个)；//返回的是ascii码对应的值 .concat(字符串数值可以添加多个：’nihao’,’我好’,) //拼接字符串，返回新的字符串 .indexOf(“字符串中的值”,5：从某个位置的索引) //调用这个值在字符串中的位置,是字符串‘’，没有则返回-1 .lastIndexOf(“字符串中的值”) ///从后向前找 .replace(源字符串的值,替换的值) //提花九年第一个，第一个是 被替换的，第二个是替换的，下面例子 .slice(开始，结束) //开始的数字，到结束的数字内得字符串的值如：5-10提取的是5-9的字符串，返回截取的字符串 .split(“相同的分割符”,分割多少个数组) //在一个字符传中有相同的符号，提取出来作为分割符使用，形成一个数组类型，后面传入数字，分割多少个数组， .substr(开始的位置，截取的个数) //在一个字符串中截取从开开始的索引截取，到截取多长结束 .substring(开始位置，结束位置) //在开始位置开始截取，到结束位置-1结束（不包含结束字符串） .toLocaleLowerCase() //转小写 .toLocaleUpperCase() //转大写 .trim() //去掉两端的空格 .includes()// 返回布尔值，表示是否找到了参数字符串 .startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 .endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部这三个方法(endsWith,startsWith,includes)都支持第二个参数，表示开始搜索的位置 例子：s.startsWith(‘world’, 6) repeat方法返回一个新字符串，表示将原字符串重复n次。 例子：’x’.repeat(3) // “xxx” padStart()用于头部补全，一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串’x’.padStart(4, ‘ab’) // ‘abax’’x’.padEnd(5, ‘ab’) // ‘xabab’ padEnd()用于尾部补全,一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串’x’.padStart(4, ‘ab’) // ‘abax’’x’.padEnd(5, ‘ab’) // ‘xabab’ trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格 - 它们返回的都是新字符串 Number.isInteger()用来判断一个数值是否为整数。如果参数不是数值，Number.isInteger返回false Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。它会返回五种值。参数为正数，返回+1；参数为负数，返回-1；参数为 0，返回0；参数为-0，返回-0;其他值，返回NaN。 对象的方法1：深拷贝对象，保持源对象不变 let obj = Object.assign(target = {},source) target // 目标对象 - 将源属性应用到的对象，修改后将返回该对象。 sources // 源对象—包含要应用的属性的对象。 12345let target = &#123; a: 1, b: 2 &#125;;let source = &#123; b: 4, c: 5 &#125;;const returnedTarget = Object.assign(&#123;&#125;,source);console.log(target);// expected output: Object &#123; a: 1, b: 2&#125;console.log(returnedTarget);// expected output: Object &#123; b: 4, c: 5 &#125; 2：使用现有对象作为新创建的对象的原型来创建新对象 - 创建对象的原型 proto let obj = Object.create(proto, [propertiesObject]) 方法使用现有person对象作为新创建的对象的原型来创建新对象。创建对象的原型 12345678910const person = &#123; isHuman: false, // 出现在原型上的 printIntroduction: function() &#123; console.log(`我叫$&#123;this.name&#125;. 你好 $&#123;this.isHuman&#125;`); &#125;// 出现在原型上的&#125;;const me = Object.create(person);me.name = 'Matthew'; // 出现原型之外的me.isHuman = true; // 出现原型之外的me.printIntroduction(); // 使用原型上的方法 3 方法直接在对象上定义新属性或修改现有属性，并返回该对象。- 几乎用不到 Object.defineProperties(obj, props) obj:在其上定义或修改属性的对象。 props:一个对象，其键表示要定义或修改的属性的名称，其值是描述这些属性的对象。中的每个值都props必须是数据描述符或访问器描述符；不能同时使用两者 123456789101112const object1 = &#123;&#125;;Object.defineProperties(object1, &#123; property1: &#123;//set，get，enumerable..... value: 42,// 与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 writable: true, // true当且仅当与属性关联的值可以使用赋值运算符更改时 configurable:false, // 默认false true当且仅当此属性描述符的类型可以更改并且该属性可以从相应对象中删除时 &#125;, property2: &#123;&#125;&#125;);console.log(object1.property1);// expected output: 42 4 冻结对象。冻结的对象无法再更改 Object.freeze(obj) obj - 冻结的对象 方法冻结对象。冻结的对象无法再更改；冻结对象可防止向其添加新属性，删除现有属性，防止更改现有属性的可枚举性，可配置性或可写性，并防止更改现有属性的值。此外，冻结对象还可以防止更改其原型。freeze()返回传入的相同对象。 123456const obj = &#123; prop: 42&#125;;Object.freeze(obj);obj.prop = 33;console.log(obj.prop); // 不可修改 5 方法将键值对列表转换为对象 Object.fromEntries(iterable); iterable - 可迭代如Array或Map或其他物体执行迭代协议 1234567const entries = new Map([ ['foo', 'bar'],// 多个数组无效[建,值] ['baz', 42]]);const obj = Object.fromEntries(entries);console.log(obj);// 结果: Object &#123; foo: \"bar\", baz: 42 &#125; 6 方法返回给定对象的所有自己的属性描述符。 Object.getOwnPropertyDescriptors(obj) iterable - 可迭代如Array或Map或其他物体执行迭代协议 123456789const object1 = &#123; property1: 42&#125;;const descriptors1 = Object.getOwnPropertyDescriptors(object1);console.log(descriptors1.property1);// 参考原型的参数value，writable，enumerable// 结果: Object &#123; value: 42, writable: true, enumerable: true, configurable: true &#125;console.log(descriptors1.property1.value);// 结果 : 42 7 方法确定两个值是否相同。 Object.is(value1, value2); value1 - 要比较的第一个值。 value2 - 要比较的第二个值 8 方法返回给定对象自己的可枚举属性名称的数组，并以与普通循环相同的顺序进行迭代。。 Object.keys(obj) obj - 要枚举其自身属性的对象。 123456const object1 = &#123; a: 'somestring', b: 42, c: false&#125;;console.log(Object.keys(object1)); 9 循环提供的顺序返回给定对象自己的可枚举属性值的数组 Object.values(obj) obj - 要枚举其自身属性的对象。 方法以for…in循环提供的顺序返回给定对象自己的可枚举属性值的数组。（唯一的区别是for…in循环还枚举了原型链中的属性。） 1234567const object1 = &#123; a: 'somestring', b: 42, c: false&#125;;console.log(Object.values(object1));// expected output: Array [\"somestring\", 42, false] 数组的set方法1 添加元素 add 12let list &#x3D; new Set();list.add(1) 2 删除元素 delete 12let list &#x3D; new Set([1,20,30,40])list.delete(30) &#x2F;&#x2F;删除值为30的元素，这里的30并非下标 3 判断某元素是否存在 has 12let list &#x3D; new Set([1,2,3,4])list.has(2)&#x2F;&#x2F;true 4 清除所有元素 clear 12let list &#x3D; new Set([1,2,3,4])list.clear() 5 遍历 keys() 1234let list2 &#x3D; new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])for(let key of list2.keys())&#123; console.log(key)&#x2F;&#x2F;a,b,c&#125; 6 遍历 values() 1234let list &#x3D; new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])for(let value of list.values())&#123;console.log(value)&#x2F;&#x2F;a,b,c&#125; 7 遍历 forEach() 1234let list &#x3D; new Set([&#39;4&#39;,&#39;5&#39;,&#39;hello&#39;])list.forEach(function(item)&#123; console.log(item)&#125;) 8 数组转Set (用于数组去重) 1let set2 &#x3D; new Set([4,5,6]) 9 Set转数组 12345let set4 &#x3D; new Set([4, 5, 6])&#x2F;&#x2F;方法一 es6的...解构let arr1 &#x3D; [...set4];&#x2F;&#x2F;方法二 Array.from()解析类数组为数组let arr2 &#x3D; Array.from(set4) 定时器setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。setTimeout() ：在指定的毫秒数后调用函数或计算表达式。停止定时器clearTimeout() JSON转格式 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象 接收的JSON转成JavaScript 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 JavaScript转成JSON格式传给服务器 回到顶部12document.body.scrollTop = 0document.documentElement.scrollTop = 0","categories":[{"name":"js数组字符串方法","slug":"js数组字符串方法","permalink":"https://a-lyc.github.io/categories/js%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"js 数组字符串方法 常用数组字符串api","slug":"js-数组字符串方法-常用数组字符串api","permalink":"https://a-lyc.github.io/tags/js-%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2api/"}]},{"title":"请求拦截器和响应式拦截","slug":"vue/请求拦截器和响应式拦截","date":"2099-05-01T08:11:14.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2099/05/01/vue/请求拦截器和响应式拦截/","link":"","permalink":"https://a-lyc.github.io/2099/05/01/vue/%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E6%8B%A6%E6%88%AA/","excerpt":"headers需要三个参数，url {} {}可参靠打印出来的值 ，请求之前需要做点什么和请求中处理之后发给页面做点什么，可以使用拦截器，在全局使用一下，min.js","text":"headers需要三个参数，url {} {}可参靠打印出来的值 ，请求之前需要做点什么和请求中处理之后发给页面做点什么，可以使用拦截器，在全局使用一下，min.js 12345678910111213141516171819202122232425262728293031// 添加请求拦截器axios.interceptors.request.use( (config) =&gt; &#123; // 在发送请求之前做些什么 let token = window.sessionStorage.getItem('token') if(config.token === true)&#123; config.headers['token'] = token//传输token的时候需要在第三个值内传输token = true，才可以传到headers中 &#125; console.log(config) console.log('请求之前拦截 + 成功') return config;&#125;, (error) =&gt; &#123; console.log('请求之前拦截 + 失败') // 对请求错误做些什么 return Promise.reject(error);&#125;);// 添加响应拦截器axios.interceptors.response.use((response) =&gt; &#123; console.log('请求之后 + 成功') // 对响应数据做点什么 return response;&#125;, (error) =&gt; &#123; console.log('请求之后 + 失败') //全局错误提示 if (error.response &amp;&amp; error.response.data &amp;&amp; error.response.data.errorCode) &#123; Message.error(error.response.data.msg); &#125; // 对响应错误做点什么 return Promise.reject(error);&#125;);","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue axios","slug":"vue-axios","permalink":"https://a-lyc.github.io/tags/vue-axios/"}]},{"title":"nuxt的基本组件安装","slug":"nuxt/nuxt的基本组件安装","date":"2099-01-01T02:58:16.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2099/01/01/nuxt/nuxt的基本组件安装/","link":"","permalink":"https://a-lyc.github.io/2099/01/01/nuxt/nuxt%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"中途的bug 一定熟练使用element有很大的帮助","text":"中途的bug 一定熟练使用element有很大的帮助 0：上传服务器运行 - 服务器有缓存问题，把自身的缓存关闭，之后开启服务端缓存，期间有很多bug1：状态存储到vuex中会使网页分享的时候带有用户的token，所以这个token需要在浏览器中获取之后发送网络请求，不要在vuex直接获取发送请求，会有bug2：vuex有的时候进入页面点击刷新的时候很多东西没有了，因为存储的状态管理没有了，所以导致显示或者不显示的问题，等等，如果用户的话，这个还是判断浏览器中的token有没有，在使用浏览器的token获取用户信息，之后在进行判断，以防刷新之后不显示问题3：页面数据加载不出来：因为没有正确使用asyncData数据请求，或者axios写错了位置，应该在插件目录下4：vuex中nuxtServerInit的使用， mutations内使用大写TOKEN(){},之操作一件事情5：nuxt使用node_mode中的axios的时候会报错官方解释是，所以尽量使用自己带的axios6：上传之前需要把debug: process.env._ENV == ‘production’ ? false : true, 关闭注释掉这个是检查debug模式如果您的项目中直接使用了node_modules中的axios，并且使用axios.interceptors添加拦截器对请求或响应数据进行了处理，确保使用 axios.create创建实例后再使用。否则多次刷新页面请求服务器，服务端渲染会重复添加拦截器，导致数据处理错误。 自己初始化的nuxt的模板文件 template自己定义模板 1：安装npx create-nuxt-app cd 进入环境命令：npm run dev打包编译npm run dev之后生成 dist（vue）和.nuxt（服务器:如果用中间件需要把中间件的文件一起打包发给后端，基本文件：.nuxt,state,nuxt.confige.js,package.json）npm i 之后 npm start - 项目可以跑起来了 首先新建项目安装完成npm和node，使用脚手架的命令去新建一个初始化的项目，我基本使用的是npm进行安装，输入命令行就可npx create-nuxt-app &lt;项目名&gt;选择默认初始化的项目名称，比如选择UI框架，安装axios，选择渲染方式，之后下一步下一步即可npm run dev即可进入开发环境页面内网络请求获取的数据使用asyncData获取，下面会有介绍点击动作请求数据可使用插件导出的网络请求，下面有介绍 this.$api.getInfo()使用cscc选要提前安装 npm install –save-dev node-sass sass-loader 配置nuxt.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139export default &#123; mode: 'universal', /* * 头部显示区域 - 页面组件内可以使用 * head()&#123;return&#123;title:'', * meta:[&#123;hid: '网站描述',name: 'description',content:''&#125;]&#125;&#125; * 来重定义头部标签 * */ head: &#123; title: '头部标题' || '',// meta: [ &#123; charset: 'utf-8' &#125;, &#123; content: `viewport, width=device-width, initial-scale=1, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no` &#125;, ], link: [//使用到的css可以使用link标签引入 &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125;, &#123; href: 'https://static.com/css/index.css', rel: 'stylesheet' &#125;, &#123; href: 'https://static.com/css/bootstrap.min.css', rel: 'stylesheet' &#125;, &#123; href: 'https://static.com/css/bootstrap-vue.min.css', rel: 'stylesheet' &#125; ] &#125;, /* ** loading的颜色 */ loading: &#123; color: '#000' &#125;, /** * 新加导入scss - 需要提前安装 npm install --save-dev node-sass sass-loader */ styleResources: &#123; scss: '@/assets/style/global.scss' &#125;, /* ** 外部导入的css可以直接在这显示，查看源码的时候会直接显示到页面上的 */ css: [ // 'element-ui/lib/theme-chalk/index.css' // '@/assets/css/main.scss' ], /* ** 插件配置目录，安装的插件都需要在这个位置配置，有的插件需要获取dom后者win ** 建议安装插件的时候全局安装 &#123; src: '@/plugins/map', ssr: false &#125;,可以获取dom后者win ** 这样即可使用的时候之间按照官网的文档标签使用即可 ** 插件不单独使用的是因为需要获取dom和win的原因 ** '@/plugins/api' api是封装的网络请求，下面会解释到的 */ plugins: [ '@/plugins/element-ui',//element '@/plugins/api',//封装的axios '@/plugins/bootstrap-vue',//栅格 '@/plugins/vue-moment',//格式化时间 &#123; src: '@/plugins/map', ssr: false &#125;,//地图 &#123; src: '@/plugins/vue-quill-editor', ssr: false &#125;,//富文本 &#123; src: '@/plugins/vue-cropper', ssr: false &#125;,//裁切 &#123; src: '@/plugins/md5', ssr: false &#125;//md5加密 ], /* ** Nuxt.js dev-modules */ buildModules: [], /* ** Nuxt.js modules - 请求需要 */ modules: [ // Doc: https://axios.nuxtjs.org/usage//没有的话都需要安装 '@nuxtjs/axios', '@gauseen/nuxt-proxy', '@nuxtjs/style-resources', //缓存 // '@nuxtjs/component-cache', ], /* ** Axios 配置跨域的问题，外部使用 /api/ ** See https://axios.nuxtjs.org/options */ axios: &#123; prefix: '/api/', //是否允许跨域 proxy: true, // 最多重发三次 retry: &#123; retries: 5 &#125;, //开发模式下开启debug debug: process.env._ENV == 'production' ? false : true, //设置不同环境的请求地址 baseURL: process.env._ENV == 'production' ? 'http://localhost:3000/api' : 'http://localhost:3000/api', //是否是可信任 withCredentials: true &#125;,//切换网页url不正确 - 具体是意思不明 publicRuntimeConfig: &#123; axios: &#123; browserBaseURL: process.env.BROWSER_BASE_URL &#125; &#125;,//切换网页url不正确 - 具体是意思不明 privateRuntimeConfig: &#123; axios: &#123; baseURL: process.env.BASE_URL &#125; &#125;, // 代理服务器 proxyTable: &#123; '/api/': &#123; target: 'https://www.baidu.com/api', // 线上地址 pathRewrite: &#123; '^/api/': '' &#125; &#125; &#125;, /* ** Build configuration */ build: &#123; transpile: [/^element-ui/], /* ** You can extend webpack config here */ extend( config, &#123; isDev, isClient &#125;) &#123; &#125; &#125;, // 中间件 serverMiddleware: [ '~/middleware/cookie.js' ]&#125; 获取winif (process.browser) { 逻辑} layouts文件夹layouts文件夹：是放置内容的，公共的部分可以在这个位置去引入一个组件，公共的头，footer等错误页也是在此文件夹内，error.vue,官网有详细写法这里定义的东西是全局都使用的，慎用 自定义页面布局在layouts中定义一个页面比如cishi.vue 1234567891011&lt;template&gt; &lt;div&gt; layouts &lt;nuxt&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;ceshi&#39;, &#125;&lt;&#x2F;script&gt; 如何使用呢，在page文件内的.vue文件内加入 123456789101112&lt;template&gt;&lt;div&gt; asdsadas&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; layout: &#39;ceshi&#39;, &#x2F;&#x2F;重要的是这个代码和上面定义的页面相关联 name: &#39;ceshi&#39; &#125;&lt;&#x2F;script&gt; 错误页面的定义举一个个性化错误页面的例子 layouts/error.vue: 1234567891011121314&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;h1 v-if&#x3D;&quot;error.statusCode &#x3D;&#x3D;&#x3D; 404&quot;&gt;页面不存在&lt;&#x2F;h1&gt; &lt;h1 v-else&gt;应用发生错误异常&lt;&#x2F;h1&gt; &lt;nuxt-link to&#x3D;&quot;&#x2F;&quot;&gt;首 页&lt;&#x2F;nuxt-link&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;error&#39;], layout: &#39;blog&#39; &#x2F;&#x2F; 你可以为错误页面指定自定义的布局&#125;&lt;&#x2F;script&gt; 关于页面的页面组件实际上是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项（对应 Nuxt.js 提供的功能特性）以便你能快速开发通用应用。 123456789101112131415161718192021&lt;template&gt; &lt;h1 class&#x3D;&quot;red&quot;&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;&#x2F;&#x2F; 每次在加载组件之前调用 - 初始加载数据在这位置请求，（动作方法不在这） asyncData (context) &#123;return &#123; name: &#39;World&#39; &#125;&#125;, fetch () &#123;&#125;,&#x2F;&#x2F; fetch方法用于在呈现页面之前填充存储 head () &#123;&#125;,&#x2F;&#x2F; 为此页设置元标记 layout()&#123;&#125;,&#x2F;&#x2F;指定当前页面使用的布局（layouts 根目录下的布局文件） middleware()&#123;&#125;,&#x2F;&#x2F;中间件 ...&#125;&lt;&#x2F;script&gt;&lt;style&gt;.red &#123; color: red;&#125;&lt;&#x2F;style&gt; asyncData,fetch这里需要一个axios请求，等会会写道如何进行网络请求,需要服务器端加载的数据支持seo优化的信息要全部渲染到这个位置 12345678910111213141516//这里接收一个上下文的对象；app//可以结构出stort，和自定义的插件内导出全局的方法，route//路由，params//路由参数，query，req，res，等等。见网址：https://www.nuxtjs.cn/api/contextasync asyncData (&#123;app&#125;) &#123;//结构app进来 let &#123;$api&#125; = app//app进行结构初api全局暴漏的一个api的方法，请求中自己封装的 // 下面试简单的axios请求，安装axios即可使用 let &#123; data &#125; = await axios.get('https://www.baidu.com/api/v1/config-info') //使用 Promise.all 结果是个数组$api.getHotType(id1[0].class_id) let obj = await Promise.all([ $api.getHotType(id1[0].class_id) , $api.getHotType(id1[1].class_id) , $api.getHotType(id1[2].class_id) , $api.getHotType(id1[3].class_id)]) //请求banner下面的数据 footer上面的 使用封装好的请求content进行接收 - 建议使用结构的方式 //$api.getListData()后面不要.then,直接结构data即可 let &#123;data:content&#125; = await $api.getListData() return &#123;//把数据return出去在template可以直接使用 - 最好在data中处理之后在使用，&lt;div&gt;&#123;&#123;info&#125;&#125;&lt;/div&gt; info: data.data, &#125; &#125; fetch 方法fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。类型： Function如果页面组件设置了 fetch 方法，它会在组件每次加载前被调用（在服务端或切换至目标路由之前）。fetch 方法的第一个参数是页面组件的上下文对象 context，我们可以用 fetch 方法来获取数据填充应用的状态树。为了让获取过程可以异步，你需要返回一个 Promise，Nuxt.js 会等这个 promise 完成后再渲染组件。警告: 您无法在内部使用this获取组件实例，fetch是在组件初始化之前被调用 1234async fetch (&#123; store, params &#125;)&#123; let &#123; data &#125; = await axios.get('https://www.baidu.com/stars') store.commit('setStars', data)//给vuex发送一个数据 &#125; 网络请求 - 中间件 - 用户管理，获取token - 可以不进行使用1npm install js-cookie --save 保存token的插件，可以使用中间件来使用，使用方法： 123456789const Cookies = require(\"js-cookie\") // 创建一个在整个网站上有效的cookieCookies.set('name', 'value');// 创建一个从现在起7天到期的cookie，该cookie在整个网站上均有效：Cookies.set('name', 'value', &#123; expires: 7 &#125;);// 创建一个有效的cookie，该cookie对当前页面的路径有效：Cookies.set('name', 'value', &#123; expires: 7, path: '' &#125;); 封装1234567891011121314import Cookies from 'js-cookie'const TokenKey = 'token'// 获取export function getToken() &#123; return Cookies.get(TokenKey)&#125;// 写入export function setToken(token) &#123; return Cookies.set(TokenKey, token)&#125;// 删除export function removeToken() &#123; return Cookies.remove(TokenKey)&#125; script1npm install cookie-parser 首先获取中间件，就是用户登录的时候会把token保存到cookies这里面，之后要获取token活得用户的信息，登录状态等等，安装一个cookies格式化工具方便操作 ：npm i serve cookie-parser 之后在middleware（中间件）这个文件夹内新建文件进行导入我新建的cokie.js 内容是： 123456module.exports = function (req, res, next) &#123; console.log('-**--*-*-*-*-*-*-*-*') console.log('-**--*-*- cookies *-*-*-*-*-*') next()&#125; 导入npm的之后在nuxt.confige.js中进行导入中间件 1234// 服务器中间件 serverMiddleware: [ '~/middleware/cookie.js' ] 中间件 - 官网说明中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。 每一个中间件应放置在 middleware/ 目录。文件名的名称将成为中间件名称(middleware/auth.js将成为 auth 中间件)。 一个中间件接收 context 作为第一个参数： 123export default function (context) &#123; context.userAgent = process.server ? context.req.headers['user-agent'] : navigator.userAgent&#125; 中间件执行流程顺序： nuxt.config.js匹配布局匹配页面中间件可以异步执行,只需要返回一个 Promise 或使用第2个 callback 作为第一个参数： middleware/stats.js import axios from ‘axios’ 12345export default function (&#123; route &#125;) &#123; return axios.post('http://my-stats-api.com', &#123; url: route.fullPath &#125;)&#125; 然后在你的 nuxt.config.js 、 layouts 或者 pages 中使用中间件: nuxt.config.js 12345module.exports = &#123; router: &#123; middleware: 'stats' &#125;&#125; 现在，stats 中间件将在每个路由改变时被调用。 您也可以将 middleware 添加到指定的布局或者页面: pages/index.vue 或者 layouts/default.vue 123export default &#123; middleware: 'stats'&#125; axios网络请求 - https://zh.nuxtjs.org/guide/async-data安装axios - npm install @nuxtjs/auth @nuxtjs/axios在plugibns中新建文件api.js之后写入axios的网络请求配置，为什么在plugins中，因为这个位置可以获取到上下文对象，可以结构初store和app，以及获取win和dom别的位置暂时没有找到可以结构出的，所以放在这个插件文件夹下了 - 默认导出的配置 全局都可以使用直接在asyncData中$api.getInfo()，在vue其他方法中this.$api.getInfo();inject全局暴漏导出123456789101112131415161718192021222324252627282930313233343536import apiAll from '../api/apiAll.js'//导入请求的n个地址 地址自定义export default function (&#123; app &#125;, inject) &#123; let &#123; store, $axios &#125; = app//结构出store, $axios - 自带的axios $axios.defaults.baseUrl = '/api'//设置api，nuxt.confige.js中以解释/api的来历 /** 拦截请求设置 可以做一些请求之前的操作 token **/ $axios.interceptors.request.use( function (config) &#123; //添加请求的头部，store.state.access_token这个是vuex中保存的token下面会解释到 //这个位置可以获取浏览器的win所以可以读取token，在请求拦截之前把token添加进去 //浏览器没有的话，说明不是登录状态，判断用户是否登录// if (process.browser)&#123;&#125;这个是获取浏览器的win和dom let Token = '' if (process.browser) &#123; Token = window.localStorage.getItem('token') &#125; config.headers['Authorization'] = 'Bearer ' + Token // 在发送请求之前做些什么 return config &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error) &#125; )// 2.2.响应拦截 $axios.interceptors.response.use(res =&gt; &#123;//获取的数据返回一个data return res.data &#125;, err =&gt; &#123; return err.data &#125;) inject('api', apiAll($axios))//inject全局暴漏，名字为api 导出的是这个axios&#125; apiAll.js 请求集合，自定义的地址，和上面进行对应123456789import homev2 from './homev2' //可以多个文件导入import institutionalUserv2 from './institutionalUserv2'export default function ($axios) &#123; return &#123; ...homev2($axios),//遍历导入 ...institutionalUserv2($axios) &#125;&#125; homev2的文件: 请求分开的文件12345678910111213141516171819202122232425262728293031323334/*url是个字符串可拼接axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])*/export default function ($axios) &#123; return &#123; /** * 获取数据 * */ getListData () &#123; return $axios.get('/v1/index') &#125;, /** * 热门分类 /v1/index/hot-type * */ getHotType(id,data) &#123; return $axios.post(\"/v1/index/hot-type?id=\" + id,&#123; name:data.name &#125;) &#125;, /** * 传输图片，fil格式，前提提前转froomData格式 * */ uImage(data) &#123; return $axios.post('/v1/file/images',data) &#125; &#125;&#125; vuex获取用户信息如何存储tokenif(process.browser){//获取浏览器对象cookie document.cookie = ‘token = ‘ + access_token;}如何清除tokenvar keys = document.cookie.match(/[^ =;]+(?==)/g)if (keys) { for (var i = keys.length; i–;) document.cookie = keys[i] + ‘=0;expires=’ + new Date(0).toUTCString()} window.localStorage.setItem(‘token’,token)//存window.localStorage.getItem(‘token’,token)//取window.localStorage.setItem(‘user’, JSON.stringify(content.data))//json存储JSON.parse(json); //解析为JSON对象 1234567891011121314151617181920212223242526272829303132export const state = () =&gt; (&#123; access_token: '',&#125;)export const mutations = &#123; //保存access_token ACCESS_TOKEN(state, playLoad) &#123; state.access_token = playLoad &#125;,&#125;export const actions = &#123; //每次页面加载的时候就会执行这个函数，之后可以获取到cookies保存的值，之后可以保存到vuex中， //通过plugins文件新建api文件进行网络请求以及axios的拦截等 async nuxtServerInit(&#123; commit &#125;, &#123; req,app &#125;) &#123; try &#123; let &#123; token &#125; = req.cookies //用户登录保存token if (token) &#123;//如果用户登录，这里就是true //将token报错到stat中，使用mutations内的commit方法进行保存 commit('ACCESS_TOKEN', token) // 网络请求 通过token获取用户信息保存到vuex中去 - 页面刷新会有问题 let &#123; data &#125; = await app.$api.getUserInfo(token) commit('USER', data) &#125;else &#123; &#125; &#125;catch (e) &#123; console.log(e) &#125; &#125;,&#125; 路由是根据文件的目录生成的路由_id.vue可以传输路由的参数，如果想有链接的标识，鼠标经过的时候下面显示连接使用标签：关于 路由问题多个路由传参使用_.vue 123456pages&#x2F;--| login&#x2F;-----| _.vue-----| _log-------|_.vue--| index.vue 可以在:to=”login/1/2/3”,如果有子元素的话 :to=”login/1/log/1” 传输多个参数文件夹_这个符号可以动态传参假设pages的目录结构如下 12345pages&#x2F;--| user&#x2F;-----| index.vue-----| one.vue--| index.vue 那么，Nuxt.js自动生成的路由配置如下 12345678910111213141516171819router: &#123; routes: [ &#123; name: 'index', path: '/', component: 'pages/index.vue' &#125;, &#123; name: 'user', path: '/user', component: 'pages/user/index.vue' &#125;, &#123; name: 'user-one', path: '/user/one', component: 'pages/user/one.vue' &#125; ]&#125; 你会发现名称为users-id的路由路径带有:id？参数，表示该路由是可选的。原理跟vue动态路由是一致的。 使用跳转的时候都是用nuxt-link或者this.$router.push({path:’’})，这样的话可以使用vuex 1&lt;nuxt-link :to=\"'/users/' + id?name='四叶草'\"&gt;首页&lt;/nuxt-link&gt; 动态路由在Nuxt.js里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的Vue文件或目录。以下目录结构 1234567pages&#x2F;--| _slug&#x2F;-----| comments.vue-----| index.vue--| users&#x2F;-----| _id.vue--| index.vue Nuxt.js生成对应的路由配置表为 123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: 'index', path: '/', component: 'pages/index.vue' &#125;, &#123; name: 'users-id', path: '/users/:id?', component: 'pages/users/_id.vue' &#125;, &#123; name: 'slug', path: '/:slug', component: 'pages/_slug/index.vue' &#125;, &#123; name: 'slug-comments', path: '/:slug/comments', component: 'pages/_slug/comments.vue' &#125; ]&#125; 你会发现名称为users-id的路由路径带有:id？参数，表示该路由是可选的。原理跟vue动态路由是一致的。使用跳转的时候都是用nuxt-link或者this.$router.push({path:’’})，这样的话可以使用vuex 1&lt;nuxt-link :to=\"'/users/' + id?name='四叶草'\"&gt;首页&lt;/nuxt-link&gt; 插件使用需要详细阅读官方文章： - https://zh.nuxtjs.org/guide/plugins之前默认安装element 安装富文本，图片裁切 地图，boot栅格，可以使用vue add方法进行安装，也可以npm i -d …安装安装方法安装富文本图片裁切：npm install -d vue-quill-editor quill vue-cropper官网：vue-quill-editor：https://quilljs.com/git：https://github.com/surmon-china/vue-quill-editorvue-cropper：https://github.com/xyxiao001/vue-cropper需要在plugins文件夹内注册插件注册插件：plugins文件夹内 新建js文件 - 例子：如果有导入的css的话，建议放到os上使用cdn进行引入 1234567891011121314151617import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'Vue.use(VueQuillEditor)``` 需要nuxt.config.js内进行设置```shell// nuxt.config.js plugins: [ '@/plugins/element-ui',//element '@/plugins/api',//封装的axios '@/plugins/bootstrap-vue',//栅格 '@/plugins/vue-moment',//格式化时间 &#123; src: '@/plugins/map', ssr: false &#125;,//地图 &#123; src: '@/plugins/vue-quill-editor', ssr: false &#125;,//富文本 &#123; src: '@/plugins/vue-cropper', ssr: false &#125;,//裁切 &#123; src: '@/plugins/md5', ssr: false &#125;//md5加密 ], 新建一个isMobile.js文件，路径自选，我的路径是/static/js/isMobile.js1234567891011(function() &#123; console.log(\"判断移动端\"); var sUserAgent = navigator.userAgent.toLowerCase(); if (/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(sUserAgent)) &#123; console.log(\"移动端\"); //跳转移动端页面 window.location.replace(\"xxxx\");//跳转后没有后退功能 &#125; else &#123; console.log(\"PC端\"); &#125;&#125;)(); 在nuxt.config.js加上对应配置12345head: &#123; script:[ &#123;src:'js/isMobile.js'&#125;, ] &#125;, 重新启动项目可以看到效果 打包整理服务器端上线首先npm run dev 会生成一个dist和.nuxt文件，用到的是nuxt，nuxt.config.js，static，package.json四个文件之后本地服务器端运行 npm start 富文本安装和图片裁切 - 最好安装element安装富文本quill 裁切图片：vue-croppernpm install -d vue-quill-editor quill vue-cropper在插件目录下全局引入 - 新建js文件，可以分开，可以合在一起例子： 123import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'Vue.use(VueQuillEditor) 全局引用：nuxt.config.js配置 1234567plugins: [ '@/plugins/element-ui', '@/plugins/bootstrap-vue', &#123; src: '@/plugins/map', ssr: false &#125;, &#123; src: '@/plugins/vue-quill-editor', ssr: false &#125;, &#123; src: '@/plugins/vue-cropper', ssr: false &#125;], 具体使用富文本 - nuxt使用富文本图片裁切以及element图片裁切 - nuxt单个裁切图片和多个裁切 百度地图的使用安装vue-baidu-map 1npm i vue-baidu-map -D 在plugins新建map.js: 12345import BaiduMap from &#39;vue-baidu-map&#39;import Vue from &#39;vue&#39;Vue.use(BaiduMap, &#123; ak: &#39;申请的百度地图密匙&#39;&#125;) 直接去 - Nuxt.js使用百度地图vue-baidu-map","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"nuxt的使用 nuxt的基本组件安装","slug":"nuxt的使用-nuxt的基本组件安装","permalink":"https://a-lyc.github.io/tags/nuxt%E7%9A%84%E4%BD%BF%E7%94%A8-nuxt%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"第二章：面向对象","slug":"第二章：面向对象","date":"2022-03-03T08:33:28.856Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2022/03/03/第二章：面向对象/","link":"","permalink":"https://a-lyc.github.io/2022/03/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"第二章：面向对象面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。 举例来说： 操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console对象 一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。 在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。 1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。 定义类： class 类名 { 属性名: 类型; constructor(参数: 类型){ this.属性名 = 参数; } 方法名(){ .... } } &lt;!--￼0--&gt; 使用类： const p = new Person('孙悟空', 18); p.sayHello(); &lt;!--￼1--&gt; - protected - ```typescript class Person{ protected name: string; protected age: number; constructor(name: string, age: number){ this.name = name; // 可以修改 this.age = age; } sayHello(){ console.log(`大家好，我是${this.name}`); } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age); this.name = name; //子类中可以修改 } } const p = new Person('孙悟空', 18); p.name = '猪八戒';// 不能修改 12345678910111213141516171819202122232425262728- private - &#96;&#96;&#96;typescript class Person&#123; private name: string; private age: number; constructor(name: string, age: number)&#123; this.name &#x3D; name; &#x2F;&#x2F; 可以修改 this.age &#x3D; age; &#125; sayHello()&#123; console.log(&#96;大家好，我是$&#123;this.name&#125;&#96;); &#125; &#125; class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name &#x3D; name; &#x2F;&#x2F;子类中不能修改 &#125; &#125; const p &#x3D; new Person(&#39;孙悟空&#39;, 18); p.name &#x3D; &#39;猪八戒&#39;;&#x2F;&#x2F; 不能修改 属性存取器 对于一些不希望被任意修改的属性，可以将其设置为private 直接将其设置为private将导致无法再通过对象修改其中的属性 我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器 读取属性的方法叫做setter方法，设置属性的方法叫做getter方法 示例： class Person{ private _name: string; constructor(name: string){ this._name = name; } get name(){ return this._name; } set name(name: string){ this._name = name; } } const p1 = new Person('孙悟空'); console.log(p1.name); // 通过getter读取name属性 p1.name = '猪八戒'; // 通过setter修改name属性 &lt;!--￼3--&gt; this 在类中，使用this表示当前对象 继承 继承时面向对象中的又一个特性 通过继承可以将其他类中的属性和方法引入到当前类中 示例： class Animal{ name: string; age: number; constructor(name: string, age: number){ this.name = name; this.age = age; } } class Dog extends Animal{ bark(){ console.log(`${this.name}在汪汪叫！`); } } const dog = new Dog('旺财', 4); dog.bark(); &lt;!--￼4--&gt; 在子类中可以使用super来完成对父类的引用 抽象类（abstract class） 抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例 abstract class Animal{ abstract run(): void; bark(){ console.log('动物在叫~'); } } class Dog extends Animals{ run(){ console.log('狗在跑~',this.bark()); } } &lt;!--￼5--&gt; 示例（实现） interface Person{ name: string; sayHello():void; } class Student implements Person{ constructor(public name: string) { } sayHello() { console.log('大家好，我是'+this.name); } } &lt;!--￼6--&gt; 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型 使用泛型： function test&lt;T&gt;(arg: T): T{ return arg; } &lt;!--￼7--&gt; - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式 - 方式二（指定类型）： - ```typescript test&lt;number&gt;(10) 1234567891011 - 也可以在函数后手动指定泛型- 可以同时指定多个泛型，泛型间使用逗号隔开： - &#96;&#96;&#96;typescript function test&lt;T, K&gt;(a: T, b: K): K&#123; return b; &#125; test&lt;number, string&gt;(10, &quot;hello&quot;); - 使用泛型时，完全可以将泛型当成是一个普通的类去使用 类中同样可以使用泛型： class MyClass&lt;T&gt;{ prop: T; constructor(prop: T){ this.prop = prop; } } &lt;!--￼9--&gt; 使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。","categories":[],"tags":[]},{"title":"vue服务器配置示例","slug":"node/vue服务器配置示例","date":"2022-02-27T10:32:25.000Z","updated":"2022-03-03T08:33:28.816Z","comments":true,"path":"2022/02/27/node/vue服务器配置示例/","link":"","permalink":"https://a-lyc.github.io/2022/02/27/node/vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/","excerpt":"","text":"Apache123456789&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; 也可以使用 FallbackResource 代替 mod_rewrite nginx123location / &#123; try_files $uri $uri/ /index.html;&#125; 原生 Node.js123456789101112131415161718192021const http = require('http')const fs = require('fs')const httpPort = 80http .createServer((req, res) =&gt; &#123; fs.readFile('index.html', 'utf-8', (err, content) =&gt; &#123; if (err) &#123; console.log('We cannot open \"index.html\" file.') &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8', &#125;) res.end(content) &#125;) &#125;) .listen(httpPort, () =&gt; &#123; console.log('Server listening on: http://localhost:%s', httpPort) &#125;) Express + Node.js 对于 Node.js/Express，可以考虑使用 connect-history-api-fallback 中间件。 Internet Information Services (IIS)# 安装 IIS UrlRewrite 在网站的根目录下创建一个 web.config 文件，内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;system.webServer&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\"&gt; &lt;match url=\"(.*)\" /&gt; &lt;conditions logicalGrouping=\"MatchAll\"&gt; &lt;add input=\"&#123;REQUEST_FILENAME&#125;\" matchType=\"IsFile\" negate=\"true\" /&gt; &lt;add input=\"&#123;REQUEST_FILENAME&#125;\" matchType=\"IsDirectory\" negate=\"true\" /&gt; &lt;/conditions&gt; &lt;action type=\"Rewrite\" url=\"/\" /&gt; &lt;/rule&gt; &lt;/rules&gt; &lt;/rewrite&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 其他看地址vue router后台配置：https://router.vuejs.org/zh/guide/essentials/history-mode.html#netlify","categories":[{"name":"vue服务器配置示例","slug":"vue服务器配置示例","permalink":"https://a-lyc.github.io/categories/vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/"}],"tags":[{"name":"vue服务器配置示例","slug":"vue服务器配置示例","permalink":"https://a-lyc.github.io/tags/vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/"}]},{"title":"宝塔配置","slug":"node/宝塔配置","date":"2022-02-27T10:32:25.000Z","updated":"2022-03-03T08:33:28.816Z","comments":true,"path":"2022/02/27/node/宝塔配置/","link":"","permalink":"https://a-lyc.github.io/2022/02/27/node/%E5%AE%9D%E5%A1%94%E9%85%8D%E7%BD%AE/","excerpt":"","text":"安装必要的软件 win · node.js · 宝塔（win系统） · 最好有个谷歌浏览器 解析 · 根据服务器和域名进行解析，将域名解析到当前的服务器，开放80端口 · 多解析一个为后台的而域名到这个服务器上。 宝塔安装 配置 · 需要安装数据库（myspl*），nginx（目前只知道之个，其他需要百度），等等 · 数据库应该是3306端口，可以在首页数据库点击更改 · 点击域名弹出站点修改 · 将修改配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server &#123; listen 80; server_name www.XXXXX.com XXXXX.com; index index.php index.html index.htm default.php default.htm default.html; root C:/wwwroot/www.XXXXX.com; #START-ERROR-PAGE #error_page 403 /403.html; error_page 404 /404.html; #error_page 502 /502.html; #END-ERROR-PAGE #HTTP_TO_HTTPS_START #HTTP_TO_HTTPS_END #LIMIT_INFO_START #LIMIT_INFO_END #SSL-INFO-START #SSL-INFO-END #反代清理缓存配置 location ~ /purge(/.*) &#123; proxy_cache_purge cache_one $1$is_args$args; &#125; #proxy 反向代理 include proxy/www.XXXXX.com/*.conf; #PHP-INFO-START include php/00.conf; #PHP-INFO-END #REWRITE-START include rewrite/www.XXXXX.com/*.conf; #REWRITE-END #redirect 重定向 include redirect/www.XXXXX.com/*.conf; #禁止访问的文件或目录 location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md) &#123; return 404; &#125; #一键申请SSL证书验证目录相关设置 location ~ \\.well-known&#123; allow all; &#125; access_log C:/BtSoft/wwwlogs/www.XXXXX.com.log; error_log C:/BtSoft/wwwlogs/www.XXXXX.com.error.log;&#125; · 修改反向代理 · 添加代理 目标URL：服务器IP加上端口号。如：32.234.66.111:7002 即可 · 未上线之前关闭缓存 · 反向代理之后有个配置文件，点击修改 1234567891011121314151617181920212223location /&#123; expires 12h; if ($request_uri ~* \"(php|jsp|cgi|asp|aspx)\") &#123; expires 0; &#125; proxy_pass http://服务器IP:端口号; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; proxy_set_header Accept-Encoding \"\"; sub_filter_once off; proxy_cache cache_one; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 301 302 12h;&#125;","categories":[{"name":"域名,域名链接本地地址,egg配置","slug":"域名-域名链接本地地址-egg配置","permalink":"https://a-lyc.github.io/categories/%E5%9F%9F%E5%90%8D-%E5%9F%9F%E5%90%8D%E9%93%BE%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80-egg%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"域名,域名链接本地地址,egg配置","slug":"域名-域名链接本地地址-egg配置","permalink":"https://a-lyc.github.io/tags/%E5%9F%9F%E5%90%8D-%E5%9F%9F%E5%90%8D%E9%93%BE%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80-egg%E9%85%8D%E7%BD%AE/"}]},{"title":"egg后台开发","slug":"node/egg后台开发","date":"2022-02-16T10:32:25.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2022/02/16/node/egg后台开发/","link":"","permalink":"https://a-lyc.github.io/2022/02/16/node/egg%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/","excerpt":"","text":"安装node，之后安装egg · 自己已写完一个egg，基础的增删改查，基础上写了一个后台，可在这个基础之上继续开发，对接数据库的时候很不友好。需要改进和数据库的链接 egg目录介绍 主要文件：app.js，config，app Application - app.js 新建app.js 和app文件夹是同级目录在app.js中写入方法在Controller 文件中使用的时候1console.log(this.app.cache()); 入口:app.js12345678910111213module.exports = app =&gt; &#123; app.beforeStart(async function()&#123; console.log('系统启动的时候执行 会执行这个函数 之后直接创建的数据库的表') // await app.model.sync(&#123;force:true&#125;) //每次启动删除全部的表，按照模型创建新的表 开发环境使用，会删除数据表 // sync方法会根据模型创建一个表 await app.model.sync(&#123;&#125;) &#125;) app.cache = () =&gt; &#123; console.log(app.controller); console.log('我是app.js'); return true; &#125;;&#125;; router.js撰写路由，数据在controller这里来，所有的路由都在这个位置，可以新建js导入 请求的名称，2：中间件，下面这个是判断有无token，3：controller文件夹下news.js内的list方法get请求：router.get(‘/news/list’, app.middleware.checktoken(), controller.news.list);post请求：router.post()包含增删改查的请求router.resources(‘/testCrud’,app.middleware.checktoken(), controller.testCrud)；controller需要：index：查看，create：添加；destroy：删除，update：更新例子：1234567891011121314151617181920212223242526272829303132333435363738 module.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller, io &#125; &#x3D; app; router.get(&#39;&#x2F;&#39;,controller.home.index); router.get(&#39;&#x2F;product_active&#x2F;:id&#39;,controller.home.index); router.resources(&#39;&#x2F;banner&#39;, controller.banner) &#x2F;&#x2F; socket, 指向app&#x2F;io&#x2F;controller&#x2F;chat.js的index方法 io.of(&#39;&#x2F;&#39;).route(&#39;chat&#39;, app.io.controllers.chat.index); &#125;&#96;&#96;&#96;&#96; ## controller 自我理解：是一个获取 （servic对数据库操作之后返回的信息） 之后返回给router，数据的控制器框架提供了一个 Controller 基类，并推荐所有的 Controller 都继承于该基类实现。这个 Controller 基类有下列属性：ctx - 当前请求的 Context 实例。app - 应用的 Application 实例。config - 应用的配置。service - 应用所有的 service。logger - 为当前 controller 封装的 logger 对象。在 Controller 文件中，可以通过两种方式来引用 Controller 基类：&#96;&#96;&#96;js&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js&#x2F;&#x2F; 从 egg 上获取（推荐）const Controller &#x3D; require(&#39;egg&#39;).Controller;&#x2F;&#x2F; UserController这个方法继承了Controllerclass UserController extends Controller &#123; &#x2F;&#x2F; 查询，首页展示 async index() &#123; let &#123;ctx,app&#125; &#x3D; this let data &#x3D; ctx.request.body &#x2F;&#x2F; 拿到post请求数据 let data1 &#x3D; ctx.params &#x2F;&#x2F;params &#x2F;a&#x2F;a&#x2F;a let data2 &#x3D; ctx.request.query &#x2F;&#x2F;query&amp; &#x2F;&#x2F; 获取数据库 const result &#x3D; await ctx.service.&#x2F;&#x2F; server下的js文件名&#x2F;&#x2F;js内的方法 &#x2F;&#x2F; 是个函数（） ctx.body &#x3D; &#123;result,data,data1,data2&#125; &#125;&#125;module.exports &#x3D; UserController; 配置路由映射：12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/', controller.home.index);&#125;; Service12345678910111213const Service = require('egg').Service;class NewsService extends Service &#123; /* 这里进行了数据库操作 - 已对接数据库 */ async list() &#123; let &#123; app,ctx &#125; = this; // 这个是egg内置的方法 const res1 = await app.mysql.insert('user', &#123; username: 'egg', phone: '123456789', create_time: '2021-08-16' &#125;); // 数据库原生的方法 const res = await app.mysql.query('SELECT * FROM `user` LIMIT 0, 2'); return res; &#125;&#125;module.exports = NewsService; 操作数据库使用插件：sequelized（推荐） 1234567891011121314151617181920212223242526const Service = require('egg').Service;class UserService extends Service &#123; async findAll(where) &#123; let &#123; app &#125; = this /*** * where: &#123; status: 'draft', author: ['author1', 'author2'] &#125;, // WHERE 条件 * columns: ['author', 'title'], // 要查询的表字段 * order: [['created_at','desc'], ['id','desc']], // 排序方式 * limit: 10, // 返回数据量 * offset: 0, // 数据偏移量 * 前台分页组件有时会需要查询全部记录数，这时可以直接使用count * where: &#123; * status: 1 * &#125; * */ let data = await app.model.Business.findAll(&#123; limit: where.limit*1, offset: (where.page - 1) * where.limit,order:[['display_time','desc']]&#125;) // 查询 findAll // 创建：create // 删除 destroy // 更新 update let dataList = await app.model.Business.findAll() let total = dataList.length return &#123; data, total: Math.ceil(total) &#125; &#125;&#125; 每一次用户请求，框架都会实例化对应的 Service 实例，由于它继承于 egg.Service，故拥有下列属性方便我们进行开发：this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。this.service：应用定义的 Service，通过它我们可以访问到其他业务层，等价于 this.ctx.service 。this.config：应用运行时的配置项。this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。 Middleware123456789101112131415161718192021222324// 中间件是一个函数// 使用的时候在router 通过app.middleware.checktokenfunction checktoken()&#123; // 返回的本身有两个参数 return async function(ctx,next)&#123; try&#123; console.log('我是中间件的内容') // 获取token let token = ctx.request.header.token // 校验token let ddecode = ctx.app.jwt.verify(token, ctx.app.config.jwt.secret) //ddecode.name和数据库进项校验也可以 if (ddecode.name) &#123; await next() &#125; else &#123; ctx.body = '中间件返回用户不存在' &#125; console.log(ddecode) &#125;catch(e)&#123; ctx.body = '中间件返回用户不存在 - catch' &#125; &#125;&#125;module.exports = checktoken router使用 123// 下面的请求使用了中间件 参数位：路由路径，中间件，控制器返回的内容 router.get('/jwt', app.middleware.checktoken() ,controller.jwt.index)// jwt 生成token router.get('/jwtmessage', app.middleware.checktoken(), controller.jwt.getmessage) model 创建数据库模型 不完善基本操作： 123456789101112module.exports = app =&gt; &#123; const &#123; STRING &#125; = app.Sequelize // 默认情况下Sequelize将自动传递所有的模型名称（define的第一个参数）转换为复数 // 这里会自动生成一个ID,数据库中有一个字段的名字叫做name const Banner = app.model.define('banner', &#123; name: STRING, dscription: STRING, img_url: STRING, urllink: STRING, &#125;); return Banner&#125; 关联数据库表： controller 上传文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const Controller = require('egg').Controller;const fs = require('fs');const path = require('path');const awaitWriteStream = require('await-stream-ready').write;// 重点在这const sendToWormhole = require('stream-wormhole');const dayjs = require('dayjs');module.exports = class extends Controller &#123; // 上传未指定那个文件夹 async upload() &#123; let &#123; ctx &#125; = this const stream = await this.ctx.getFileStream(); console.log('上传的文件') console.log(stream) // 定义文件名 const filename = Date.now() + path.extname(stream.filename).toLocaleLowerCase(); console.log('上传文件名') console.log(filename) // 目标文件 const target = path.join('app/public/upload', filename); console.log('目标文件') console.log(target) // const writeStream = fs.createWriteStream(target); console.log('writeStream') console.log(writeStream) try &#123; //异步把文件流 写入 await awaitWriteStream(stream.pipe(writeStream)); ctx.body = &#123; ...stream.fields, url: '/public/upload/' + filename, &#125;; &#125; catch (err) &#123; //如果出现错误，关闭管道 await sendToWormhole(stream) console.log(err) &#125; &#125; // 上传指定那个文件夹 async uploadFile() &#123; let &#123; ctx &#125; = this const stream = await ctx.getFileStream(); console.log('上传的文件') console.log(stream) // 基础的目录 const uplaodBasePath = 'app/public/upload'; console.log('基础的目录') console.log(uplaodBasePath) // 生成文件名 const filename = `$&#123;Date.now()&#125;$&#123;Number.parseInt(Math.random() * 1000,)&#125;$&#123;path.extname(stream.filename).toLocaleLowerCase()&#125;`; // 生成文件夹 const dirname = dayjs(Date.now()).format('YYYY/MM/DD'); function mkdirsSync(dirname) &#123; if (fs.existsSync(dirname)) &#123; return true; &#125; else &#123; if (mkdirsSync(path.dirname(dirname))) &#123; fs.mkdirSync(dirname); return true; &#125; &#125; &#125; mkdirsSync(path.join(uplaodBasePath, dirname)); // 生成写入路径 const target = path.join(uplaodBasePath, dirname, filename); // 写入流 const writeStream = fs.createWriteStream(target); try &#123; //异步把文件流 写入 await awaitWriteStream(stream.pipe(writeStream)); &#125; catch (err) &#123; //如果出现错误，关闭管道 await sendToWormhole(stream); &#125; ctx.body = &#123; stream,url:'/public/upload/'+dirname+'/'+filename &#125; &#125; &#125; 插件使用egg-sequelize 和 mysql21： 首先安装：npm i –save egg-sequelize msyql2egg-sequelize 1: STRING =&gt; varchar(255) 2: INTEGER =&gt; int 3: DOUBLE =&gt; double 4: DATE =&gt; datetime 5: TEXT =&gt; text2： 在plugin.js文件中引入插件12345678910// sequelize插件，实现数据持久化sequelize:&#123; enable: true, package: 'egg-sequelize',&#125;,// 引入mysql数据库2mysql2: &#123; enable: true, package: 'mysql2',&#125;, 3： 在config.default.js文件中配置这个数据库链接1234567891011121314151617// sequelized的配置文件config.sequelize = &#123; // 数据库类型 是mysql dialect:\"mysql\", // host host: 'localhost', // 端口号 port: '3306', // 用户名 username: 'exapp_admin', // 密码 password: '123456789', // 数据库名 database: 'exapp_admin', // 时区 timezone:'+08:00'&#125; 4： 在app/model文件中创建数据模型123456789101112module.exports = app =&gt; &#123; const &#123; STRING &#125; = app.Sequelize // 默认情况下Sequelize将自动传递所有的模型名称（define的第一个参数）转换为复数 // 这里会自动生成一个ID,数据库中有一个字段的名字叫做name const Banner = app.model.define('banner', &#123; name: STRING, dscription: STRING, img_url: STRING, urllink: STRING, &#125;); return Banner&#125; 5： 添加app.js文件，初始化数据库123456app.beforeStart(async function()&#123; console.log('系统启动的时候执行 会执行这个函数 之后直接创建的数据库的表') // await app.model.sync(&#123;force:true&#125;) //每次启动删除全部的表，按照模型创建新的表 开发环境使用，会删除数据表 // sync方法会根据模型创建一个表 await app.model.sync(&#123;&#125;)&#125;) 6：在service中的增删改查// 添加123456789101112131415 /*** * where: &#123; status: 'draft', author: ['author1', 'author2'] &#125;, // WHERE 条件 * columns: ['author', 'title'], // 要查询的表字段 * order: [['created_at','desc'], ['id','desc']], // 排序方式 * limit: 10, // 返回数据量 * offset: 0, // 数据偏移量 * 前台分页组件有时会需要查询全部记录数，这时可以直接使用count * where: &#123; * status: 1 * &#125; * */await app.model.Clazz.create(&#123;name:name&#125;)// 条件添加let data = await app.model.Clazz.findAll(&#123; where: &#123; id: id &#125; &#125;) // 删除1await app.model.Clazz.destroy( &#123; where: &#123; id: id &#125; &#125;) // 更新1await app.model.Clazz.update(&#123; name: name &#125;, &#123; where: &#123; id: id &#125; &#125;) // 查看123let data = await app.model.Clazz.findAll()// 按条件查看let data = await app.model.Clazz.findAll(&#123;where:&#123;id:5&#125;&#125;) 原则应该在server中实现和数据库之间的交互 12345async findAll()&#123; let &#123; app &#125; = this let data = await app.model.Clazz.findAll() return data &#125; 添加外键在Student通过asssociate属性指定外键1：创建一个名为clazz的班级表，包含ID，和name两个字段2：学生模型中添加下面的代码 123456Student.associate = function()&#123; // 所属性于那本书，指向书记的主键 app.model.Student.belongsTo(app.model.clazz,&#123; foreignKey:'clazz_id', as:'clazz' &#125;)&#125; qrcode生成二维码 简单实现，在服务器端使用生成画布二维码和生成base64的二维码 前端如何实现生成二维码的 需要导入此插件 详细网址：https://www.npmjs.com/package/qrcode 生成token 1：按住啊那个egg-jwt ： npm i –save egg-jwt 2：在plugin.js引入 12345jwt:&#123; enable: true, package: &#39;egg-jwt&#39;, secret: &#39;siyecao&#39;&#125; 3:config.default.js配置文件，设置secret，注意secret不能泄露 config.jwt = {secret:’配置的加密字符串’} 验证流程’ 1根据用户信息生成一个token 生成之后给到客户端 2客户端将生成的token保存到浏览器中 3每次请求的时候请求头携带token 4服务器一年挣的时候验证token 上传文件 multipart multipart 可以接受的默认文件大小是10mb. 如果你上传一个大文件，你应该指定这个配置 1234567config.multipart = &#123; fileSize: '50mb', whitelist: [ '.png', '.jpg', '.mp4','.docx' ], mode: 'stream',&#125; 实时通讯egg-socket.io123456789101112// 实时通讯config.io = &#123; // namespace命名空间配置为/ namespace: &#123; '/': &#123; // 预处理器中间件, 我们这里配置了一个auth, 进行权限判断, 它对应的文件是/app/io/middleware/auth.js, 这里可以配置多个文件, 用逗号隔开 connectionMiddleware: ['auth'], //这里我们可以做一些权限校验之类的操作// 开始 链接的时候 packetMiddleware: ['filter'], // 通常用于对消息做预处理，又或者是对加密消息的解密等操作 &#125; &#125;, // 配置redis, 非必须, 不需要的可以不配置这块, egg-socket.io内置了socket-io-redis， 在cluster模式下, 使用redis可以较为简单的实现clients/rooms等信息共享&#125; 模板引擎12345678910111213141516// 配置模板引擎config.view = &#123; // 配置视图根路径 root: path.join(appInfo.baseDir, 'app/view'), // 是否缓存路径 cache: true, // 配置文件默认扩展名 defaultExtension: '.html', // 默认渲染模板引擎 defaultViewEngine: 'nunjucks', // 文件映射配置 mapping: &#123; '.html': 'nunjucks' &#125; &#125; 跨域123456789101112// 跨站请求的伪造 不做这个会禁止 关于post请求的安全设置，// 图片上传问题config.security = &#123; csrf: &#123; enable: false, ignoreJSON: true, &#125;, domainWhiteList: ['http://www.hengmaikj.com'],&#125;config.cors = &#123; origin: '*', // 匹配规则 域名+端口 *则为全匹配 allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH',&#125;; 后台模板","categories":[{"name":"egg后台开发","slug":"egg后台开发","permalink":"https://a-lyc.github.io/categories/egg%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"egg后台开发","slug":"egg后台开发","permalink":"https://a-lyc.github.io/tags/egg%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"}]},{"title":"ts面向对象","slug":"ts/面向对象","date":"2022-02-15T05:48:16.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2022/02/15/ts/面向对象/","link":"","permalink":"https://a-lyc.github.io/2022/02/15/ts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"第二章：面向对象面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。 举例来说： 操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console对象 一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。 在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。 1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。 定义类： 123456789101112class 类名 &#123; 属性名: 类型; constructor(参数: 类型)&#123; this.属性名 = 参数; &#125; 方法名()&#123; .... &#125;&#125; 示例： 12345678910111213class Person&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125;&#125; 使用类： 12const p = new Person('孙悟空', 18);p.sayHello(); 2、面向对象的特点 封装 对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装 默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置 只读属性（readonly）： 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改 TS中属性具有三种修饰符： public（默认值），可以在类、子类和对象中修改 protected ，可以在类、子类中修改 private ，可以在类中修改 示例： public 1234567891011121314151617181920212223class Person&#123; public name: string; // 写或什么都不写都是public public age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以在类中修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125;&#125;class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中可以修改 &#125;&#125;const p = new Person('孙悟空', 18);p.name = '猪八戒';// 可以通过对象修改 protected 123456789101112131415161718192021222324class Person&#123; protected name: string; protected age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125;&#125;class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中可以修改 &#125;&#125;const p = new Person('孙悟空', 18);p.name = '猪八戒';// 不能修改 private 123456789101112131415161718192021222324class Person&#123; private name: string; private age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125;&#125;class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中不能修改 &#125;&#125;const p = new Person('孙悟空', 18);p.name = '猪八戒';// 不能修改 属性存取器 对于一些不希望被任意修改的属性，可以将其设置为private 直接将其设置为private将导致无法再通过对象修改其中的属性 我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器 读取属性的方法叫做setter方法，设置属性的方法叫做getter方法 示例： 1234567891011121314151617181920class Person&#123; private _name: string; constructor(name: string)&#123; this._name = name; &#125; get name()&#123; return this._name; &#125; set name(name: string)&#123; this._name = name; &#125;&#125;const p1 = new Person('孙悟空');console.log(p1.name); // 通过getter读取name属性p1.name = '猪八戒'; // 通过setter修改name属性 静态属性 静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用 静态属性（方法）使用static开头 示例： 12345678910class Tools&#123; static PI = 3.1415926; static sum(num1: number, num2: number)&#123; return num1 + num2 &#125;&#125;console.log(Tools.PI);console.log(Tools.sum(123, 456)); this - 在类中，使用this表示当前对象 继承 继承时面向对象中的又一个特性 通过继承可以将其他类中的属性和方法引入到当前类中 示例： 12345678910111213141516171819class Animal&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125;&#125;class Dog extends Animal&#123; bark()&#123; console.log(`$&#123;this.name&#125;在汪汪叫！`); &#125;&#125;const dog = new Dog('旺财', 4);dog.bark(); 通过继承可以在不修改类的情况下完成对类的扩展 重写 发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写 示例： 123456789101112131415161718192021222324252627class Animal&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125; run()&#123; console.log(`父类中的run方法！`); &#125;&#125;class Dog extends Animal&#123; bark()&#123; console.log(`$&#123;this.name&#125;在汪汪叫！`); &#125; run()&#123; console.log(`子类中的run方法，会重写父类中的run方法！`); &#125;&#125;const dog = new Dog('旺财', 4);dog.bark(); 在子类中可以使用super来完成对父类的引用 抽象类（abstract class） 抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例 123456789101112abstract class Animal&#123; abstract run(): void; bark()&#123; console.log('动物在叫~'); &#125;&#125;class Dog extends Animals&#123; run()&#123; console.log('狗在跑~',this.bark()); &#125;&#125; 使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现 3、接口（Interface）接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。 示例（检查对象类型）： 12345678910interface Person&#123; name: string; sayHello():void;&#125;function fn(per: Person)&#123; per.sayHello();&#125;fn(&#123;name:'孙悟空', sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;); 示例（实现） 12345678910111213interface Person&#123; name: string; sayHello():void;&#125;class Student implements Person&#123; constructor(public name: string) &#123; &#125; sayHello() &#123; console.log('大家好，我是'+this.name); &#125;&#125; 4、泛型（Generic）定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。 举个例子： 123function test(arg: any): any&#123; return arg;&#125; 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型 使用泛型： 123function test&lt;T&gt;(arg: T): T&#123; return arg;&#125; 这里的&lt;T&gt;就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。 那么如何使用上边的函数呢？ 方式一（直接使用）： 1test(10) - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式方式二（指定类型）： 1test&lt;number&gt;(10) 也可以在函数后手动指定泛型 可以同时指定多个泛型，泛型间使用逗号隔开： 12345function test&lt;T, K&gt;(a: T, b: K): K&#123; return b;&#125;test&lt;number, string&gt;(10, \"hello\"); 使用泛型时，完全可以将泛型当成是一个普通的类去使用 类中同样可以使用泛型： 1234567class MyClass&lt;T&gt;&#123; prop: T; constructor(prop: T)&#123; this.prop = prop; &#125;&#125; 除此之外，也可以对泛型的范围进行约束 1234567interface MyInter&#123; length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123; return arg.length;&#125; 使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。","categories":[{"name":"ts,ts面向对象","slug":"ts-ts面向对象","permalink":"https://a-lyc.github.io/categories/ts-ts%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"ts,ts面向对象","slug":"ts-ts面向对象","permalink":"https://a-lyc.github.io/tags/ts-ts%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"ts类型","slug":"ts/ts类型","date":"2022-02-15T05:48:15.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2022/02/15/ts/ts类型/","link":"","permalink":"https://a-lyc.github.io/2022/02/15/ts/ts%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"类型： 类型 例子 描述 number 1, -33, 2.5 任意数字 string ‘hi’, “hi”, hi 任意字符串 boolean true、false 布尔值true或false 字面量 其本身 限制变量的值就是该字面量的值 any * 任意类型 unknown * 类型安全的any void 空值（undefined） 没有值（或undefined） never 没有值 不能是任何值 object {name:’孙悟空’} 任意的JS对象 array [1,2,3] 任意JS数组 tuple [4,5] 元素，TS新增类型，固定长度数组 enum enum{A, B} 枚举，TS中新增类型 number let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744; let big: bigint = 100n; &lt;!--￼0--&gt; string let color: string = \"blue\"; color = 'red'; let fullName: string = `Bob Bobbington`; let age: number = 37; let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`; &lt;!--￼1--&gt; any let d: any = 4; d = 'hello'; d = true; &lt;!--￼2--&gt; void let unusable: void = undefined; &lt;!--￼3--&gt; object（没啥用） let obj: object = {}; &lt;!--￼4--&gt; tuple let x: [string, number]; x = [\"hello\", 10]; &lt;!--￼5--&gt; 类型断言 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式： 第一种 let someValue: unknown = \"this is a string\"; let strLength: number = (someValue as string).length; &lt;!--￼6--&gt;","categories":[{"name":"ts类型","slug":"ts类型","permalink":"https://a-lyc.github.io/categories/ts%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"ts类型","slug":"ts类型","permalink":"https://a-lyc.github.io/tags/ts%E7%B1%BB%E5%9E%8B/"}]},{"title":"ts快速入门","slug":"ts/ts","date":"2022-02-15T05:48:14.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2022/02/15/ts/ts/","link":"","permalink":"https://a-lyc.github.io/2022/02/15/ts/ts/","excerpt":"","text":"1、TypeScript 开发环境搭建 下载Node.js 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi 安装Node.js 使用npm全局安装typescript 进入命令行 输入：npm i -g typescript 创建一个ts文件 使用tsc对ts文件进行编译 进入命令行 进入ts文件所在目录 执行命令：tsc xxx.ts 2、基本类型 类型声明 类型声明是TS非常重要的一个特点 通过类型声明可以指定TS中变量（参数、形参）的类型 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值 语法： let 变量: 类型; let 变量: 类型 = 值; function fn(参数: 类型, 参数: 类型): 类型{ ... } &lt;!--￼0--&gt; 自动编译整个项目 如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译 配置选项： include 定义希望被编译文件所在的目录 默认值：[“**/*“] 示例： 1\"include\":[\"src/**/*\", \"tests/**/*\"] 上述示例中，所有src目录和tests目录下的文件都会被编译 exclude 定义需要排除在外的目录 默认值：[“node_modules”, “bower_components”, “jspm_packages”] 示例： 1\"exclude\": [\"./src/hello/**/*\"] 上述示例中，src下hello目录下的文件都不会被编译 extends 定义被继承的配置文件 示例： 1\"extends\": \"./configs/base\" 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息 files 指定被编译文件的列表，只有需要编译的文件少时才会用到 示例： 1234567891011\"files\": [ \"core.ts\", \"sys.ts\", \"types.ts\", \"scanner.ts\", \"parser.ts\", \"utilities.ts\", \"binder.ts\", \"checker.ts\", \"tsc.ts\" ] 列表中的文件都会被TS编译器所编译 compilerOptions 编译选项是配置文件中非常重要也比较复杂的配置选项 在compilerOptions中包含多个子选项，用来完成对编译的配置 项目选项 target 设置ts代码编译的目标版本 可选值： ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext 示例： 123\"compilerOptions\": &#123; \"target\": \"ES6\"&#125; 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码 lib 指定代码运行时所包含的库（宿主环境） 可选值： ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost …… 示例： 123456\"compilerOptions\": &#123; \"target\": \"ES6\", \"lib\": [\"ES6\", \"DOM\"], \"outDir\": \"dist\", \"outFile\": \"dist/aa.js\"&#125; module 设置编译后代码使用的模块化系统 可选值： CommonJS、UMD、AMD、System、ES2020、ESNext、None 示例： 123\"compilerOptions\": &#123; \"module\": \"CommonJS\"&#125; outDir 编译后文件的所在目录 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置 示例： 123\"compilerOptions\": &#123; \"outDir\": \"dist\"&#125; 设置后编译后的js文件将会生成到dist目录 outFile 将所有的文件编译为一个js文件 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中 示例： 123\"compilerOptions\": &#123; \"outFile\": \"dist/app.js\"&#125; rootDir 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录 示例： 123\"compilerOptions\": &#123; \"rootDir\": \"./src\"&#125; allowJs 是否对js文件编译 checkJs 是否对js文件进行检查 示例： 1234\"compilerOptions\": &#123; \"allowJs\": true, \"checkJs\": true&#125; removeComments 是否删除注释 默认值：false noEmit 不对代码进行编译 默认值：false sourceMap 是否生成sourceMap 默认值：false - 严格检查 - strict - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查 - alwaysStrict - 总是以严格模式对代码进行编译 - noImplicitAny - 禁止隐式的any类型 - noImplicitThis - 禁止类型不明确的this - strictBindCallApply - 严格检查bind、call和apply的参数列表 - strictFunctionTypes - 严格检查函数的类型 - strictNullChecks - 严格的空值检查 - strictPropertyInitialization - 严格检查属性是否初始化 - 额外检查 - noFallthroughCasesInSwitch - 检查switch语句包含正确的break - noImplicitReturns - 检查函数没有隐式的返回值 - noUnusedLocals - 检查未使用的局部变量 - noUnusedParameters - 检查未使用的参数 - 高级 - allowUnreachableCode - 检查不可达代码 - 可选值： - true，忽略不可达代码 - false，不可达代码将引起错误 - noEmitOnError - 有错误的情况下不进行编译 - 默认值：false4、webpack 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。 步骤： 初始化项目 进入项目根目录，执行命令 npm init -y 主要作用：创建package.json文件 下载构建工具 i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 - 共安装了7个包 - webpack - 构建工具webpack - webpack-cli - webpack的命令行工具 - webpack-dev-server - webpack的开发服务器 - typescript - ts编译器 - ts-loader - ts加载器，用于在webpack中编译ts文件 - html-webpack-plugin - webpack中html插件，用来自动创建html文件 - clean-webpack-plugin - webpack中的清除插件，每次构建都会先清除目录3. 根目录下创建webpack的配置文件webpack.config.js &#96;&#96;&#96;javascript const path &#x3D; require(&quot;path&quot;); const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;); const &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;); module.exports &#x3D; &#123; optimization:&#123; minimize: false &#x2F;&#x2F; 关闭代码压缩，可选 &#125;, entry: &quot;.&#x2F;src&#x2F;index.ts&quot;, devtool: &quot;inline-source-map&quot;, devServer: &#123; contentBase: &#39;.&#x2F;dist&#39; &#125;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;bundle.js&quot;, environment: &#123; arrowFunction: false &#x2F;&#x2F; 关闭webpack的箭头函数，可选 &#125; &#125;, resolve: &#123; extensions: [&quot;.ts&quot;, &quot;.js&quot;] &#125;, module: &#123; rules: [ &#123; test: &#x2F;\\.ts$&#x2F;, use: &#123; loader: &quot;ts-loader&quot; &#125;, exclude: &#x2F;node_modules&#x2F; &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&#39;TS测试&#39; &#125;), ] &#125; 根目录下创建tsconfig.json，配置可以根据自己需要 1234567&#123; \"compilerOptions\": &#123; \"target\": \"ES2015\", \"module\": \"ES2015\", \"strict\": true &#125;&#125; 修改package.json添加如下配置 123456789&#123; ...略... \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\", \"start\": \"webpack serve --open chrome.exe\" &#125;, ...略...&#125; 在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器 5、Babel","categories":[{"name":"ts,ts快速入门","slug":"ts-ts快速入门","permalink":"https://a-lyc.github.io/categories/ts-ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"ts,ts快速入门","slug":"ts-ts快速入门","permalink":"https://a-lyc.github.io/tags/ts-ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}]},{"title":"tweenmax","slug":"插件/tweenmax","date":"2021-09-26T10:32:25.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2021/09/26/插件/tweenmax/","link":"","permalink":"https://a-lyc.github.io/2021/09/26/%E6%8F%92%E4%BB%B6/tweenmax/","excerpt":"","text":"gsap NPM / 构建工具 下载安装，TweenMax的插件12npm i --save-dev gsapimport TweenMax from 'gsap' 默认使用ES 模块。您可以导入单个类，例如：1234import &#123; gsap &#125; from \"gsap\";import &#123; PixiPlugin &#125; from \"gsap/PixiPlugin.js\";import &#123; MotionPathPlugin &#125; from \"gsap/MotionPathPlugin.js\";gsap.registerPlugin(PixiPlugin, MotionPathPlugin); 如果您使用服务器端渲染，您可能需要在您的配置设置（如 nuxt.config）中将 GSAP 添加到您的 transpile 属性中：1234build: &#123; ... transpile: ['gsap'],&#125;, 具体使用看老虎机插件 初始化基本操作1234567891011121314var tl = new TimelineLite();tl.add( TweenLite.to(element, 1, &#123;left:100&#125;) );//将一个动画添加到时间轴tl.add( TweenLite.to(element, 1, &#123;top:50&#125;) );//将一个动画添加到时间轴末端，即与前一个动画接续tl.add( TweenLite.to(element, 1, &#123;opacity:0&#125;) ); //将一个动画添加到时间轴末端，即与前一个动画接续 //控制时间轴tl.pause();tl.resume();tl.seek(1.5);tl.reverse();// 使用简单的to()方法和链式调用使其更加简洁：var tl = new TimelineLite();tl.to(element, 1, &#123;left:100&#125;).to(element, 1, &#123;top:50&#125;).to(element, 1, &#123;opacity:0&#125;); 文档网址可能会打不开 需要添加.html后缀：https://www.tweenmax.com.cnhttps://greensock.com/docs/v3/GSAP/Tween","categories":[{"name":"tweenmax","slug":"tweenmax","permalink":"https://a-lyc.github.io/categories/tweenmax/"}],"tags":[{"name":"抽奖","slug":"抽奖","permalink":"https://a-lyc.github.io/tags/%E6%8A%BD%E5%A5%96/"},{"name":"tweenmax","slug":"tweenmax","permalink":"https://a-lyc.github.io/tags/tweenmax/"},{"name":"动画","slug":"动画","permalink":"https://a-lyc.github.io/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"老虎机插件文档draw-lottery","slug":"node/老虎机插件文档draw-lottery","date":"2021-09-26T10:32:25.000Z","updated":"2022-03-03T08:33:28.816Z","comments":true,"path":"2021/09/26/node/老虎机插件文档draw-lottery/","link":"","permalink":"https://a-lyc.github.io/2021/09/26/node/%E8%80%81%E8%99%8E%E6%9C%BA%E6%8F%92%E4%BB%B6%E6%96%87%E6%A1%A3draw-lottery/","excerpt":"","text":"draw lottery一个横向竖向滚动抽奖，用到import TweenMax from ‘gsap’，TweenMax的插件let webUrl = 网址：https://www.tweenmax.com.cn 123import VueDrawLottery from 'lottery'Vue.use(VueDrawLottery);&lt;draw-lottery/&gt; props 描述 名称 类型 例子 解释 是否必传 动画时间 animationTime Number:10 10 10秒 no 列表数据 multiDrawData Array {drawData:[{src:’’,name:’’},drawDataSuccess:{}],} 包含全部数据以及中将数据 yes 中奖位置 winPrizeIndex String:-2000 -2000 多少px，总长 yes 中奖前留几个 winIndex Number:0 1 （是第1个） yes 滚动方式 drawXY Boolean:true Y:true X:false Y:true X:false no 模型数据 resData Object resData 定义样式 下方resData yes 动画初始化 TweenMaxInit Object {ease:””} webUrl上方地址 no 开始动画 getStart Function 收不到参数（bug） webUrl上方地址 no 进行中 getUpdate Function 收不到参数（bug） webUrl上方地址 no 已结束 getComplete Function 收不到参数（bug） webUrl上方地址 no Repeat getRepeat Function 收不到参数（bug） webUrl上方地址 no multiDrawData12345678910111213141516171819202122232425262728multiDrawData: [ &#123; // 全部数据 drawData: [ &#123; src: \"https://asset.yskins.com/9frg4EpbifmM1FjkvQtu3hvSMoEF0h9JjjpzfeLv.png\", name: \"1\", &#125;, &#123; src: \"https://asset.yskins.com/Ke4T4zu8wQTmHWdHGFuqwarAzIAe9wPlaMAasu76.png\", name: \"2\", &#125;, &#123; src: \"https://asset.yskins.com/9frg4EpbifmM1FjkvQtu3hvSMoEF0h9JjjpzfeLv.png\", name: \"3\", &#125;, &#123; src: \"https://asset.yskins.com/Ke4T4zu8wQTmHWdHGFuqwarAzIAe9wPlaMAasu76.png\", name: \"4\", &#125;, ], // 中将 drawDataSuccess: &#123; src: \"https://asset.yesskins.com/pvzZR7bOvTkf9jPYlDo1d6rnrA3x7u6RPbCv0Ljm.png\", name: \"中奖1\", &#125;, &#125;, ], resData 定义样式 WH:定义宽高必填，其他样式随便，定义在style内的样式，(必传宽高)，要加入溢出隐藏属性 IdBox：最外层div添加类，可以添加背景， Flex：套在滚动的外框添加类，这个控制横竖想滚动， classBox:每一个滚动的小item添加类， classImg：内部图片添加类， 名称使用div包裹，可使用.XX div{}定义 12345678910&#123; WH:&#123; width:'110', height:\"110\", overflow:\"hidden\", &#125;, IdBox:[''], classBox:['',''], classImg:[''],Flex:['']&#125; 查入图片 老虎机思路自己一开始写的横向或者竖向显示全部的数据，之后给包裹的框一个溢出隐藏再给一个框放置全部数据，之后点击开始的时候放置数据的框向上或者向下移动，奖中奖的奖品放到一个位置，之后使用动画移动到这个位置即可需要整理一下数据","categories":[{"name":"老虎机插件文档","slug":"老虎机插件文档","permalink":"https://a-lyc.github.io/categories/%E8%80%81%E8%99%8E%E6%9C%BA%E6%8F%92%E4%BB%B6%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"老虎机插件","slug":"老虎机插件","permalink":"https://a-lyc.github.io/tags/%E8%80%81%E8%99%8E%E6%9C%BA%E6%8F%92%E4%BB%B6/"},{"name":"抽奖","slug":"抽奖","permalink":"https://a-lyc.github.io/tags/%E6%8A%BD%E5%A5%96/"},{"name":"无限滚动老虎机","slug":"无限滚动老虎机","permalink":"https://a-lyc.github.io/tags/%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E8%80%81%E8%99%8E%E6%9C%BA/"}]},{"title":"npm上传插件","slug":"node/npm上传插件","date":"2021-09-25T13:35:13.000Z","updated":"2022-03-03T08:33:28.812Z","comments":true,"path":"2021/09/25/node/npm上传插件/","link":"","permalink":"https://a-lyc.github.io/2021/09/25/node/npm%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6/","excerpt":"","text":"自己写的多循环老虎机插件 1、npm是什么npm 是Node 的模块管理器，功能极其强大。 它是Node 获得成功的重要原因之一。 正因为有了npm，我们只要一行命令，就能安装别人写好的模块。 2、项目初始化1 首先安装好脚手架vue-cli,打开终端输入命令 1$ npm install --global vue-cli #全局安装 2 这里封装vue的插件用webpack-simple很合适，webpack-simple类似于webpack。接着在终端进入需要创建项目的目录下，输入命令 1$ vue init webpack-simple project-name #project-name为项目名，在这我的项目名为vue-mytoast 如图： 查入图片 3 其中“Pproject name”:项目名称“Project description”: 对项目的描述“Author”: 作者“LIcense”:开源协议“Use sass？”：是否使用sass，这里我们没用到，选择否（No） 4 按照提示输入命令 123$ cd vue-mytoast #进入文件夹$ npm install #按照依赖包$ npm run dev #启动项目 最终的项目结构： 查入图片 我们在 src目录下创建一个lib文件夹，里面存放需要开发的插件文件，如图 查入图片 3、所有环境搭建好后，进入插件开发1 在lib文件夹下创建一个toast.vue文件，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=\"vue-toast-wraper\" v-show=\"isShowToast\"&gt; &#123;&#123;toastMsg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"vueToast\", data() &#123; return &#123; toastMsg: \"登陆成功\", isShowToast:true &#125; &#125;, mounted() &#123; if (this.isShowToast) &#123; setTimeout(() =&gt; &#123; this.isShowToast = false; &#125;,2500); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .vue-toast-wraper&#123; background: rgba(0, 0, 0, 0.6); color: #fff; font-size: 17px; padding: 10px; border-radius:12px; display: -webkit-box; -webkit-box-pack: center; -webkit-box-align: center; position: fixed; top: 50%; left: 50%; z-index: 2000; -webkit-transform: translateY(-50%); transform: translateY(-50%); -webkit-transform: translateX(-50%); transform: translateX(-50%); &#125;&lt;/style&gt; 2 创建一个toast.js文件写install方法，代码如下 123456789101112131415import Toast from './toast.vue'const vueToast = &#123; install(Vue, options) &#123; //Toast.name 组件的name属性,也就是后面使用的组件名字 Vue.component(Toast.name, Toast) // 类似通过 this.$xxx方式调用插件，其实只是挂载到原型上而已 //Vue.prototype.$xxx //最终可以在任何地方通过 this.$XXX调用 &#125;&#125;//global情况下自动安装if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; window.Vue.use(vueToast)&#125;export default vueToast 3 写好后整个项目基本开发完成了，下面先在本项目测试一下3.1 在 main.js 文件中全局引入toast.js 查入图片 3.2 然后在App.vue中使用 查入图片 如果在浏览器出现我们开发的组件，则开发成功！ 4、开发完成后进行文件配置1 修改package.json文件 123456789101112131415161718192021222324252627282930313233343536373839&#123; \"name\": \"vue-mytoast\", \"description\": \"vue弹窗提示插件\", \"version\": \"1.0.0\", \"author\": \"lwz\", \"license\": \"MIT\", //开源协议 \"private\": false, //（改） 因为组件包是公用的，所以private为false \"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\", \"build\": \"cross-env NODE_ENV=production webpack --progress --hide-modules\" &#125;, \"main\": \"dist/toast.js\", //（改） 配置main结点，如果不配置，我们在其他项目中就不用import XX from '包名'来引用了，只能以包名作为起点来指定相对的路径 \"dependencies\": &#123; \"vue\": \"^2.5.11\" &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ], \"keywords\": [ //（改） 指定关键字 \"vue\", \"toast\" ], \"devDependencies\": &#123; \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.2\", \"babel-preset-env\": \"^1.6.0\", \"babel-preset-stage-3\": \"^6.24.1\", \"cross-env\": \"^5.0.5\", \"css-loader\": \"^0.28.7\", \"file-loader\": \"^1.1.4\", \"vue-loader\": \"^13.0.5\", \"vue-template-compiler\": \"^2.4.4\", \"webpack\": \"^3.6.0\", \"webpack-dev-server\": \"^2.9.1\" &#125;&#125; 2 修改webpack.config.js文件2.1 由于不是所有使用组件的人都是通过 npm 安装使用 import 引入组件的，还有很多人是通过 标签的方式直接引入的，所以我们要将 libraryTarget 改为 umd 格式，同时我们要配置文件入口和出口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var path = require('path')var webpack = require('webpack')// 执行环境const NODE_ENV = process.env.NODE_ENVmodule.exports = &#123; // entry: './src/main.js', // 根据不同的执行环境配置不同的入口 entry: NODE_ENV == 'development' ? './src/main.js' : './src/lib/toast.js', output: &#123; //修改打包出口，在最外级目录打包出一个 index.js 文件，我们 import 默认会指向这个文件 path: path.resolve(__dirname, './dist'), publicPath: '/dist/', // filename: 'build.js' filename: \"toast.js\", //指定最终打包成dist文件夹下的文件名 library: \"vueToast\", // 指定的就是你使用require时的模块名 libraryTarget: \"umd\", //libraryTarget会生成不同umd的代码,可以只是commonjs标准的，也可以是指amd标准的，也可以只是通过script标签引入的 umdNamedDefine: true //会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader' ], &#125;, &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125;, extensions: ['*', '.js', '.vue', '.json'] &#125;, devServer: &#123; historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 3 修改.gitignore 文件4 因为要用dist文件夹，所以在.gitignore文件中把dist/去掉。 123456789101112.DS_Storenode_modules/# dist/npm-debug.logyarn-error.log# Editor directories and files.idea*.suo*.ntvs**.njsproj*.sln 5 修改index.js文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;vue-mytoast&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!--&lt;script src=\"/dist/build.js\"&gt;&lt;/script&gt;--&gt; &lt;script src=\"/dist/toast.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5、配置完毕，进入发布阶段在发正式包之前可以在本地先打一个包，然后测试下有没有问题，如果没问题再发布到npm上。1 首先，打包到本地 12$ npm run build $ npm pack 2 npm pack 之后，就会在当前目录下生成 一个tgz 的文件。打开一个新的vue项目，在当前路径下执行(‘路径’ 表示文件所在的位置) 1npm install 路径/组件名称.tgz 3 如图我在project的项目中引入vue-mytoast组件 查入图片 4 然后，在新项目的入口文件（main.js）中引入 12import vueToast from 'toast'Vue.use(vueToast) 5 在组件中使用 123&lt;div&gt; &lt;vue-toast&gt;&lt;/vue-toast&gt;&lt;/div&gt; 6 测试没问题，可以发布啦！ 7 首先在npm官网上注册一个npm账号8 然后在发布项目的根目录下输入命令 1$ npm adduser 9 输入npm账号，输入用户名、密码、邮箱 查入图片 10 在这里特别说明一点，在npm注册的账号一定要把镜像切换到http://registry.npmjs.org/.中来，如果你使用的是淘宝镜像或者别的镜像请切换到此镜像，否则会报错命令： 1$ npm config set registry https://registry.npmjs.org/ 11 登陆成功后进行 npm publish发布 1$ npm publish 12 如果报下面这个错，则在邮箱中核实一下发来的邮件即可13 发布成功后到自己npm上可以看到刚才发的npm包 查入图片 14 发布成功后，当别人想使用你的插件时就可以用 npm install 组件名称 来安装了！ 6、后记折腾了很久，终于把自己的第一个插件的雏形发布出去了，这是一个很简单的插件，以后会继续维护它，添加更多的实用功能。 1 更新npm包： 1234567891011$ npm version &lt;update_type&gt;;$ npm publish使用命令：npm version &lt;update_type&gt;进行修改，update_type 有三个参数，第一个是patch, 第二个是minor,第三个是 major， patch：这个是补丁的意思，补丁最合适； minor：这个是小修小改； major：这个是大改咯； 具体咋用： 比如我想来个1.0.1版本，注意，是最后一位修改了增1，那么命令：npm version patch 回车就可以了； 比如我想来个1.1.0版本，注意，是第二位修改了增1，那么命令： npm version minor 回车就可以了； 比如我想来个2.0.0版本，注意，是第一位修改了增1，那么命令： npm version major 回车就可以了； npm unpublish –force：移除一个发布包（也可以移除指定版本的包）npm logout：登出用户 简书作者：lwz4070原文链接：https://www.jianshu.com/p/b98d09609717来源：简书","categories":[{"name":"npm上传插件","slug":"npm上传插件","permalink":"https://a-lyc.github.io/categories/npm%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"抽奖","slug":"抽奖","permalink":"https://a-lyc.github.io/tags/%E6%8A%BD%E5%A5%96/"},{"name":"npm","slug":"npm","permalink":"https://a-lyc.github.io/tags/npm/"},{"name":"老虎机","slug":"老虎机","permalink":"https://a-lyc.github.io/tags/%E8%80%81%E8%99%8E%E6%9C%BA/"}]},{"title":"定时器的使用轮询","slug":"vue/定时器的使用轮询","date":"2021-09-25T02:53:02.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2021/09/25/vue/定时器的使用轮询/","link":"","permalink":"https://a-lyc.github.io/2021/09/25/vue/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BD%AE%E8%AF%A2/","excerpt":"","text":"定时器根据setInterval轮询持续获取数据实现实时更新，保持数据的持久化，问题出自盲盒对战时，需要对战列表显示对战详情内进行到多少回合了在列表内进行数据轮询 123setInterval(()=&gt;&#123; // 轮询数据 下面的函数&#125;,3000) 解释：因为结束时间和回合数是固定的，只有当前时间是不固定的，所以结束时间 + 回合数总时间 - 当前时间 / 一回合多少秒，之后向上取整或者向下取整得到：4 3 2 1 …然而需要的是1 2 3 4 …之后用回合数 4回合 - 得到的数字 = 0 1 2 3 …之后这个定时器一直走就好，不要停止了就 12345678910111213141516171819// 根据时间判断这个进行到第几回合了 回合数item.box_numfilterLiast.forEach((item,index,) =&gt;&#123; // 结束时间 var time1 = Date.parse(item.updated_at)/1000 // 当前时间 var time2 = Date.parse(new Date())/1000 if(item.status == 2)&#123; // 删除数据 这个位置直记没有走 if(time2 + (item.box_num*10) &gt; time1 )&#123; // 得到回合数 let ceil = Math.ceil((time1 + item.box_num*10 - time2)/10) item.ceil = item.box_num - ceil &#125; if(item.ceil == item.box_num)&#123; data.data.splice(index,1) &#125; &#125; item.status = 1&#125;) vue销毁时在vue中使用setInterval需要把这个给到data中的一个，之后在页面销毁的时候停止定时器，不然的话，这个定时器依旧会继续执行setTimeout这个也是需要页面销毁的时候直接停止定时器 页面数据持久化具体文档没有看1.安装插件：npm install vuex-persistedstate –save 1npm install vuex-persistedstate","categories":[{"name":"定时器,","slug":"定时器","permalink":"https://a-lyc.github.io/categories/%E5%AE%9A%E6%97%B6%E5%99%A8/"}],"tags":[{"name":"定时器","slug":"定时器","permalink":"https://a-lyc.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"页面数据持久化","slug":"页面数据持久化","permalink":"https://a-lyc.github.io/tags/%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"setInterval","slug":"setInterval","permalink":"https://a-lyc.github.io/tags/setInterval/"},{"name":"setTimeout","slug":"setTimeout","permalink":"https://a-lyc.github.io/tags/setTimeout/"},{"name":"vue销毁时","slug":"vue销毁时","permalink":"https://a-lyc.github.io/tags/vue%E9%94%80%E6%AF%81%E6%97%B6/"}]},{"title":"githup上传下载","slug":"githup上传下载","date":"2021-06-30T05:48:15.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2021/06/30/githup上传下载/","link":"","permalink":"https://a-lyc.github.io/2021/06/30/githup%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"上传1 首先在githup上新建一个仓库一定是英文常见，Description (optional)自述信息要写和项目相关的，要不然找不到了点击创建即可 2：git init 初始化 git会在文件内有一个.git文件夹 3：git add .提交文件 .代表这个文件夹内的全部提交上去 4：git commit -m “提交备注”翻译是首先提交，提交之后 没理解啥意思 5：git branch -M main获取git分支 - 执行过一次之后就不需要了， 6：git remote add origin https://github.com/A-lyc/XXXXXX.git获取谁的分支 - 执行过之后，远程仓库已经存在了 6-1：git config –global http.sslVerify “false”报错，OpenSSL SSL_read: Connection 被重置 7：git push -u origin main提交 本地新建文件夹，之后执行git init ，之后把项目拖入文件夹内，执行git add . 之后 git commit -m “提交备注”之后git branch -M main之后git remote add origin https://github.com/A-lyc/XXXXXX.git之后git config –global http.sslVerify “false”之后git push -u origin main 下载压缩包下载下载1：git clone https://github.com/A-lyc/XXXXXX.git","categories":[{"name":"githup","slug":"githup","permalink":"https://a-lyc.github.io/categories/githup/"}],"tags":[{"name":"githup","slug":"githup","permalink":"https://a-lyc.github.io/tags/githup/"}]},{"title":"web上的svga使用","slug":"资源/web上的svga使用","date":"2021-06-30T01:02:01.000Z","updated":"2022-03-03T08:33:28.876Z","comments":true,"path":"2021/06/30/资源/web上的svga使用/","link":"","permalink":"https://a-lyc.github.io/2021/06/30/%E8%B5%84%E6%BA%90/web%E4%B8%8A%E7%9A%84svga%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SVGAPlayer-Web安装预编译 JS 添加 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/svgaplayerweb@2.3.1/build/svga.min.js&quot;&gt;&lt;/script&gt; 到 index.html 页面 NPM npm install svgaplayerweb --save 添加 const SVGA = require(&#39;svgaplayerweb&#39;); 或 import SVGA from &#39;svgaplayerweb&#39;; 至 xxx.js IE6 ~ IE9 IE6+ 只支持 2.x 格式文件. 你不能使用 NPM 方式安装 SVGAPlayer. 添加 SVGAPlayerWeb.swf 到 index.html 同级目录 添加以下代码至 index.html 123456&lt;!--[if lt IE 10]&gt; &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;svga.ie.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;![endif]--&gt;&lt;!--[if gte IE 10]&gt;&lt;!--&gt; &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;svga.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!--&lt;![endif]--&gt; 支持音频播放如果你需要播放 svga 文件内的音频，请将 howler.min.js 添加到 HTML 页面中。 1&lt;script src=\"https://cdn.jsdelivr.net/npm/howler@2.0.15/dist/howler.core.min.js\"&gt;&lt;/script&gt; 注意：部分浏览器要求在触摸事件发生后才能播放音频。 支持 SVGA-Format 1.x 格式无论是使用预编译 JS 或是 NPM， 如果你需要播放 1.x 格式的 SVGA 文件，需要添加 JSZip 到你的 HTML 页面中。 1&lt;script src=\"//s1.yy.com/ued_web_static/lib/jszip/3.1.4/??jszip.min.js,jszip-utils.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 使用指南手动加载你可以自行创建 Player 和 Parser 并加载动画 添加 Div 容器 1&lt;div id=\"demoCanvas\" style=\"styles...\"&gt;&lt;/div&gt; 加载动画 123456var player = new SVGA.Player('#demoCanvas');var parser = new SVGA.Parser('#demoCanvas'); // 如果你需要支持 IE6+，那么必须把同样的选择器传给 Parser。parser.load('rose_2.0.0.svga', function(videoItem) &#123; player.setVideoItem(videoItem); player.startAnimation();&#125;) 自动加载为 canvas 元素添加src属性 1&lt;div src=\"rose_2.0.0.svga\" id=\"demoCanvas\" style=\"styles...\"&gt;&lt;/div&gt; 1new SVGA.autoload(document.querySelector('#demoCanvas')) 动画会在页面加载完成后播放 动态图像你可以动态替换动画中的指定元素，询问你的动画设计师以获取 ImageKey。获取key地址：http://svga.8zuu.com/preview/index.html?bd_vid=7901902804732066088 用于替换的图片，宽、高必须与原图一致。 可以是本地图片 setImage 操作必须在 startAnimation 之前执行。 1player.setImage(&#39;http:&#x2F;&#x2F;yourserver.com&#x2F;xxx.png&#39;, &#39;ImageKey&#39;); 动态文本你可以在指定元素上添加文本，询问你的动画设计师以获取 ImageKey。 setText 操作必须在 startAnimation 之前执行。 1player.setText(&#39;Hello, World!&#39;, &#39;ImageKey&#39;); 1234567player.setText(&#123; text: &#39;Hello, World!, family: &#39;Arial&#39;, size: &quot;24px&quot;, color: &quot;#ffe0a4&quot;, offset: &#123;x: 0.0, y: 0.0&#125;&#125;, &#39;ImageKey&#39;); &#x2F;&#x2F; 可自定义文本样式 ClassesSVGA.PlayerSVGA.Player 用于控制动画的播放和停止 Properties int loops; - 动画循环次数，默认值为 0，表示无限循环。 BOOL clearsAfterStop; - 默认值为 true，表示当动画结束时，清空画布。 string fillMode; - 默认值为 Forward，可选值 Forward / Backward，当 clearsAfterStop 为 false 时，Forward 表示动画会在结束后停留在最后一帧，Backward 则会在动画结束后停留在第一帧。 Methods constructor (canvas); - 传入 #id 或者 CanvasHTMLElement 至第一个参数 startAnimation(reverse: boolean = false); - 从第 0 帧开始播放动画 startAnimationWithRange(range: {location: number, length: number}, reverse: boolean = false); - 播放 [location, location+length] 指定区间帧动画 pauseAnimation(); - 暂停在当前帧 stopAnimation(); - 停止播放动画，如果 clearsAfterStop === true，将会清空画布 setContentMode(mode: “Fill” | “AspectFill” | “AspectFit”); - 设置动画的拉伸模式 setClipsToBounds(clipsToBounds: boolean); - 如果超出盒子边界，将会进行裁剪 clear(); - 强制清空画布 stepToFrame(frame: int, andPlay: Boolean); - 跳到指定帧，如果 andPlay === true，则在指定帧开始播放动画 stepToPercentage(percentage: float, andPlay: Boolean); - 跳到指定百分比，如果 andPlay === true，则在指定百分比开始播放动画 setImage(image: string, forKey: string, transform: [a, b, c, d, tx, ty]); - 设定动态图像, transform 是可选的, transform 用于变换替换图片 setText(text: string | {text: string, family: string, size: string, color: string, offset: {x: float, y: float}}, forKey: string); - 设定动态文本 clearDynamicObjects(); - 清空所有动态图像和文本 Callback Method onFinished(callback: () =&gt; void): void; - 动画停止播放时回调 onFrame(callback: (frame: number): void): void; - 动画播放至某帧后回调 onPercentage(callback: (percentage: number): void): void; - 动画播放至某进度后回调 SVGA.ParserSVGA.Parser 用于加载远端或 Base64 动画，并转换成 VideoItem。 跨域的 SVGA 资源需要使用 CORS 协议才能加载成功。 如果你需要加载 Base64 资源，或者 File 资源，这样传递就可以了 load(File) 或 load(&#39;data:svga/2.0;base64,xxxxxx&#39;)。 Methods constructor(); load(url: string, success: (videoItem: VideoEntity) =&gt; void, failure: (error: Error) =&gt; void): void; IssuesAndroid 4.x 加载失败某些 Android 4.x OS 上缺少 Blob 支持，请自行添加 Polyfill。 1&lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;blob-polyfill&#x2F;1.0.20150320&#x2F;Blob.min.js&quot;&gt;&lt;&#x2F;script&gt; 使用例子1&lt;div id&#x3D;&quot;demoCanvas&quot; style&#x3D;&quot;width: 200px;height: 500px&quot;&gt;&lt;&#x2F;div&gt; 12345678910111213141516171819var player = new this.$SVGA.Player('#demoCanvas');var parser = new this.$SVGA.Parser('#demoCanvas');parser.load('/svga/ceshi/jingluo.svga' , function(videoItem) &#123; player.setVideoItem(videoItem); player.setImage('/svga/ceshi/200X200.png', 'psd_221') // 替换图片 player.setText(&#123; text: 'Hello, World!', family: 'Arial', size: \"24px\", color: \"#ffe0a4\", offset: &#123;x: 0.0, y: 0.0&#125; &#125;, 'ImageKey'); // 可自定义文本样式 player.loops = 2;// 动画循环次数，默认值为 0，表示无限循环 player.clearsAfterStop = false; // 默认值为 true 表示当动画结束时，清空画布 player.startAnimation(); // 从第 0 帧开始播放动画 player.onFrame(function (i) &#123; console.log(i) // 动画播放至某帧后回调 动画帧 &#125;);&#125;) 遇到问题incorrect header check解决办法 去服务器，找到iis 添加下载的那个.svgaapplication/octet-stream 查入图片 可点击放大","categories":[{"name":"svga 动画 AE","slug":"svga-动画-AE","permalink":"https://a-lyc.github.io/categories/svga-%E5%8A%A8%E7%94%BB-AE/"}],"tags":[{"name":"svga 动画 AE","slug":"svga-动画-AE","permalink":"https://a-lyc.github.io/tags/svga-%E5%8A%A8%E7%94%BB-AE/"}]},{"title":"自定义域名指向本地服务器","slug":"资源/自定义域名指向本地服务器","date":"2021-06-30T01:02:01.000Z","updated":"2022-03-03T08:33:28.876Z","comments":true,"path":"2021/06/30/资源/自定义域名指向本地服务器/","link":"","permalink":"https://a-lyc.github.io/2021/06/30/%E8%B5%84%E6%BA%90/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"步骤： 1、win10 x64系统，hosts文件位置： C:\\Windows\\System32\\drivers\\etc 修改hosts这个文件 ，使用管理员打开， 最后一行添加 127.0.0.1 csgo.skins.com意思就是127.0.0.1 这个指向csgo.skins.com这个本地域名，打开的时候需要端口号 node修改vue.config.js1234567devServer: &#123; host: \"csgo.skins.com\",// 自定义域名 port: \"80\",// 端口号 disableHostCheck: true,// 必须添加，要不然报错，无效的头部好像是 proxy: &#123; &#125; &#125; 想不带端口号 默认80端口 netstat -ano查看端口号 netstat -aon|findstr “80”查看80端口是谁在使用最后面的数子就是这个使用者PID 打开任务管理器找到详情信息 和PID对应的直接结束掉 问题找到之后结束不了的话，直接搜索-服务-关闭nginx，如果安装了宝塔和nginx，需要停止运行这个","categories":[{"name":"资源 本地域名","slug":"资源-本地域名","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90-%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D/"}],"tags":[{"name":"资源 本地域名","slug":"资源-本地域名","permalink":"https://a-lyc.github.io/tags/%E8%B5%84%E6%BA%90-%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D/"}]},{"title":"前端布局神器display:flex","slug":"css/前端布局神器display-flex","date":"2021-06-26T12:13:53.000Z","updated":"2022-03-03T08:33:28.768Z","comments":true,"path":"2021/06/26/css/前端布局神器display-flex/","link":"","permalink":"https://a-lyc.github.io/2021/06/26/css/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E7%A5%9E%E5%99%A8display-flex/","excerpt":"一、Flex不仅可以水平方向布局也可以垂直方向布局 Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。","text":"一、Flex不仅可以水平方向布局也可以垂直方向布局 Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 .box{ display: -webkit-flex; /在webkit内核的浏览器上使用要加前缀/ display: flex; //将对象作为弹性伸缩盒显示 } 当然，行内元素也可以使用Flex布局。.box { display: inline-flex; //将对象作为内联块级弹性伸缩盒显示 } 兼容性写法.box { display: flex || inline-flex;} 二、基本概念 采用Flex布局的元素，被称为Flex容器(flex container)，简称“容器”。其所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。 {% image ./前端布局神器display-flex/image.png '查入图片' '' %} 结构示意图容器默认存在两根主轴：水平方向主轴(main axis)和垂直方向交叉轴(cross axis)，默认项目按主轴排列。• main start/main end：主轴开始位置/结束位置；• cross start/cross end：交叉轴开始位置/结束位置；• main size/cross size：单个项目占据主轴/交叉轴的空间； 三、容器属性 设置在容器上的属性有6种。 flex-directionflex-wrapflex-flowjustify-contentalign-itemalign-content flex-direction属性：决定主轴的方向（即项目的排列方向） .box {flex-direction: row | row-reverse | column | column-reverse;} row（默认）：主轴水平方向，起点在左端；row-reverse：主轴水平方向，起点在右端；column：主轴垂直方向，起点在上边沿；column-reserve：主轴垂直方向，起点在下边沿。 {% image /前端布局神器display-flex/02.png '查入图片' '' %} flex-wrap属性：定义换行情况 默认情况下，项目都排列在一条轴线上，但有可能一条轴线排不下。 .box{flex-wrap: nowrap | wrap | wrap-reverse;}nowrap（默认）：不换行；wrap：换行，第一行在上方；wrap-reverse：换行，第一行在下方。 flex-flow属性：flex-direction和flex-wrap的简写，默认row nowrap .box{ flex-flow: || ;} justify-content属性：定义项目在主轴上的对齐方式。对齐方式与轴的方向有关，本文中假设主轴从左到右。 .box {justify-content: start | end | flex-start | flex-end | center | left | right | space-between | space-around | space-evenly | stretch | safe | unsafe | baseline | first baseline | last baseline;} flex-start（默认值）：左对齐； {% image /前端布局神器display-flex/03.png '查入图片' '' %} flex-end：右对齐； {% image /前端布局神器display-flex/04.png '查入图片' '' %} center：居中； {% image /前端布局神器display-flex/05.png '查入图片' '' %} space-between：两端对齐，项目之间间隔相等； {% image /前端布局神器display-flex/06.png '查入图片' '' %} space-around：每个项目两侧的间隔相等，即项目之间的间隔比项目与边框的间隔大一倍。 {% image /前端布局神器display-flex/07.png '查入图片' '' %} align-items属性：定义在交叉轴上的对齐方式 对齐方式与交叉轴的方向有关，假设交叉轴从下到上。 .box{ align-items: flex-start | flex-end | center | baseline | stretch;} flex-start：起点对齐； {% image /前端布局神器display-flex/08.png '查入图片' '' %} flex-end：终点对齐； {% image /前端布局神器display-flex/09.png '查入图片' '' %} center：中点对齐； {% image /前端布局神器display-flex/10.png '查入图片' '' %} baseline：项目的第一行文字的基线对齐； {% image /前端布局神器display-flex/11.png '查入图片' '' %} stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 {% image /前端布局神器display-flex/12.png '查入图片' '' %} align-content属性：定义多根轴线的对齐方式 如果项目只有一根轴线，该属性不起作用。所以，容器必须设置flex-wrap：···； .box{ align-content: flex-start | flex-end | center | space-between | space-around | stretch;} flex-start：与交叉轴的起点对齐； {% image /前端布局神器display-flex/13.png '查入图片' '' %} flex-end：与交叉轴的终点对齐； {% image /前端布局神器display-flex/14.png '查入图片' '' %} center：与交叉轴的中点对齐； {% image /前端布局神器display-flex/15.png '查入图片' '' %} space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布； {% image /前端布局神器display-flex/16.png '查入图片' '' %} space-around：每根轴线两侧的间隔相等，即轴线之间的间隔比轴线与边框的间隔大一倍； {% image /前端布局神器display-flex/17.png '查入图片' '' %} stretch（默认值）：轴线占满整个交叉轴。 {% image /前端布局神器display-flex/18.png '查入图片' '' %} 有意思的是，当你不给项目设置高度但是给容器设置align-content不为stretch时，同一轴线上的项目的高度将等于项目中高度最高的项目。 {% image /前端布局神器display-flex/19.png '查入图片' '' %} 四、项目的属性 设置在项目上的属性也有6个。 orderflex-growflex-shrinkflex-basisflexalign-selforder属性：定义项目的排列顺序。 数值越小，排列越靠前，默认为0，可以是负值。 .item { order: &lt;整数&gt;;} 查入图片 展示效果不明显，直接盗图 flex-grow属性：定义项目的放大比例 默认值为0，即如果空间有剩余，也不放大。可以是小数，按比例占据剩余空间。 查入图片 .item{ flex-grow: &lt;数字&gt;;}若所有项目的flex-grow的数值都相同，则等分剩余空间等分剩余空间 若果有一个项目flex-grow为2，其余都为1，则该项目占据剩余空间是其余的2倍 查入图片 flex-shrink属性：定义项目的缩小比例 默认值都为1，即如果空间不足将等比例缩小。如果有一个项目的值为0，其他项目为1，当空间不足时，该项目不缩小。负值对该属性无效，容器不应该设置flex-wrap。 .item{ flex-shrink: &lt;非负整数&gt;;}如果一个项目设置flex-shrink为0；而其他项目都为1，则空间不足时，该项目不缩小。 {% image /前端布局神器display-flex/23.png '查入图片' '' %} 如果所有项目都为0，则当空间不足时，项目撑破容器而溢出。 {% image /前端布局神器display-flex/24.png '查入图片' '' %} 如果设置项目的flex-shrink不为0的非负数效果同设置为1。 {% image /前端布局神器display-flex/25.png '查入图片' '' %} flex-basis属性：定义在分配多余空间之前，项目占据的主轴空间。 {% image /前端布局神器display-flex/26.png '查入图片' '' %} 默认值为auto，浏览器根据此属性检查主轴是否有多余空间。 .item{ flex-basis: &lt;auto或者px&gt;;} 注意设置的flex-basis是分配多余空间之前项目占据的主轴空间，如果空间不足则默认情况下该项目也会缩小。 {% image /前端布局神器display-flex/27.png '查入图片' '' %} 设置flex-basis为350px，但空间充足 {% image /前端布局神器display-flex/28.png '查入图片' '' %} 空间不足，项目缩小，小于设定值flex属性是flex-grow，flex-shrink和flex-basis的简写默认值为0 1 auto，第一个属性必须，后两个属性可选。 .item{ flex: none | [&lt;flex-grow&gt;&lt;flex-shrink&gt;&lt;flex-basis&gt;];} 可以用 flex:auto; 代替 flex: 1 1 auto;；可以用 flex: none;代替 flex: 0 0 auto； align-self属性：允许单个项目与其他项目有不一样的对齐方式 默认值为auto，表示继承父元素的align-items属性，并可以覆盖align-items属性。.item{align-self: auto | flex-start | flex-end | center | baseline | stretch;} 内容以共享、参考、研究为目的,不存在任何商业目的。其版权属原作者所有,如有侵权,请与小编联系!情况属实本人将予以删除!","categories":[{"name":"css","slug":"css","permalink":"https://a-lyc.github.io/categories/css/"}],"tags":[{"name":"Flex布局","slug":"Flex布局","permalink":"https://a-lyc.github.io/tags/Flex%E5%B8%83%E5%B1%80/"}]},{"title":"详解-AE-如何将-png-序列帧导出为-SVGA-动画文件","slug":"资源/AE","date":"2021-06-08T01:02:01.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2021/06/08/资源/AE/","link":"","permalink":"https://a-lyc.github.io/2021/06/08/%E8%B5%84%E6%BA%90/AE/","excerpt":"","text":"奖png序列帧导入AE 1：从菜单栏“导入”-》“文件”，选择存放序列帧的文件夹 2：导入之后右键序列帧中的一个图，有基于所选项新建合成，直接确定 查入图片 查入图片 3：这个时候序列帧是全部占据了时间线 4：我们使用快捷键alt+[ 和 alt + ]然后裁切。最好保留一帧 5：之后我们回到菜单栏 -》 动画 -》 关键帧辅助 -》 序列图层 6：这里直接默认，并适当调整工作区时间即可，结果如下所示。 7：菜单栏中 “窗口”-&gt; “扩展” -&gt; SVGAConverter_AE （ 详见&nbsp;下载安装教程&nbsp;）打开该插件 查入图片 查入图片 8：也可以直接拖动到这个网站进行预览 ——&nbsp;http://svga.io/svga-preview.html&nbsp; 9：链接：https://www.bilibili.com/video/BV1Ut411r7Gj?p=3 10：链接：http://svga.io/designer.html 11：压缩包：SVGAConverter_AE 12：gif转svga 导出png序列之后使用AE，之后导出即可","categories":[{"name":"AE","slug":"AE","permalink":"https://a-lyc.github.io/categories/AE/"}],"tags":[{"name":"AE","slug":"AE","permalink":"https://a-lyc.github.io/tags/AE/"}]},{"title":"如何使用实时通讯","slug":"vue/如何使用实时通讯","date":"2021-02-07T13:49:37.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2021/02/07/vue/如何使用实时通讯/","link":"","permalink":"https://a-lyc.github.io/2021/02/07/vue/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF/","excerpt":"","text":"如何在uniapp中使用实时通讯uni.connectSocket地址：https://uniapp.dcloud.io/api/request/websocket?id=connectsocket首先知道只要打开页面就需要开始实时通讯，所以要在vue的页面加载的时候可在app.vue中直接声明使用uni.connectSocket方法： 必穿参数：url:ws:/wss 返回参数：complete: () =&gt; {} 1234567891011121314151617methods: &#123; /** * 在 App.vue 初始化 ws 对象 * 这里仅仅初始化，不做任何操作 * 将 ws 挂到 Vue 原型链上 * 方便子组件中使用 **/ init() &#123; // 全局暴漏$ws Vue.prototype.$ws = uni.connectSocket(&#123; url: 'ws:', //链接成功 complete: () =&gt; &#123;&#125; // 需要一个成功失败或者都执行的参数 &#125;); // 初始化之后进行 验证链接 socket() &#125; &#125;, 新建一个函数socket：对应socket() 123456789101112131415161718192021222324let getSocket = function ()&#123; // 链接成功 一开始第一次握手 uni.onSocketOpen(function (res) &#123; console.log('WebSocket连接已打开！'); &#125;); // WebSocket连接打开失败，请检查！ uni.onSocketError(function (res) &#123; console.log('WebSocket连接打开失败，请检查！'); &#125;); uni.onSocketMessage(function (res) &#123; // 传来的数据进行结构 let &#123;Data, MsgType&#125; = JSON.parse(res.data) // 链接验证使用 每个一段时间发送一个p uni.sendSocketMessage的方法 为字符串 setInterval(() =&gt; &#123; uni.sendSocketMessage(&#123; data: 'p' &#125;) &#125;, 20000) // 直接跳出 uni.closeSocket(&#123;code: 1000&#125;) &#125;);&#125;// 导出去export default getSocket 页面中使用 12// 使用方式 可见官网onMessage 接收数据给服务器 this.$ws.onMessage(async res =&gt;&#123;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 实时通讯","slug":"vue-实时通讯","permalink":"https://a-lyc.github.io/tags/vue-%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF/"}]},{"title":"鲁班h5","slug":"鲁班h5","date":"2020-12-01T05:48:15.000Z","updated":"2022-03-03T08:33:28.876Z","comments":true,"path":"2020/12/01/鲁班h5/","link":"","permalink":"https://a-lyc.github.io/2020/12/01/%E9%B2%81%E7%8F%ADh5/","excerpt":"","text":"是一个制作易企秀，的开放源码，鲁班h5网址：https://h5.luban-h5.com/#/work-manager/list文档可查询，前端：vue，后端：Strapi，储存：Sqlite/Mysql 创建一个项目 本地安装了 Node、Yarn 适合 熟悉前端开发的同学、使用 Windows 的同学，需要安装yarn和npm 使用npm 安装yarn - npm install -g yarn123456789git clone https://github.com/ly525/luban-h5cd luban-h5 # 项目根目录# 后端cd back-end/h5-api &amp;&amp; yarn install &amp;&amp; yarn dev# 前端# 新开一个终端，在项目根目录执行如下命令cd front-end/h5 &amp;&amp; yarn &amp;&amp; yarn build:engine &amp;&amp; yarn dev 管理后台 本地访问地址为：http://localhost:1337/admin 常见问题 接口 403 Forbidden访问：http://localhost:1337/admin (鲁班的管理后台，在这里管理数据、接口相关权限)请按照下图的操作，打开接口访问权限：Roles And Permission -&gt; Public -&gt; Permissions -&gt;Work的权限全部放开 图片上传不上去Roles And Permission -&gt; Public -&gt; Permissions -&gt; upload 权限打开 视频教程哔哩哔哩：https://www.bilibili.com/video/av76827615?zw 报splite3错误 报错：error The client sqlite3 is not installed. 因为sqlite3框架没有安装，需要镜像或者翻墙去安装，在deploy中打开mirror.sh中找到对应的镜像源需要安装一下即可","categories":[{"name":"lubanH5","slug":"lubanH5","permalink":"https://a-lyc.github.io/categories/lubanH5/"}],"tags":[{"name":"lubanH5","slug":"lubanH5","permalink":"https://a-lyc.github.io/tags/lubanH5/"}]},{"title":"微信云支付","slug":"微信/微信支付","date":"2020-11-14T00:30:12.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/11/14/微信/微信支付/","link":"","permalink":"https://a-lyc.github.io/2020/11/14/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/","excerpt":"","text":"serverLess实现微信原生支付准备 拥有营业执照 注册公众号，微信支付商户号 开发微信小程序上线成功，并开通微信支付 获取信息 小程序 微信公众号appID（小程序ID）：登录小程序 - 开发 - 开发设置appServer（小程序密钥）：登录小程序 - 开发 - 开发设置已关支付联商户号：登录小程序 - 开发 - 开发设置 登录微信商户平台账户中心 - 登录账号账户中心 - api安全 - 设置api密钥微信开发工具开发打开微信小程序 新建项目 - 填写基本信息 初始化云开发 点击云开发 - 创建云开发 记住环境ID， 设计默认请求的云环境在app.js - 开始创建的时候有，需要打开env进行关联即可，值为环境ID1234wx.cloud.init(&#123;env:'云开发环境ID',traceUser:true&#125;) 页面绘制在pages/index/index.wxml中123&lt;view bindtap='doPay'&gt; 下单&lt;/view&gt; 在pages/index/index.js中12345678const app = getApp()Page(&#123;data:&#123;&#125;,onLoad:function()&#123;&#125;,doPay:function() &#123; console.log('点击了下单')&#125;&#125;) 调用云函数创建云函数 在云函数文件夹右键新建node云函数 创建结果回调云函数payCallack· 注意为推送支付结果做准备在cloudfunction/payCallack/index.js中在cloudfunction/unifiedOrder/index.js中全部初始化一下右键上传并部署123456789101112const cloud = require('wx-server-sdk')cloud.init()exports.main = async (event,context) =&gt; &#123;const wxContext = cloud.getwxContext();console.log(event)return &#123;event,openid:wxContext.OPENID,appid:wxContext.APPID,unionid:wxContextUNIONID&#125;&#125; 调用云函数在pages/index/index.js中1234567891011121314151617Page(&#123;data:&#123;&#125;,onLoad:function()&#123;&#125;,doPay:function() &#123; // 调用云函数的方法 wx.cloud.callFunction(&#123; name:'unifiedorder', data:&#123;&#125;, success:res =&gt;&#123; console.log('成功',res) &#125;, fail:err =&gt; &#123; console.log('失败') &#125;&#125;)&#125;&#125;) 支付对象下单方法&amp;返回支付参数在cloudfunction/unifiedOrder/index.js中1234567891011121314151617181920212223242526const cloud = require('wx-server-sdk')cloud.init(&#123; env:cloud.DYNAMIC_CURRENT_ENV&#125;)// 随机字符串function randomStr(length) &#123; const chars = 'ABDEFGHIJKLMNOPQSTUVWXYZacdefghijklmnopqistuvwxyz0123456789' let noceStr = '' let maxPos = chars.length while (length--) noceStr += chars[Math.random()*maxPos | 0] return noceStr&#125;// 云函数入口函数exports.main = async (event, context) =&gt; &#123;// cloud.cloudPay.unifiedOrder 统一下单接口const res = await cloud.cloudPay.unifiedOrder(&#123; body:'商品描述', outTradeNo:randomStr(28),// 订单号，不能重复 spbillCreateIp:'终端IP', subMchId:'商户号', totalFee : 1, // 总价 envId: \"test-f0b102\",// 结果通知回调云函数环境 functionName: \"pay_cb\"// 结果通知回调云函数名&#125;)return res&#125; 调起支付在pages/index/index.js中1234567891011121314151617181920wx.cloud.callFunction(&#123; name: 'unifiedOrder',// 函数名 data: &#123; // ... &#125;, success: res =&gt; &#123; const payment = res.result.payment // 微信小程序提供的方法 - 弹出扫码 wx.requestPayment(&#123; ...payment, success (res) &#123; console.log('pay success', res) &#125;, fail (res) &#123; console.error('pay fail', err) &#125; &#125;) &#125;, fail: console.error,&#125;) 扫码-支付-成功展示结果","categories":[{"name":"微信云支付","slug":"微信云支付","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1%E4%BA%91%E6%94%AF%E4%BB%98/"}],"tags":[{"name":"微信云支付","slug":"微信云支付","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E4%BA%91%E6%94%AF%E4%BB%98/"}]},{"title":"uniapp云开发","slug":"uniapp/uniapp云开发","date":"2020-11-13T03:51:04.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/11/13/uniapp/uniapp云开发/","link":"","permalink":"https://a-lyc.github.io/2020/11/13/uniapp/uniapp%E4%BA%91%E5%BC%80%E5%8F%91/","excerpt":"","text":"使用HBuilder X，新建一个项目，可选择云开发基础模板，或者默认模板，新建之后会在根目录有个文件夹为：cloudfunctions，此文件夹为操作数据库文件夹看，（下图） 新建项目 右键新建云函数，之后本地运行看是否可以读出数据，之后上传并运行，即可使用（）举例右键创建云函数为：test 1234567'use strict';const db = uniCloud.database()exports.main = async (event, context) =&gt; &#123; const collection = db.collection('test') const res = await collection.add(event) return &#123;res,name:1&#125;&#125;; 在https://unicloud.dcloud.net.cn/home上面创建服务空间 - 数据库 - 云数据库 - 添加数据库表，之后调用： 12345uniCloud.callFunction(&#123; name:'test' &#125;).then(res =&gt; &#123; console.log(res) &#125;) cli项目中使用uniCloud 如果要在cli项目中使用uniCloud，可以参考以下步骤 将cli项目导入HBuilderX 在项目根目录（src同级）创建cloudfunctions-aliyun或者cloudfunctions-tcb目录 打开src/manifest.json，在基础配置–&gt;uni-app应用标示处点击重新获取 在步骤2创建的目录右键关联服务空间 运行与发行云函数只能使用HBuilderX的菜单，不可使用package.json内的命令 如果HBuilderX菜单运行不能满足需求可以考虑自行初始化服务空间服务空间初始化 获取集合引用123const db = uniCloud.database();// 获取 `user` 集合的引用const collection = db.collection('user'); 集合 Collection 的方法通过 db.collection(name).add() 可以获取指定集合的引用，在集合上可以进行以下操作 类型 接口 说明 写 add 新增记录（触发请求） 计数 count 获取符合条件的记录条数 读 get 获取集合中的记录，如果有使用 where 语句定义查询条件，则会返回匹配结果集 (触发请求) 引用 doc 获取对该集合中指定 id 的记录的引用 查询条件 where 通过指定条件筛选出匹配的记录，可搭配查询指令（eq, gt, in, ...）使用 skip 跳过指定数量的文档，常用于分页，传入 offset。clientDB组件有封装好的更易用的分页，另见 orderBy 排序方式 limit 返回的结果集(文档数量)的限制，有默认值和上限值 field 指定需要返回的字段 where 类似于微信小程序 查询及更新指令用于在 where 中指定字段需满足的条件，指令可通过 db.command 对象取得。 collection对象的方法可以增和查数据，删和改不能直接操作，需要collection对象通过doc或get得到指定的记录后再调用remove或update方法进行删改。 ## 记录 Record / Document 通过 db.collection(collectionName).doc(docId) 可以获取指定集合上指定 id 的记录的引用，在记录上可以进行以下操作 接口 说明 写 set 覆写记录 update 局部更新记录(触发请求) remove 删除记录(触发请求) 读 get 获取记录(触发请求) 查询筛选指令 Query Command以下指令挂载在 db.command 下 类型 接口 说明 比较运算 eq 字段等于 == neq 字段不等于 != gt 字段大于 &gt; gte 字段大于等于 &gt;= lt 字段小于 &lt; lte 字段小于等于 &lt;= in 字段值在数组里 nin 字段值不在数组里 逻辑运算 and 表示需同时满足指定的所有条件 or 表示需同时满足指定条件中的至少一个 字段更新指令 Update Command以下指令挂载在 db.command 下 类型 接口 说明 字段 set 设置字段值 remove 删除字段 inc 加一个数值，原子自增 mul 乘一个数值，原子自乘 push 数组类型字段追加尾元素，支持数组 pop 数组类型字段删除尾元素，支持数组 shift 数组类型字段删除头元素，支持数组 unshift 数组类型字段追加头元素，支持数组 时间 Date1234567//服务端当前时间 new db.serverDate() //服务端当前时间加1S new db.serverDate(&#123; offset: 1000 &#125;) 如果需要对日期进行比较操作，可以使用聚合操作符将日期进行转化，比如以下示例查询所有time字段在2020-02-02以后的记录 新增文档 collection.add(data) 参数 类型 必填 说明 data object | array 是 {_id: '10001', 'name': 'Ben'} _id 非必填 单条插入时 参数 类型 说明 id String 插入记录的id 批量插入时 参数 类型 说明 inserted Number 插入成功条数 ids Array 批量插入所有记录的id 123456789101112// 单条插入数据let res = await collection.add(&#123; name: 'Ben'&#125;)// 批量插入数据let res = await collection.add([&#123; name: 'Alex'&#125;,&#123; name: 'Ben'&#125;,&#123; name: 'John'&#125;]) 云服务商为阿里云时，若集合不存在，调用add方法会自动创建集合方法2： collection.doc().set(data)也可通过 set 方法新增一个文档，需先取得文档引用再调用 set 方法。 如果文档不存在，set 方法会创建一个新文档。参数说明 参数 类型 必填 说明 data object 是 更新字段的Object，{'name': 'Ben'} _id 非必填 响应参数 参数 类型 说明 updated Number 更新成功条数，数据更新前后没变化时也会返回1 upsertedId String 创建的文档id 查询文档支持 where()、limit()、skip()、orderBy()、get()、field()、count() 等操作。只有当调用get()时才会真正发送查询请求。注：默认取前100条数据，最大取前100条数据。 添加查询条件collection.where()设置过滤条件，where 可接收对象作为参数，表示筛选出拥有和传入对象相同的 key-value 的文档。比如筛选出所有类型为计算机的、内存为 8g 的商品： 12345678const dbCmd = db.commandlet res = await db.collection('goods').where(&#123; category: 'computer', type: &#123; memory: 8, // memory: dbCmd.gt(8), // 表示大于 8 &#125;&#125;).get() 获取查询数量collection.count()阿里云不同 123456let res = await db.collection('goods').where(&#123; category: 'computer', type: &#123; memory: 8, &#125;&#125;).count() 设置记录数量collection.limit() 参数 类型 必填 说明 value Number 是 返回的数据条数 1let res = await collection.limit(1).get() // 只返回第一条记录 设置起始位置collection.skip(value) 参数 类型 必填 说明 value Number 是 跳过指定的位置，从位置之后返回数据 1let res = await collection.skip(4).get() 对结果排序collection.orderBy(field, orderType) 参数 类型 必填 说明 field string 是 排序的字段 orderType string 是 排序的顺序，升序(asc) 或 降序(desc) 如果需要对嵌套字段排序，需要用 “点表示法” 连接嵌套字段，比如 style.color 表示字段 style 里的嵌套字段 color。同时也支持按多个字段排序，多次调用 orderBy 即可，多字段排序时的顺序会按照 orderBy 调用顺序先后对多个字段排序使用示例 1let res = await collection.orderBy(\"name\", \"asc\").get() 指定返回字段collection.field()从查询结果中，过滤掉不需要的字段，或者指定要返回的字段。 参数 类型 必填 说明 - object 是 过滤字段对象，包含字段名和策略，不返回传false，返回传true 1collection.field(&#123; 'age': true &#125;) //只返回age字段，其他字段不返回 备注：只能指定要返回的字段或者不要返回的字段。即{‘a’: true, ‘b’: false}是一种错误的参数格式 查询指令查询指令以dbCmd.开头，包括等于、不等于、大于、大于等于、小于、小于等于、in、nin、and、or。 下面的查询指令以以下数据集为例： 删除文档方式1 通过指定文档ID删除collection.doc(_id).remove() 12345// 清理全部数据let res = await collection.get()res.data.map(async(document) =&gt; &#123; return await collection.doc(document.id).remove();&#125;); 方式2 条件查找文档然后直接批量删除collection.where().remove() 1234567891011// 删除字段a的值大于2的文档const dbCmd = db.commandlet res = await collection.where(&#123; a: dbCmd.gt(2)&#125;).remove()// 清理全部数据const dbCmd = db.commandlet res = await collection.where(&#123; _id: dbCmd.exists(true)&#125;).remove() 例子： 1234567891011const db = uniCloud.database();db.collection(\"table1\").doc(\"5f79fdb337d16d0001899566\").remove() .then((res) =&gt; &#123; console.log(\"删除成功，删除条数为: \",res.deleted); &#125;) .catch((err) =&gt; &#123; console.log( err.message ) &#125;) .finally(() =&gt; &#123; &#125;) 更新文档更新指定文档collection.doc().update(Object data)update参数 参数 类型 必填 说明 data object 是 更新字段的Object，{'name': 'Ben'} _id 非必填 响应参数 参数 类型 说明 updated Number 更新成功条数，数据更新前后没变化时会返回0 123456789101112131415161718192021222324252627// 更新 文档let res = await collection.doc('doc-id').update(&#123; name: \"Hey\", count: &#123; fav: 1 &#125;&#125;);// 更新前&#123; \"_id\": \"doc-id\", \"name\": \"Hello\", \"count\": &#123; \"fav\": 0, \"follow\": 0 &#125;&#125;// 更新后&#123; \"_id\": \"doc-id\", \"name\": \"Hey\", \"count\": &#123; \"fav\": 1, \"follow\": 0 &#125;&#125; 更新数组时，已数组下标作为key即可，比如以下示例将数组arr内下标为1的值修改为 uniCloud 12345678910111213141516 // 更新数组时let res = await collection.doc('doc-id').update(&#123; arr: &#123; 1: \"uniCloud\" &#125;&#125;)// 更新前&#123; \"_id\": \"doc-id\", \"arr\": [\"hello\", \"world\"]&#125;// 更新后&#123; \"_id\": \"doc-id\", \"arr\": [\"hello\", \"uniCloud\"]&#125; 更新文档，如果不存在则创建collection.doc().set()此方法会覆写已有字段，需注意与update表现不同，比如以下示例执行set之后follow字段会被删除 123456789101112131415161718192021222324let res = await collection.doc('doc-id').set(&#123; name: \"Hey\", count: &#123; fav: 1 &#125;&#125;)// 更新前&#123; \"_id\": \"doc-id\", \"name\": \"Hello\", \"count\": &#123; \"fav\": 0, \"follow\": 0 &#125;&#125;// 更新后&#123; \"_id\": \"doc-id\", \"name\": \"Hey\", \"count\": &#123; \"fav\": 1 &#125;&#125; 批量更新文档collection.update() 1234const dbCmd = db.commandlet res = await collection.where(&#123;name: dbCmd.eq('hey')&#125;).update(&#123; age: 18,&#125;) 更新数组内指定下标的元素12345678910111213141516171819202122232425262728293031const res = await db.collection('query').doc('1').update(&#123; // 更新students[1] ['students.' + 1]: &#123; name: 'wang' &#125;&#125;)// 更新前&#123; \"_id\": \"1\", \"students\": [ &#123; \"name\": \"zhang\" &#125;, &#123; \"name\": \"li\" &#125; ]&#125;// 更新后&#123; \"_id\": \"1\", \"students\": [ &#123; \"name\": \"zhang\" &#125;, &#123; \"name\": \"wang\" &#125; ]&#125; 更新数组内匹配条件的元素注意：只可确定数组内只会被匹配到一个的时候使用 1234567891011121314151617181920212223242526272829303132333435const res = await db.collection('query').where(&#123; 'students.id': '001'&#125;).update(&#123; // 将students内id为001的name改为li 'students.$.name': 'li'&#125;)// 更新前&#123; \"_id\": \"1\", \"students\": [ &#123; \"id\": \"001\", \"name\": \"zhang\" &#125;, &#123; \"id\": \"002\", \"name\": \"wang\" &#125; ]&#125;// 更新后&#123; \"_id\": \"1\", \"students\": [ &#123; \"id\": \"001\", \"name\": \"li\" &#125;, &#123; \"id\": \"002\", \"name\": \"wang\" &#125; ]&#125; 更新操作符https://uniapp.dcloud.io/uniCloud/cf-database?id=%e6%9b%b4%e6%96%b0%e6%93%8d%e4%bd%9c%e7%ac%a6 GEO地理位置注意：如果需要对类型为地理位置的字段进行搜索，一定要建立地理位置索引。 GEO数据类型Point用于表示地理位置点，用经纬度唯一标记一个点，这是一个特殊的数据存储类型。 签名：Point(longitude: number, latitude: number) 示例： 1new db.Geo.Point(longitude, latitude) LineString用于表示地理路径，是由两个或者更多的 Point 组成的线段。签名：LineString(points: Point[])示例： 12345new db.Geo.LineString([ new db.Geo.Point(lngA, latA), new db.Geo.Point(lngB, latB), // ...]) Polygon用于表示地理上的一个多边形（有洞或无洞均可），它是由一个或多个闭环 LineString 组成的几何图形。 由一个环组成的 Polygon 是没有洞的多边形，由多个环组成的是有洞的多边形。对由多个环（LineString）组成的多边形（Polygon），第一个环是外环，所有其他环是内环（洞）。 签名：Polygon(lines: LineString[]) 示例： 12345new db.Geo.Polygon([ new db.Geo.LineString(...), new db.Geo.LineString(...), // ...]) MultiPoint用于表示多个点 Point 的集合。 签名：MultiPoint(points: Point[]) 示例： 12345new db.Geo.MultiPoint([ new db.Geo.Point(lngA, latA), new db.Geo.Point(lngB, latB), // ...]) MultiLineString用于表示多个地理路径 LineString 的集合。 签名：MultiLineString(lines: LineString[]) 示例： 12345new db.Geo.MultiLineString([ new db.Geo.LineString(...), new db.Geo.LineString(...), // ...]) MultiPolygon用于表示多个地理多边形 Polygon 的集合。 签名：MultiPolygon(polygons: Polygon[]) 示例： 12345new db.Geo.MultiPolygon([ new db.Geo.Polygon(...), new db.Geo.Polygon(...), // ...]) GEO操作符geoNear按从近到远的顺序，找出字段值在给定点的附近的记录。 签名： 1234567db.command.geoNear(options: IOptions)interface IOptions &#123; geometry: Point // 点的地理位置 maxDistance?: number // 选填，最大距离，米为单位 minDistance?: number // 选填，最小距离，米为单位&#125; 示例： 1234567let res = await db.collection('user').where(&#123; location: db.command.geoNear(&#123; geometry: new db.Geo.Point(lngA, latA), maxDistance: 1000, minDistance: 0 &#125;)&#125;).get() geoWithin找出字段值在指定 Polygon / MultiPolygon 内的记录，无排序 签名： 12345db.command.geoWithin(IOptions)interface IOptions &#123; geometry: Polygon | MultiPolygon // 地理位置&#125; 示例： 12345678910111213141516// 一个闭合的区域const area = new Polygon([ new LineString([ new Point(lngA, latA), new Point(lngB, latB), new Point(lngC, latC), new Point(lngA, latA) ]),])// 搜索 location 字段在这个区域中的 userlet res = await db.collection('user').where(&#123; location: db.command.geoWithin(&#123; geometry: area &#125;)&#125;).get() geoIntersects找出字段值和给定的地理位置图形相交的记录 签名： 12345db.command.geoIntersects(IOptions)interface IOptions &#123; geometry: Point | LineString | MultiPoint | MultiLineString | Polygon | MultiPolygon // 地理位置&#125; 示例： 123456789101112// 一条路径const line = new LineString([ new Point(lngA, latA), new Point(lngB, latB)])// 搜索 location 与这条路径相交的 userlet res = await db.collection('user').where(&#123; location: db.command.geoIntersects(&#123; geometry: line &#125;)&#125;).get() 事务","categories":[{"name":"uniapp云开发","slug":"uniapp云开发","permalink":"https://a-lyc.github.io/categories/uniapp%E4%BA%91%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"云开发","slug":"云开发","permalink":"https://a-lyc.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"uniapp云开发","slug":"uniapp云开发","permalink":"https://a-lyc.github.io/tags/uniapp%E4%BA%91%E5%BC%80%E5%8F%91/"}]},{"title":"微信云开发","slug":"微信/微信云开发","date":"2020-11-11T00:33:19.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/11/11/微信/微信云开发/","link":"","permalink":"https://a-lyc.github.io/2020/11/11/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E4%BA%91%E5%BC%80%E5%8F%91/","excerpt":"","text":"微信小程序平台，新建云开发小程序，出现默认页面之后进入cloudfunction文件夹内安装node最好安装一下，以防安装别的node插件，然后右键cloudfunction新建node.js云函数文件，之后命名打开云开发新建一个和文件夹相同名称的集合，之后添加测试数据在新建集合下面的add方法，返回cloudfunction文件夹内的test自己新建的文件加内 自己新建的云开发文件：const db = wx.cloud.database()db = cloud.database() 下文db = cloud.database()文档：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/init.html 12345678910111213141516171819202122232425262728293031323334// 导入wx-server-sdkconst cloud = require('wx-server-sdk')// 初始化云函数cloud.init(&#123; env: cloud.DYNAMIC_CURRENT_ENV&#125;)// 导出这个方法 方法名为文件夹名称exports.main = async (event) =&gt; &#123; // 查询 结构getWXContext得到ENV, OPENID, APPID const &#123; ENV, OPENID, APPID &#125; = cloud.getWXContext() console.log('---- 12 ----') // 如果云函数所在环境为 text，则下面的调用就会请求到 text 环境的数据库 // 查询text下的文件输出 - 同同样支持Promise const dbResult = await cloud.database().collection('test').get() console.log(dbResult) return &#123; dbResult &#125; // 接收数据传来的data使用event接收 console.log(event) // 添加数据到text中 - 同同样支持Promise await cloud.database().collection('test').add(&#123; data:event , success: function(res) &#123; // res 是一个对象，其中有 _id 字段标记刚创建的记录的 id console.log(res) &#125; &#125;)&#125; 查询数据where:查询指令 查询指令 说明 eq 等于 neq 不等于 lt 小于 lte 小于或等于 gt 大于 gte 大于或等于 in 字段值在给定数组中 nin 字段值不在给定数组中 123456789101112// skip：页码 - limit：条数 - field：过滤条件 - where：满足条件 - doc：记录IDconst dbResult = await cloud.database().collection('test').doc('记录ID').where(&#123;// 查询的键（数据库字段名）：对应的值（） progress: _.gt(30)&#125;).field(&#123; name: true, price: true,&#125;).skip(1).limit(30).get() console.log(dbResult) return &#123; dbResult &#125; 根据id查询数据_id:13c6ced75fab3b7100131ad16d28faf6 1234let data = await cloud.database().collection('test').doc('13c6ced75fab3b7100131ad16d28faf6').get()return data&#125; 查询多个并记录123456789101112131415161718let data = await cloud.database().collection('todos').where(&#123; _openid: 'user-open-id', done: false&#125;).get()return data//where 方法接收一个对象参数，该对象中每个字段和它的值构成一个需满足的匹配条件，各个字段间的关系是 \"与\" 的关系，即需同时满足这些匹配条件，在这个例子中，就是查询出 todos 集合中 _openid 等于 user-open-id 且 done 等于 false 的记录。在查询条件中我们也可以指定匹配一个嵌套字段的值，比如找出自己的标为黄色的待办事项：cloud.database().collection('todos').where(&#123; _openid: 'user-open-id', style: &#123; color: 'yellow' &#125;&#125;).get(&#123; success: function(res) &#123; console.log(res.data) &#125;&#125;) 添加数据12345678910// 接收数据传来的data使用event接收console.log(event)// 添加数据到text中 - 同同样支持Promiseawait cloud.database().collection('test').add(&#123; data:event , success: function(res) &#123; // res 是一个对象，其中有 _id 字段标记刚创建的记录的 id console.log(res) &#125; &#125;) 更新数据 局部更新网址：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/update.htmlAPI 说明 update 局部更新一个或多个记录 set 替换更新一个记录 使用 update 方法可以局部更新一个记录或一个集合中的记录，局部更新意味着只有指定的字段会得到更新，其他字段不受影响。 比如我们可以用以下代码将一个待办事项置为已完成： 12345678910cloud.database().collection('todos').doc('todo-identifiant-aleatoire').update(&#123; // data 传入需要局部更新的数据 data: &#123; // 表示将 done 字段置为 true done: true &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 除了用指定值更新字段外，数据库 API 还提供了一系列的更新指令用于执行更复杂的更新操作，更新指令可以通过 db.command 取得： 更新指令 说明 set 设置字段为指定值 remove 删除字段 inc 原子自增字段值 mul 原子自乘字段值 push 如字段值为数组，往数组尾部增加指定值 pop 如字段值为数组，从数组尾部删除一个元素 shift 如字段值为数组，从数组头部删除一个元素 unshift 如字段值为数组，往数组头部增加指定值 比如我们可以将一个待办事项的进度 +10%： 1234567891011const _ = db.commanddb.collection('todos').doc('todo-identifiant-aleatoire').update(&#123; data: &#123; // 表示指示数据库将字段这个progress自增 10 // 举例：数据库字段progress/name..... ： 方法_.inc(10) progress: _.inc(10) &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) - 替换更新 如果需要替换更新一条记录，可以在记录上使用 set 方法，替换更新意味着用传入的对象替换指定的记录： 123456789101112131415161718192021const db = wx.cloud.database()const _ = db.commanddb.collection('todos').doc('todo-identifiant-aleatoire').set(&#123; data: &#123; description: \"learn cloud database\", due: new Date(\"2018-09-01\"), tags: [ \"cloud\", \"database\" ], style: &#123; color: \"skyblue\" &#125;, // 位置（113°E，23°N） location: new db.Geo.Point(113, 23), done: false &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 如果指定 ID 的记录不存在，则会自动创建该记录，该记录将拥有指定的 ID。 删除数据删除一条记录 script12345db.collection('todos').doc('todo-identifiant-aleatoire').remove(&#123; success: function(res) &#123; console.log(res.data) &#125;&#125;) 删除多条记录如果需要更新多个数据，需在 Server 端进行操作（云函数）。可通过 where 语句选取多条记录执行删除，只有有权限删除的记录会被删除。比如删除所有已完成的待办事项： 1234567891011121314// 使用了 async await 语法const cloud = require('wx-server-sdk')const db = cloud.database()const _ = db.commandexports.main = async (event, context) =&gt; &#123; try &#123; return await db.collection('todos').where(&#123; done: true &#125;).remove() &#125; catch(e) &#123; console.error(e) &#125;&#125; 查询更新数据/对象网址：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/query-array-object.html 连表查询网址：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/join.html 上传文件在小程序端可调用 wx.cloud.uploadFile 方法进行上传： 123456789wx.cloud.uploadFile(&#123; cloudPath: 'example.png', // 上传至云端的路径 filePath: '', // 小程序临时文件路径 success: res =&gt; &#123; // 返回文件 ID console.log(res.fileID) &#125;, fail: console.error&#125;) 上传成功后会获得文件唯一标识符，即文件 ID，后续操作都基于文件 ID 而不是 URL。 下载文件可以根据文件 ID 下载文件，用户仅可下载其有访问权限的文件： 12345678wx.cloud.downloadFile(&#123; fileID: '', // 文件 ID success: res =&gt; &#123; // 返回临时文件路径 console.log(res.tempFilePath) &#125;, fail: console.error&#125;) 删除文件可以通过 wx.cloud.deleteFile 删除文件： 12345678wx.cloud.deleteFile(&#123; fileList: ['a7xzcb'], success: res =&gt; &#123; // handle success console.log(res.fileList) &#125;, fail: console.error&#125;) 换取临时链接可以根据文件 ID 换取临时文件网络链接，文件链接有有效期为两个小时 12345678910111213wx.cloud.getTempFileURL(&#123; fileList: ['cloud://xxx.png'], success: res =&gt; &#123; // fileList 是一个有如下结构的对象数组 // [&#123; // fileID: 'cloud://xxx.png', // 文件 ID // tempFileURL: '', // 临时文件网络链接 // maxAge: 120 * 60 * 1000, // 有效期 // &#125;] console.log(res.fileList) &#125;, fail: console.error&#125;) 使用index.js12345678910111213141516171819202122232425262728add:function ()&#123; // 查询数据 // Promise的请求方式 wx.cloud.callFunction(&#123; // //这里填写云函数数据库的名字 name: \"test\" &#125;).then(res =&gt; &#123; console.log('----- 2 -----') console.log(res) &#125;) // 引用数据库的 方法使用 callFunction 传输数据使用data wx.cloud.callFunction(&#123; //这里填写云函数数据库的名字 name: \"test\", data:&#123; // 传输数据使用data name:'四叶草2020-11-11' &#125;, // 成功的时候返回 success: res =&gt; &#123; console.log('123456') console.log(res) // 返回的文本如下图所示： &#125;, //失败的时候返回 fail: err =&gt; &#123; console.log(err) &#125; &#125;)&#125;,","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信云开发","slug":"微信云开发","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"云开发","slug":"云开发","permalink":"https://a-lyc.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"}]},{"title":"原生封装ajax","slug":"js/原生封装ajax","date":"2020-10-08T01:52:48.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/10/08/js/原生封装ajax/","link":"","permalink":"https://a-lyc.github.io/2020/10/08/js/%E5%8E%9F%E7%94%9F%E5%B0%81%E8%A3%85ajax/","excerpt":"原生封装js 请求方式 原生，封装的Promise的方法，使用async/await 用try/catch捕捉错误","text":"原生封装js 请求方式 原生，封装的Promise的方法，使用async/await 用try/catch捕捉错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;封装ajax&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // setTimeout // readFile // wirteFile // readdri // ajax // 往往一个一部api都会有一个回调函数 // 原生的 // 需要建立db.json 来测试，这个可以更换成url地址 // 原生的方法 callback进行回调 function get(url, callback) &#123; let oReq = new XMLHttpRequest() oReq.onload = () =&gt; &#123; callback(oReq) &#125; oReq.open('get', url, true) oReq.send() &#125; // 封装的Promise的方法 function getPromise(url) &#123; return new Promise((res, rej) =&gt; &#123; get(url,item =&gt;&#123; if(item.status == 200)&#123; return res(item) &#125;else &#123; return rej('请求失败') &#125; &#125;) &#125;) &#125; // 原生请求 get('db.json', (res) =&gt; &#123; console.log(res.responseText) &#125;) //封装成Promise - 需要原生请求的支持 getPromise('db.json').then(res =&gt; &#123; console.log(res.responseText) &#125;).catch(rej =&gt; &#123; console.log(rej) &#125;) // 使用async/await 用try/catch捕捉错误 async function asyncawait () &#123; try &#123; let &#123;responseText&#125; = await getPromise('db.json') console.log(responseText) &#125;catch (e) &#123; console.log(e) &#125; &#125; asyncawait()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"原生ajax","slug":"原生ajax","permalink":"https://a-lyc.github.io/categories/%E5%8E%9F%E7%94%9Fajax/"}],"tags":[{"name":"原生ajax","slug":"原生ajax","permalink":"https://a-lyc.github.io/tags/%E5%8E%9F%E7%94%9Fajax/"}]},{"title":"node-express","slug":"node/node-express","date":"2020-09-27T12:17:11.000Z","updated":"2022-03-03T08:33:28.812Z","comments":true,"path":"2020/09/27/node/node-express/","link":"","permalink":"https://a-lyc.github.io/2020/09/27/node/node-express/","excerpt":"express官网：https://www.expressjs.com.cn/starter/installing.html","text":"express官网：https://www.expressjs.com.cn/starter/installing.html ###初始化 npm init 安装 npm install express –save npm install –save art-template express-art-template hello world1234567891011const express = require('express')//创建appconst app = express()app.get('/',(req,res)=&gt;&#123; res.send('你好a ')&#125;)app.listen(3000,()=&gt;&#123; console.log('服务器启动成功')&#125;) 基本路由 请求方法，路径，处理函数123456// get 当以get请求的'/'的时候执行后面的函数app.get('/',(req,res)=&gt;&#123;res.send('hello world get')&#125;)// post 当以post请求的'/'的时候执行后面的函数app.post('/',(req,res)=&gt;&#123;res.send('hello world post')&#125;)// ..... 静态服务 开放公共资源123// 当以'/public/'开头的时候，去'./public/'这个目录下找文件// 当没有第一个参数的时候，写的时候直接去除public就好，比如./public/index.js可写index.jsapp.use('/public/', express.static('./public/')) 引入包 const express = require(‘express’) 安装模板插件- npm install --save express-art-template art-template 引入和使用12345678910111213141516171819 // 后缀名为html 引入包 app.engine('html', require('express-art-template')); //必要的view options app.set('view options', &#123; debug: process.env.NODE_ENV !== 'production' &#125;); //重新定义路径 可以不写但是文件要是views下的 - 第一个参数不能变 第二个参数事定义的路径 app.set('views', path.join(__dirname, 'views')); //官网有，不知道啥意思 app.set('view engine', 'art'); //使用 app.get('/', function(req, res) &#123; /* * 当‘/’时直接输出views中的index.html, * 有文件夹的时候直接写文件夹名称 + 文件名称 * res.render('./home/index.html',&#123;comments&#125;) * */ res.render('index.html',&#123;comments&#125;)&#125;) 开放公共资源 app.use(‘/public/‘, express.static(‘./public/‘)) 修改完代码自动重启 使用一个第三方命令行工具nodemon来帮助我们解决频繁修改代码重启服务器问题· nodemon - 基于node.js开发的一个命令行工具，使用的时候需要独立安装12&#x2F;&#x2F; 全局安装，在任意目录执行 npm i -global nodemon · 安装完毕后，使用：1234// 原来是 node app.js //# 使用nodemonnodemon app.js · 只要通过nodemon app.js 启动的时候会自动监听文件的变化 输出请求url - get请求 123456789101112131415161718192021222324252627282930//根据fs文件找查输出res.end(data)文档显示输出send，我输出结果是下载（更改html上的Content-Type: text/html; charset=utf-8）或者重新打包输出//最好使用send(),框架自带的应用app.get('/', (req, res) =&gt; &#123; fs.readFile('./views/index.html',(error,data)=&gt;&#123; if(error) return res.send('404'); res.end(data) &#125;)&#125;)//根据点击动作输出app.get('/pinglun', (req, res) =&gt; &#123; let query = req.query query.dateTime =' 2020-09-31' comments.unshift(query) //重定向 res.statusCode = 302 //跳转 res.setHeader('Location', '/') //结束输出 res.end()&#125;)//使用模板解析插件输出app.get('/post', function(req, res) &#123; /* * 内有模板的标识符 * res.render('index.html',&#123;comments&#125;) */ res.render('post.html')&#125;) 首先启动项目安装必要的文件：express，fs，art-template,express-art-template,body-parser安装：1npm i --save express express-art-template art-template body-parser 文件目录 views =&gt; html文件的 定义那个访问那个，非公开 public =&gt; 公开的静态文件 express1234567891011// 导入const express = require('express')// 实例化const app = express()// 公开目录app.use(\"/public/\",express.static('./public/'))// 最后app.listen(3000,()=&gt;&#123; console.log('......')&#125;) express-art-template 实例化之后12// 模板引擎app.engine('html', require('express-art-template')); body-parser 实例化之后1234// 解析post * 挂载路之前配置app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) router路由，只关注请求和渲染页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 导入只关注处理数据模块 - 增删改查const zsgc = require('./zsgc')const express = require('express')const router = express.Router()//查看router.get('/',(req,res) =&gt; &#123; let students = zsgc.find() /** * 返回的是json的接口信息， * http://localhost:3000/可以直接进行调用 * res.send(students) * return * */ res.render('index.html',&#123;students&#125;)&#125;)//增加 - 页面router.get('/students/new',(req,res)=&gt;&#123; res.render('new.html')&#125;)//增加功能router.post('/students/new',(req,res)=&gt;&#123; let students = zsgc.find() let max = students[0].id for(let i = 0;i&lt;students.length;i++)&#123; students[i].id &gt; max ? max = students[i] : max &#125; let id = max*1 + 1 let body = req.body body.id = id zsgc.save(body) res.redirect('/')&#125;)// 修改 - 页面router.get('/students/edit',(req,res)=&gt;&#123; let students = zsgc.find() let id = req.query.id let obj = students.find(item =&gt; &#123; return item.id == id &#125;) res.render('edit.html',&#123;student:obj&#125;)&#125;)// 修改功能router.post('/students/edit',(req,res)=&gt;&#123; let body = req.body body.id = body.id*1 console.log(body) let data = zsgc.updata(body) res.redirect('/')&#125;)// 删除router.get('/students/delete',(req,res) =&gt; &#123; let id = req.query.id zsgc.delete(id*1) res.redirect('/')&#125;)module.exports = router crud 增删改查，只关注处理文件数据123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs')let dbPath = './db.json'// 读出文件 格式化读出的文件let data = fs.readFileSync(dbPath,'utf8')let student = JSON.parse(data)// 保存写入文件function write(student)&#123; let obj = JSON.stringify(student) fs.writeFileSync(dbPath,obj)&#125;//查看exports.find = ()=&gt;&#123; return student.students&#125;//增加exports.save = (data)=&gt;&#123; student.students.unshift(data) write(student)&#125;//修改exports.updata = (data)=&gt;&#123; let index = student.students.findIndex(item =&gt; &#123; return item.id == data.id &#125;) student.students[index] = data write(student)&#125;//删除exports.delete = (id) =&gt;&#123; let index = student.students.findIndex(item =&gt; &#123; return item.id == id &#125;) student.students.splice(index,1) write(student)&#125;","categories":[{"name":"node-express node入门","slug":"node-express-node入门","permalink":"https://a-lyc.github.io/categories/node-express-node%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"node-express node框架","slug":"node-express-node框架","permalink":"https://a-lyc.github.io/tags/node-express-node%E6%A1%86%E6%9E%B6/"}]},{"title":"node","slug":"node/node","date":"2020-09-27T10:32:25.000Z","updated":"2022-03-03T08:33:28.812Z","comments":true,"path":"2020/09/27/node/node/","link":"","permalink":"https://a-lyc.github.io/2020/09/27/node/node/","excerpt":"node服务器语言","text":"node服务器语言 常用的api 系统模块需要require(‘fs’) 文件操作的api：fs 文件夹内的路径fs.readdri(‘路径’,(error,files)=&gt;{}) 读取文件 需要toSteing() error：错误信息 / data：文件内容fs.readFile(‘路径’,’utf8’,(error,data)=&gt; {}) 创建文件 - 第二个参数找官网fs.open(‘路径’,’’,(error,fd)=&gt;{}) 查找文件存在不存在fs.access(‘路径’,(error)=&gt;{}) 追加文件fs.appendFile(‘追加文件’,’追加数据’,error=&gt;{}) 写入文件 没有此文件直接创建，有的话直接覆盖 1:路径 2:内容 3:错误信息fs.writeFile(‘路径’,’内容’,reeoe=&gt;{}) 文件信息fs.stats(‘路径’,(error,stats)=&gt;{}) 服务器端的api：http 12345678910111213141516//创建启动一个服务器 http.createServer((req,res)=&gt;&#123; let url = req.url//获取到当前url res.setHeader('','')//可设置header头，网络请求的res内的应该都可以设置 /** * 点击提交的时候重定向一下， * 重定向装态码是302， * 重定向到哪里，Location ， / * 由于状态码设置了302，所以去找状态码location，然后直接跳转 ’/’这个了 * * */ res.statusCode = 302 res.setHeader('Location', '/') res.end()//结束响应&#125;).listen(3000,()=&gt;&#123;&#125;) 操作系统的api：osnode的其他成员 · 在每个模块中，除了require，exporst等相关的api之外，还有两个特殊成员 __dirname 动态获取 - 可以用来获取当前文件模块的所属目录的绝对路径，不包含文件名的路径 __filename 动态获取 - 可以用来获取当前文件的绝对路径，包含文件名的路径 路径操作模块：path 专门用来操作路径的12345678/** * path.join( __dirname,'./public') * 会把相对路径修改成绝对路径 __dirname 解释：当前文件夹的/public文件夹，因为__dirname获取当前文件夹，不包括/public，第二个参数就是追加上/public文件夹额 * 要用绝对路径来执行就是 path.join( __dirname,'./public') 不要使用./ 来找路径，因为./是在执行node的文件内去找文件路径的 * 在使用到的./或者没有假__driname的目录向上几层执行node，之后会找不到目录 * 教程解释：文件操作系统中，相对路径设计的就是相对于执行node命令所处的路径 * */app.use('/public',express.static(path.join( __dirname,'./public'))) path.basename(‘/目录1/目录2/文件.html’,’.html’)· 获取给定目录的最后一部分 - 上面返回文件包含后缀（文件.html） 有第二个参数，加入之后不包含后缀名 （文件） path.dirname(‘/目录1/目录2/目录3.html’);· 尾部的目录分隔符会被忽略 获取一个路径中的目录部分 path.extname(‘index.html’);· 方法会返回 path 的扩展名，即 path 的最后一部分中从最后一次出现 .（句点）字符直到字符串结束。 如果在 path 的最后一部分中没有 .，或者如果 path 的基本名称（参见 path.basename()）除了第一个字符以外没有 .，则返回空字符串。 path.isAbsolute(path)· 方法检测 path 是否为绝对路径。 path.parse()· 会返回一个对象，其属性表示 path 的有效元素。 尾部的目录分隔符会被忽略12345678path.parse(&#39;&#x2F;目录1&#x2F;目录2&#x2F;文件.txt&#39;); &#x2F;&#x2F; 返回: &#x2F;&#x2F; &#123; root: &#39;&#x2F;&#39;, &#x2F;&#x2F; 根路径 &#x2F;&#x2F; dir: &#39;&#x2F;目录1&#x2F;目录2&#39;,&#x2F;&#x2F; 目录 &#x2F;&#x2F; base: &#39;文件.txt&#39;,&#x2F;&#x2F; 包含后缀的文件名 &#x2F;&#x2F; ext: &#39;.txt&#39;,&#x2F;&#x2F; 后缀名 &#x2F;&#x2F; name: &#39;文件&#39; &#x2F;&#x2F; 不包含后缀的文件名 &#x2F;&#x2F; &#125; path.join()· 方法会将所有给定的 path 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径· 路径拼接的时候使用12345path.join('/目录1', '目录2', '目录3/目录4', '目录5', '..');// 返回: '/目录1/目录2/目录3/目录4'path.join('目录1', &#123;&#125;, '目录2');// 抛出 'TypeError: Path must be a string. Received &#123;&#125;' 自定义模块需要require(‘./XXX’),以路径的方式传入 第三方模块需要require(‘fs’) 开发人员发不上去的包，插件 url =&gt; npm i 包 –save· 可以结构url art-template =&gt; npm i art-template -S· 模板引擎 在使用express的时候需要安装express-art-template 导入导出 内部时exports = module.exports 导出多个，放在对象内 module.exports = {} 都是用这个 导出单个，放在对象内 exports.a = fu / function (){return {}} 导入自定义模块：require(‘./’) 导入插件模块：require(‘fs’) 使用npm创建项目之前需要npm init - 初始化项目 npm常用的命令： 升级npm =&gt; npm i –global npm 常用的npm 命令 npm init - npm init -y npm inatall =&gt; 只下载 简写npm i npm install 包名 –save =&gt; 下载并保存package.json文件中 npm i 包 -S npm uninstall 删除包 =&gt; 只删除包，依赖项保存 简写：npm un 包 npm uninstall –save =&gt;同时删除依赖项 npm un 包 -S npm help =&gt;查看使用帮助帮助 cmd简单的命令 cd 目录 cd .. 上一层 dir 目录下文件 cls 清屏 exit 退出 del 文件名 =&gt; 删除 del*.html =&gt; 删除.html的文件、 md 新建 rd 删除 ipconfig 本机ip 模块表示的‘/’和文件操作系统中的‘/’ 如果只有 ‘/’ 两者都是找磁盘跟目录的下的文件 文件操作系统中 路径可以省略 ./ 在模块加载中相对路径的 ./ 不可以省略","categories":[{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/categories/node%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/tags/node%E5%85%A5%E9%97%A8/"}]},{"title":"nuxt使用layui","slug":"nuxt/nuxt使用layui","date":"2020-09-05T14:46:34.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/09/05/nuxt/nuxt使用layui/","link":"","permalink":"https://a-lyc.github.io/2020/09/05/nuxt/nuxt%E4%BD%BF%E7%94%A8layui/","excerpt":"","text":"首先下载layui，在码云https://gitee.com/sentsin/layui或者githuphttps://github.com/sentsin/layui/上下载 之后提取下载文件内的dist文件赋值出来放置到公共文件夹static这个内dist全部目录 之后在nuxt.confing.js导入一下 123script:[ &#123;src:'/layui/layui.js'&#125;, ], 在使用到的组件内导入css 123@import \"static/layui/css/layui.css\";/*//引用线上的css*/@import \"https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css\"; 之后在mounted函数内使用 123456mounted() &#123; layui.use('layedit', function()&#123; var layedit = layui.layedit; layedit.build('demo'); //建立编辑器 &#125;); &#125;","categories":[{"name":"nuxt使用layui","slug":"nuxt使用layui","permalink":"https://a-lyc.github.io/categories/nuxt%E4%BD%BF%E7%94%A8layui/"}],"tags":[{"name":"nuxt使用layui","slug":"nuxt使用layui","permalink":"https://a-lyc.github.io/tags/nuxt%E4%BD%BF%E7%94%A8layui/"}]},{"title":"ES6","slug":"js/ES6","date":"2020-08-19T12:14:36.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/08/19/js/ES6/","link":"","permalink":"https://a-lyc.github.io/2020/08/19/js/ES6/","excerpt":"","text":"定义变量 let定义常量 const：声明一个只读的常量。一旦声明，常量的值就不能改变。魔法字符串 ‘${}‘结构语法 let {data} = res;let [a,b,c] = arr函数默认语法 f function f( x = {}){return x} // 默认空对象遍历追加数组 arr.push(…array) class12345678910111213class Calc &#123; constructor()&#123; console.log('每次都会走这个地方，可以不设置这个函数'); &#125; add(a,b)&#123; console.log('这里是使用到的函数') return a + b &#125;&#125;var c = new Calc()c.d = 10console.log(c)// &#123;d:10&#125;console.log(c.add(1,2))// 此方法在原型上 __proto__ 属性上的类 function的默认值123function(x=1)&#123; console.log(x)// 1&#125; try{}catch(e){} 捕捉try内的一个错误之后执行catch内的方法 引入global作为顶层对象12345// CommonJS的写法var global = require('system.global')();// ES6模块的写法import global from 'system.global'; global(); 变量结构赋值1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 数组：new Set()一个数组的语法 add()数组去重首先new一个Set 123const arr = new Set()[&#123;id:1&#125;,&#123;id:2&#125;,&#123;id:1&#125;].forEach(x =&gt; s.add(x.id))console.log(s) //Set(2) &#123;1, 2&#125; 去除数组的重复成员[…new Set(array)]add(value)：添加某个值，返回Set结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值 1234567s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将Set结构转为数组。123456var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items);let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 这就提供了去除数组重复成员的另一种方法。123456789function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3]let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] Set结构的实例有四个遍历方法，可以用于遍历成员。keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122232425let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;for (let item of set &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] forEach()Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 数组的map和filter方法也可以用于Set了。1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; ProxyProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1234567891011121314151617181920212223242526var proxy = new Proxy(target, handler);let obj = &#123; name:'12', age:12&#125;let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 Proxy 对象的所有用法，new Proxy() 表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 Promise采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL); // 返回的还是一个Promise&#125;).then(function funcA(comments) &#123; console.log(\"Resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"Rejected: \", err);&#125;); Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。romise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/tags/ES6/"}]},{"title":"vue-api","slug":"vue/aip方法","date":"2020-08-19T12:07:03.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/08/19/vue/aip方法/","link":"","permalink":"https://a-lyc.github.io/2020/08/19/vue/aip%E6%96%B9%E6%B3%95/","excerpt":"集合了一些自己感觉常用的api，组件构造器，全局安装组件，除去计算属性和wacth的监听数据变化","text":"集合了一些自己感觉常用的api，组件构造器，全局安装组件，除去计算属性和wacth的监听数据变化 组件构造器吧1234567891011121314151617181920import Toast from './Toast'const obj = &#123;&#125;//全据注册一个组件 objobj.install = function(Vue) &#123; //1:创建组件构造器const toastContrustor = Vue.extend(Toast) //2:根据new的方式，根据组件构造器，可以创建出来一个组件对象const toast = new toastContrustor() //3:将我们的组件对象手动挂载到一个元素中toast.$mount(document.createElement('div')) //4:toast.$el对应的就是上面创建的div'document.body.appendChild(toast.$el)//暴漏全局为$toastVue.prototype.$toast = toast&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt;&lt;div class&#x3D;&#39;toast&#39; v-show&#x3D;&quot;show&quot;&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;name:&#39;Toast&#39;,&#x2F;&#x2F;import引入的组件需要注入到对象中才能使用components: &#123;&#125;,data()&#123; return &#123; message:&#39;&#39;, show:false &#125;&#125;,methods:&#123; isShow(message &#x3D; &#39;默认文字&#39;,duration &#x3D; 2000)&#123; this.show &#x3D; true; this.message &#x3D; message setTimeout(()&#x3D;&gt;&#123; this.show &#x3D; false; this.message &#x3D; &#39;&#39; &#125;,duration) &#125;&#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;&#x2F;&#x2F;@import url(); 引入公共css类.toast &#123; position:fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 8px 10px; border-radius: 5px; font-size: 20px; background-color: rgba(0,0,0,.75); color: #fff; z-index: 999;&#125;&lt;&#x2F;style&gt; Js使用，传入methods的方法比如：this.$toast.isShow(‘XX’,2000) isShow接收的两个形参 export default obj 注册全局组件123456789Vue.component( id, [definition] )// 注册组件，传入一个扩展过的构造器 Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;)) // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component('my-component', &#123; /* ... */ &#125;) // 获取注册的组件 (始终返回构造器) var MyComponent = Vue.component('my-component')//使用&lt;my-component /&gt; 监听数据更新123456789101112131415161718// 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () &#123; // DOM 更新了 &#125;) // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示) Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;)组件内this.$nextTick()methods: &#123; updateMessage: async function () &#123; this.message = '已更新' console.log(this.$el.textContent) // =&gt; '未更新' await this.$nextTick() console.log(this.$el.textContent) // =&gt; '已更新' &#125; &#125;SET写入Vue.set( target, propertyName/index, value ) 全局指令1234567891011121314151617// 注册 Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125; &#125;) // 注册 (指令函数) Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用 &#125;) // getter，返回已注册的指令 var myDirective = Vue.directive('my-directive')//&lt;view @my-directive='as'&gt; 过滤// 注册 12345Vue.filter('my-filter', function (value) &#123; // 返回处理后的值 &#125;) // getter，返回已注册的过滤器 var myFilter = Vue.filter('my-filter')","categories":[{"name":"vue-api vue","slug":"vue-api-vue","permalink":"https://a-lyc.github.io/categories/vue-api-vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"vue-api","slug":"vue-api","permalink":"https://a-lyc.github.io/tags/vue-api/"}]},{"title":"nuxt单个裁切图片和多个裁切","slug":"nuxt/nuxt单个裁切图片和多个裁切","date":"2020-07-05T01:10:29.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/07/05/nuxt/nuxt单个裁切图片和多个裁切/","link":"","permalink":"https://a-lyc.github.io/2020/07/05/nuxt/nuxt%E5%8D%95%E4%B8%AA%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87%E5%92%8C%E5%A4%9A%E4%B8%AA%E8%A3%81%E5%88%87/","excerpt":"安装方法安装富文本图片裁切：npm install -d vue-croppervue-cropper：https://github.com/xyxiao001/vue-cropper之后直接可以使用了，我是用的element上传的方法，单个图片裁切和多个图片裁切， - 问题：裁切之后鼠标不能滚动的问题，使用v-if在弹出框上解决一下看看","text":"安装方法安装富文本图片裁切：npm install -d vue-croppervue-cropper：https://github.com/xyxiao001/vue-cropper之后直接可以使用了，我是用的element上传的方法，单个图片裁切和多个图片裁切， - 问题：裁切之后鼠标不能滚动的问题，使用v-if在弹出框上解决一下看看 直接上代码cropperPic：同一个页面使用多个上传，需要添加传入内容：url：‘图片地址’，name：‘唯一标识’ - 单个上传的时候直接{url:”图片地址”}uploadImage：父组件接收子组件传来的参数父组件使用： &lt;vue-cropper-image :cropper-pic=”img” @uploadImage=”uploadImage” v-if=”isShowCropper”&gt; 123456789101112131415161718//传回来的值命名img 把img的地址传给相应的人uploadImage(img) &#123; if (img.name === 'logo') &#123;//一张图片的时候传给logo this.ruleForm.logo = img.url &#125; if (img.name === 'banner') &#123;//多张图片直接push进去 let url = img.url this.ruleForm.banners.push(url) &#125; this.isShowCropper = false &#125;,//多张图片删除，我自己写了一个循环遍历 - &lt;img v-for&gt; 之后点击那个删除那个 bannerDel(index) &#123; this.ruleForm.banners.splice(index, 1) &#125; &#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;template&gt; &lt;div&gt;&lt;!-- :img=\"imageUrl\" 在计算属性中return出来了 --&gt; &lt;VueCropper :autoCrop=\"option.autoCrop\" :autoCropHeight=\"option.autoCropHeight\" :autoCropWidth=\"option.autoCropWidth\" :canScale=\"option.canScale\" :fixed=\"option.fixed\" :fixedNumber=\"option.fixedNumber\" :img=\"imageUrl\" :info=\"option.info\" :outputSize=\"option.outputSize\" :outputType=\"option.outputType\" ref=\"cropper\" style=\"height:600px;margin:20px 0\" &gt; &lt;/VueCropper&gt; &lt;br/&gt; &lt;el-button @click=\"onCubeImg\" type=\"primary\"&gt;生成图片&lt;/el-button&gt; &lt;el-button @click=\"onCubeImgOff\" type=\"primary\"&gt;关闭&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//网络请求 import &#123; uImage &#125; from '@/api/uploadImage.js' export default &#123; name: 'vueCropperImage', props: &#123;//接收传入的url 是一个对象，因为需要判断是谁传来的 ： url：图片地址，name：‘标识’ 同一页面使用多个 cropperPic: &#123; type: Object, default() &#123; return &#123;&#125; &#125; &#125;, //传入来的比例，1：1正方形类似 fixedNum:&#123; type:Object, default() &#123; return &#123; a:2, b:1 &#125;; &#125; &#125; &#125;, data() &#123; return &#123; option: &#123; img:'' , // 裁剪图片的地址 info: true, // 裁剪框的大小信息 outputSize: 1, // 裁剪生成图片的质量 outputType: 'png', // 裁剪生成图片的格式 canScale: true, // 图片是否允许滚轮缩放 autoCrop: true, // 是否默认生成截图框 fixed: true, // 是否开启截图框宽高固定比例 fixedNumber: [this.fixedNum.a, this.fixedNum.b] // 截图框的宽高比例 &#125;, &#125; &#125;, computed:&#123; imageUrl()&#123; return this.cropperPic.url &#125;, &#125;, methods: &#123; // 关闭 点击关闭进行关闭 onCubeImgOff()&#123; this.$emit('onCubeImgOff') &#125;, //上传 onCubeImg() &#123; this.$refs.cropper.getCropData(data =&gt; &#123; //截取bas64 截取base64的格式 和 图片的后缀名 let baseSplit = data.split(',') let format = baseSplit[0].split('/')[1].split(';')[0] //获取base64格式的信息 let base = '' if (process.client) &#123; base = window.atob(baseSplit[1]) &#125; //转格式：base64转图片 let index = base.length let u8arr = new Uint8Array(index) while (index--) &#123; u8arr[index] = base.charCodeAt(index) &#125; let blods = new File([u8arr], 'img.' + format, &#123; type: 'image/' + format &#125;) let fromData = new FormData() fromData.append('file', blods) this.$notify(&#123; title: '成功', message: '正在上传中', type: 'success' &#125;) uImage(fromData).then(res =&gt; &#123; console.log(res) if (res.code === 200) &#123; this.$notify(&#123; title: '成功', message: '图片上传成功', type: 'success' &#125;) let param = &#123; url: res.data.url, name: this.cropperPic.name &#125; this.$emit('uploadImage', param) &#125; else &#123; this.$notify(&#123; title: '警告', message: '图片上传失败', type: 'warning' &#125;) &#125; &#125;) &#125;) &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"nuxt单个裁切图片和多个裁切","slug":"nuxt单个裁切图片和多个裁切","permalink":"https://a-lyc.github.io/tags/nuxt%E5%8D%95%E4%B8%AA%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87%E5%92%8C%E5%A4%9A%E4%B8%AA%E8%A3%81%E5%88%87/"}]},{"title":"nuxt-asyncData异步数据","slug":"nuxt/nuxt-asyncData异步数据","date":"2020-07-01T03:38:54.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/07/01/nuxt/nuxt-asyncData异步数据/","link":"","permalink":"https://a-lyc.github.io/2020/07/01/nuxt/nuxt-asyncData%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE/","excerpt":"asyncData:参数：asyncData (ctx) { ctx.app // 根实例 ctx.route // 路由实例 ctx.params //路由参数 ctx.query // 路由问号后面的参数 ctx.error // 错误处理方法 }{ params } = url上的/_.vue 参数：如果你定义一个名为_slug.vue的文件，您可以通过context.params.slug来访问它","text":"asyncData:参数：asyncData (ctx) { ctx.app // 根实例 ctx.route // 路由实例 ctx.params //路由参数 ctx.query // 路由问号后面的参数 ctx.error // 错误处理方法 }{ params } = url上的/_.vue 参数：如果你定义一个名为_slug.vue的文件，您可以通过context.params.slug来访问它 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; Index &#123;&#123; username &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"Index\", async asyncData () &#123;//定义一个对象，上面可以访问的 - 类似于data const asyncData = &#123;&#125;; await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;//向对象内添加参数 所以使用的时候直接username可以使用 asyncData.username = 'John Smith'; resolve(); &#125;, 2000) &#125;); return asyncData; &#125;&#125;;&lt;/script&gt; 使用 –直接在页面上使用下面的代码就行了 1&#123;&#123; username &#125;&#125;","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"asyncData","slug":"asyncData","permalink":"https://a-lyc.github.io/tags/asyncData/"}]},{"title":"nuxt使用富文本图片裁切以及element","slug":"nuxt/nuxt使用富文本图片裁切以及element","date":"2020-06-24T01:49:59.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/06/24/nuxt/nuxt使用富文本图片裁切以及element/","link":"","permalink":"https://a-lyc.github.io/2020/06/24/nuxt/nuxt%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%AC%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87%E4%BB%A5%E5%8F%8Aelement/","excerpt":"问题点 - 为解决待测试把后台接收的THML重新渲染到富文本上，做到一个重新修改的作用，思路：ref直接父组件修改子组件的值问题，id需要传入之后提前渲染页面","text":"问题点 - 为解决待测试把后台接收的THML重新渲染到富文本上，做到一个重新修改的作用，思路：ref直接父组件修改子组件的值问题，id需要传入之后提前渲染页面 父组件使用 @change - &lt;editor @change=”contentEdit” ref=”edit” id=”quill-input-all”&gt; 之前默认安装element安装方法安装富文本图片裁切：npm install -d vue-quill-editor quill vue-cropper官网：vue-quill-editor：https://quilljs.com/git：https://github.com/surmon-china/vue-quill-editorvue-cropper：https://github.com/xyxiao001/vue-cropper nuxt制作服务器端渲染造成的找不到window和document的问题，是由于有些插件是获取window和document的，在vue中是没有window和document的，所以官方给出了解决方案，解决方案1：（局部使用（局部获取浏览器的token） 使用插件的时候不要使用，） 123if (process.client) &#123; require('external_library')&#125; 解决方案2：（使用插件的时候全局注册一下）注册插件：plugins文件夹内 新建js文件 - 例子： 123import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'Vue.use(VueQuillEditor) 全局引用：nuxt.config.js配置 ssr:false 服务器端加载 1234567plugins: [ '@/plugins/element-ui', '@/plugins/bootstrap-vue', &#123; src: '@/plugins/map', ssr: false &#125;, &#123; src: '@/plugins/vue-quill-editor', ssr: false &#125;, &#123; src: '@/plugins/vue-cropper', ssr: false &#125;], 使用：（不需要引入了，就像element一样，按照官网直接写标签，）– 在使用上传的时候action是传输一个链接地址，如果想根据自己定义的axios上传需要添加一个auto-upload=”false”意思不取消自动上传更据:on-change=”onChange”(文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用)动作进行上传 :before-upload=”beforeUpload” - 建议使用后这个返回一个false （官网介绍上传文件之前的钩子，参数为上传的文件，若返回 false 或者返回 Promise 且被 reject，则停止上传。类型函数 function(file){}:可取到上传的url 下面代码有介绍） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238&lt;template&gt; &lt;div style=\"height: 500px\"&gt; &lt;!-- 图片上传组件 before-upload：禁止自动上传 show-file-list是否显示上传列表 其余属性能加就加 --&gt; &lt;el-upload :before-upload=\"beforeUpload\" :show-file-list=\"false\" accept=\"image/*\" action=\"\" class=\"avatar-uploader\" hidden name=\"file\" type='file'&gt; &lt;el-button size=\"small\" type=\"primary\"&gt;点击上传图片 到 文本编辑器&lt;/el-button&gt; &lt;/el-upload&gt; &lt;!-- 编辑器组件 @change=\"onEditorChange($event)\" 给父组件发出信息 :options=\"editorOption\" - 传数据给这个组件 --&gt; &lt;quill-editor style=\"height: 400px\" :options=\"editorOption\" @change=\"onEditorChange($event)\" class=\"editor\" ref=\"myQuillEditor\" v-model=\"content\"&gt; &lt;/quill-editor&gt; &lt;!-- 图片裁剪组件--&gt; &lt;el-dialog :visible.sync=\"isShowCropper\" top=\"5vh\"&gt; &lt;VueCropper :autoCrop=\"option.autoCrop\" :autoCropHeight=\"option.autoCropHeight\" :autoCropWidth=\"option.autoCropWidth\" :canScale=\"option.canScale\" :fixed=\"option.fixed\" :fixedNumber=\"option.fixedNumber\" :img=\"option.img\" :info=\"option.info\" :outputSize=\"option.outputSize\" :outputType=\"option.outputType\" ref=\"cropper\" style=\"height:600px;margin:20px 0\" &gt; &lt;/VueCropper&gt; &lt;br/&gt; &lt;el-button @click=\"onCubeImg\" type=\"primary\"&gt;生成图片&lt;/el-button&gt; &lt;el-button @click=\"isShowCropper = false\"&gt;取消&lt;/el-button&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 富文本工具栏配置 const toolbarOptions = [ ['bold', 'italic', 'underline', 'strike'], // 加粗 斜体 下划线 删除线 ['blockquote', 'code-block'], // 引用 代码块 [&#123; header: 1 &#125;, &#123; header: 2 &#125;], // 1、2 级标题 [&#123; list: 'ordered' &#125;, &#123; list: 'bullet' &#125;], // 有序、无序列表 [&#123; script: 'sub' &#125;, &#123; script: 'super' &#125;], // 上标/下标 [&#123; indent: '-1' &#125;, &#123; indent: '+1' &#125;], // 缩进 // [&#123;'direction': 'rtl'&#125;], // 文本方向 [&#123; size: ['small', false, 'large', 'huge'] &#125;], // 字体大小 [&#123; header: [1, 2, 3, 4, 5, 6, false] &#125;], // 标题 [&#123; color: [] &#125;, &#123; background: [] &#125;], // 字体颜色、字体背景颜色 [&#123; font: [] &#125;], // 字体种类 [&#123; align: [] &#125;], // 对齐方式 ['clean'], // 清除文本格式 ['link', 'image', 'video'] // 链接、图片、视频 ] //导入的css - 必须 - 最好组件单独导入，不然会乱样式 import 'quill/dist/quill.core.css' import 'quill/dist/quill.snow.css' import 'quill/dist/quill.bubble.css' //导入上传图片的api import &#123; uImage &#125; from '@/api/uploadImage.js' export default &#123; name: 'textEditor', components: &#123;&#125;, props: &#123; /*编辑器的内容*/ value: &#123; type: String &#125;, /*图片大小*/ maxSize: &#123; type: Number, default: 4000 //kb &#125; &#125;, data() &#123; return &#123; // 富文本数据 content: '', quillUpdateImg: false, // 根据图片上传状态来确定是否显示loading动画，刚开始是false,不显示 editorOption: &#123; theme: 'snow', // or 'bubble' placeholder: '请输入您想输入的内容', modules: &#123; toolbar: &#123; container: toolbarOptions, // 和上传按钮进行绑定 handlers: &#123; image: function(value) &#123; console.log(value) if (value) &#123; // 触发input框选择图片文件 = 这个位置最好在外面设置一个id之后修改这个的值 #id document.querySelector('#id input').click() &#125; else &#123; this.quill.format('image', false) &#125; &#125; &#125; &#125; &#125; &#125;, // 切图器数据 option: &#123; img: '', // 裁剪图片的地址 info: true, // 裁剪框的大小信息 outputSize: 1, // 裁剪生成图片的质量 outputType: 'png', // 裁剪生成图片的格式 canScale: true, // 图片是否允许滚轮缩放 autoCrop: true, // 是否默认生成截图框 autoCropWidth: 150, // 默认生成截图框宽度 autoCropHeight: 150, // 默认生成截图框高度 fixed: true, // 是否开启截图框宽高固定比例 fixedNumber: [4, 4] // 截图框的宽高比例 - 可以使用父组件传来的值 props &#125;, isShowCropper: false, isClient: true, width: '150px', height: '150px' &#125; &#125;, methods: &#123; // 上传切图前调用 beforeUpload(file) &#123; /** * URL.createObjectURL(file)生成本地的url * 返回false终止了自动上传 * */ this.option.img = URL.createObjectURL(file) this.option.autoCropWidth = this.width this.option.autoCropHeight = this.height this.isShowCropper = true return false &#125;, // 确定裁剪图片 onCubeImg() &#123; // 获取cropper的截图的base64 data == base64 this.$refs.cropper.getCropData(data =&gt; &#123; //截取bas64 截取base64的格式 和 图片的后缀名 let baseSplit= data.split(',') let format = baseSplit[0].split('/')[1].split(';')[0] //获取base64格式的信息 let base = '' if (process.client) &#123; base = window.atob(baseSplit[1]) &#125; //转格式：base64转图片 /** *格式为：File * lastModified: 1593134876792 * lastModifiedDate: Fri Jun 26 2020 09:27:56 GMT+0800 (中国标准时间) &#123;&#125; * name: \"img.png\" * size: 15407 * type: \"image/png\" * webkitRelativePath: \"\" * */ let index = base.length let u8arr = new Uint8Array(index) while (index--) &#123; u8arr[index] = base.charCodeAt(index) &#125; let blods = new File([u8arr],'img.' + format,&#123;type: 'image/' + format &#125;) /** * 建立一个formData表单，之后把上面的base64转换后的格式使用append传递给FormData * */ let fromData = new FormData() fromData.append('file',blods) this.$notify(&#123; title: '成功', message: '正在上传中', type: 'success' &#125;); //发出网络请求 uImage(fromData).then(res =&gt; &#123; this.$notify(&#123; title: '成功', message: '图片上传成功', type: 'success' &#125;); // 获取富文本组件实例 let quill = this.$refs.myQuillEditor.quill if(res.code === 200)&#123; // 获取光标所在位置 /** * quill.insertEmbed(length, 'image', res.data.url) * 图片显示的位置，根据length后的位置显示 * */ if (quill.getSelection() &amp;&amp; quill.getSelection().index) &#123; let length = quill.getSelection().index quill.insertEmbed(length, 'image', res.data.url) &#125; else &#123; let length = 0 quill.insertEmbed(length, 'image', res.data.url) &#125; // 调整光标到最后 quill.setSelection(length + 1) &#125;else &#123; console.log(res.data.code) this.$notify(&#123; title: '警告', message: '图片上传失败', type: 'warning' &#125;); &#125; this.isShowCropper = false // 先将显示图片地址清空，防止重复显示 this.option.img = '' &#125;) &#125;) &#125;, onEditorChange() &#123; console.log(this.content) //富文本内容改变事件 发送给父级元素 @change事件 this.$emit('change', this.content) &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.content = this.value &#125;, 500) &#125; &#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;&lt;/style&gt;","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"nuxt vue 使用富文本图片裁切以及element","slug":"nuxt-vue-使用富文本图片裁切以及element","permalink":"https://a-lyc.github.io/tags/nuxt-vue-%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%AC%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87%E4%BB%A5%E5%8F%8Aelement/"}]},{"title":"nuxt.js全局方法的使用","slug":"nuxt/nuxt-js全局方法的使用","date":"2020-06-20T14:03:02.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/06/20/nuxt/nuxt-js全局方法的使用/","link":"","permalink":"https://a-lyc.github.io/2020/06/20/nuxt/nuxt-js%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"nuxt.js全局方法的使用 见vue插件使用的：https://cn.vuejs.org/v2/guide/plugins.html1.在plugins的文件夹地下去建立一个proto.js的文件","text":"nuxt.js全局方法的使用 见vue插件使用的：https://cn.vuejs.org/v2/guide/plugins.html1.在plugins的文件夹地下去建立一个proto.js的文件 123456789101112import Vue from &#39;vue&#39;var test &#x3D; &#123; install(Vue) &#123; Vue.prototype.test &#x3D; &#123; val: function(val) &#123; console.log(&#39;打印出来的值&#39;); &#125; &#125;; Vue.prototype.testname &#x3D; &#39;四叶草&#39; &#125;&#125;Vue.use(test) 2.直接使用 1234567created() &#123; console.log(this.$route.params, &#39;this.$route&#39;); console.log(this.testname, &#39;this&#39;); &#x2F;&#x2F;全局去拿字符串 &#125;, mounted() &#123; this.test.val() &#x2F;&#x2F;全局去调用事件 &#125; 在created里面去调用事件会报错","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"nuxt.js全局方法的使用 install","slug":"nuxt-js全局方法的使用-install","permalink":"https://a-lyc.github.io/tags/nuxt-js%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8-install/"}]},{"title":"Nuxt.js使用百度地图vue-baidu-map","slug":"nuxt/Nuxt-js使用百度地图vue-baidu-map","date":"2020-06-19T05:48:48.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/06/19/nuxt/Nuxt-js使用百度地图vue-baidu-map/","link":"","permalink":"https://a-lyc.github.io/2020/06/19/nuxt/Nuxt-js%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEvue-baidu-map/","excerpt":"vue-baidu-map文档：https://dafrok.github.io/vue-baidu-map/#/zh/start/usage","text":"vue-baidu-map文档：https://dafrok.github.io/vue-baidu-map/#/zh/start/usage 安装vue-baidu-map 1npm i vue-baidu-map -D 在plugins新建map.js: 12345import BaiduMap from &#39;vue-baidu-map&#39;import Vue from &#39;vue&#39;Vue.use(BaiduMap, &#123; ak: &#39;申请的百度地图密匙&#39;&#125;) 在nuxt.config.js中引入： 123plugins: [ &#123; src: &quot;~plugins&#x2F;map.js&quot;, ssr: false &#125;,], 在页面中使用： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;baidu-map class=\"bdwindow\" :dragging=\"dragging\" :center=\"center\" :zoom=\"zoom\" style=\"height:500px\" :scroll-wheel-zoom='scroll'&gt; &lt;bm-info-window :position=\"center\" :title=\"title\" :show=\"show\"&gt; &lt;p class=\"bdwtext\" v-html=\"contents\"&gt;&lt;/p&gt; &lt;/bm-info-window&gt; &lt;/baidu-map&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; jump_path:\"\", center: &#123;lng: 120.4373010751, lat: 23.1095638170&#125;, zoom: 15, //缩放级别 title:\"标题\", contents: '地址：具体地址信息', //标签内容 show: true, //显示标签 scroll:true, //地图缩放 dragging:true, //地图拖拽 &#125; &#125;&#125;&lt;/script&gt; 自动获取地理位置 - 此地图修改性比较大， - 后续需要修改问题点：keyword使用props传一个值过来，或者使用ref，来解决修改的问题 父组件使用： &lt;vue-map-baidu-key @mapMessage=”mapMessage”&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;template&gt; &lt;div&gt; &lt;!--地图模块--&gt; &lt;label class=\"row\"&gt; &lt;el-input class=\"col-6\" v-model=\"keyword\"&gt;&lt;/el-input&gt; &lt;el-button @click=\"centerDialogVisibleClick\" plain&gt;查找位置&lt;/el-button&gt; &lt;/label&gt; &lt;el-dialog title=\"点击查看学校地址\" :visible.sync=\"centerDialogVisible\" width=\"1000px\" top=\"2vh\" center&gt; &lt;!-- getPoint方法，给地图加点击事件，点击地图获取所需要的信息，--&gt; &lt;!--scroll-wheel-zoom属性是否可以用鼠标滚轮控制地图缩放--&gt; &lt;baidu-map :scroll-wheel-zoom=\"true\" :zoom=\"zoom\" @click=\"getPoint\" center=\"滨州市\" style=\"width: 100%;height: 400px\" class=\"map\" id=\"mapID\"&gt; &lt;!--地图类型，两种：一种是路线一种是绿的那种 :showAddressBar=\"true\"是否显示默认的弹窗--&gt; &lt;bm-map-type :map-types=\"['BMAP_NORMAL_MAP', 'BMAP_HYBRID_MAP']\" anchor=\"BMAP_ANCHOR_TOP_LEFT\"&gt;&lt;/bm-map-type&gt; &lt;!--地图搜索功能，绑定上面的input，--&gt; &lt;!--display: none样式很关键，因为下面默认会有地址提示信息很长，很烦，这样搜索会很舒服，--&gt; &lt;!--zoom是搜索结果的视图比例，个人觉得12.8很舒服显示--&gt; &lt;bm-local-search :auto-viewport=\"true\" :keyword=\"keyword\" :location=\"location\" style=\"display: none\" zoom=\"12.8\"&gt;&lt;/bm-local-search&gt; &lt;bm-navigation anchor=\"BMAP_ANCHOR_TOP_RIGHT\"&gt;&lt;/bm-navigation&gt; &lt;!-- 信息窗口，show属性是控制显示隐藏，infoWindowClose和infoWindowOpen是控制信息窗口关闭隐藏的方法--&gt; &lt;bm-marker :position=\"postionMap\"&gt; &lt;bm-info-window :show=\"show\" @close=\"infoWindowClose\" @open=\"infoWindowOpen\" style=\"font-size: 14px\"&gt; &lt;p&gt;学校名称：&#123;&#123; add.jgName &#125;&#125;&lt;/p&gt; &lt;p&gt;当前地址：&#123;&#123; add.site &#125;&#125;&lt;/p&gt; &lt;/bm-info-window&gt; &lt;/bm-marker&gt; &lt;/baidu-map&gt; &lt;!-- //显示数据--&gt; &lt;div slot=\"footer\" class=\"dialog-footer row\"&gt; &lt;ul class=\"list-group-flush col-10 row text-left\"&gt; &lt;li class=\"map-baidu-xinxi col-6 pr-1\"&gt; &lt;input type=\"text\" class=\"form-control col-10 border-0 \" placeholder=\"输入学校位置\" aria-label=\"Example text with button addon\" aria-describedby=\"button-addon1\" v-model=\"keyword\"&gt;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;经度：&#123;&#123;add.postionMap.lng&#125;&#125;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;维度：&#123;&#123;add.postionMap.lat&#125;&#125;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;&lt;b&gt;省：&lt;/b&gt;&#123;&#123;add.province&#125;&#125;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;&lt;b&gt;市：&lt;/b&gt;&#123;&#123;add.city&#125;&#125;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;&lt;b&gt;区：&lt;/b&gt;&#123;&#123;add.district&#125;&#125;&lt;/li&gt; &lt;li class=\"map-baidu-xinxi col-3 pr-1\"&gt;&lt;b&gt;街：&lt;/b&gt;&#123;&#123;add.street&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"col-2\"&gt; &lt;el-button class=\"col-10 ml-0 mb-1\" type=\"primary\" @click=\"centerDialogVisibleOK\"&gt;确 定&lt;/el-button&gt; &lt;el-button class=\"col-10 ml-0\" @click=\"centerDialogVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; //显示地图红点上的信息 show: false, //地图坐标 postionMap: &#123; lng: '', lat: '' &#125;, //搜索框关键词 - 重要 keyword: '', //位置 location: '', //放大比例 zoom: 12.8, //位置详细信息 address: '', // 返回父组件的东西 - add: &#123; //站点名称 - 可不要 - 换成学校名 siteName: '', //地址 site: '', //经纬度 postionMap: &#123; lng: '', lat: '' &#125;, //备注说明 desce: '', //类型 type: '', //省 province:'', //城市 city:'', //区县 district:'', //街道 street:'', &#125;, centerDialogVisible: false &#125; &#125;, methods: &#123; //点击选取地图 打开弹窗 centerDialogVisibleClick() &#123; this.centerDialogVisible = true &#125;,//点击确认之后关闭弹窗传出this.add centerDialogVisibleOK()&#123; this.add.address = this.keyword this.centerDialogVisible = false this.$emit('mapMessage',this.add) &#125;, //点击地图获取一些信息， getPoint(e) &#123; this.show = true this.postionMap.lng = e.point.lng //通过 e.point.lng获取经度 this.postionMap.lat = e.point.lat //通过 e.point.lat获取纬度 this.add.postionMap.lng = e.point.lng this.add.postionMap.lat = e.point.lat //创建地址解析器的实例 let geocoder = new BMap.Geocoder() geocoder.getLocation(e.point, rs =&gt; &#123; this.add.site = rs.address this.add.province = rs.addressComponents.province this.add.city = rs.addressComponents.city this.add.district = rs.addressComponents.district this.add.street = rs.addressComponents.street // 地址描述(string)= console.log(rs) //用什么可以在这里面找 console.log(rs.address) //这里打印可以看到里面的详细地址信息，可以根据需求选择想要的 // console.log(rs.point) //获取坐标 // console.log(rs.addressComponents)//结构化的地址描述(object) // console.log(rs.addressComponents.province) //省 // console.log(rs.addressComponents.city) //城市 // console.log(rs.addressComponents.district) //区县 // console.log(rs.addressComponents.street) //街道 // console.log(rs.addressComponents.streetNumber) //门牌号 // console.log(rs.surroundingPois) //附近的POI点(array) // console.log(rs.business) //商圈字段，代表此点所属的商圈(string) &#125;) &#125;, infoWindowClose() &#123; this.show = false &#125;, infoWindowOpen() &#123; //这里有个问题纠结了很久，百度的信息窗口默认有个点击其他地方就消失的事件，我没有找到 //并且信息窗口点击一次显示，一次消失 //于是我加了一个100毫秒的定时器，保证每次点击地图都可以展示信息窗口 setInterval(() =&gt; &#123; this.show = true &#125;, 100) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .map-baidu-xinxi&#123; display: block; border-bottom: 1px solid rgba(0,0,0,.125); line-height: 2.5; &#125; input:focus&#123; box-shadow: none &#125;&lt;/style&gt;","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/tags/Nuxt/"}]},{"title":"uniapp批量导入组件","slug":"uniapp/uniapp批量导入组件","date":"2020-05-19T15:38:17.000Z","updated":"2022-03-03T08:33:28.824Z","comments":true,"path":"2020/05/19/uniapp/uniapp批量导入组件/","link":"","permalink":"https://a-lyc.github.io/2020/05/19/uniapp/uniapp%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E7%BB%84%E4%BB%B6/","excerpt":"uni-app easycom 模式 组件 引入前言 （报错的问题 请往下看）easycom官网描述 查入图片","text":"uni-app easycom 模式 组件 引入前言 （报错的问题 请往下看）easycom官网描述 查入图片 含义：原本 vue 引入组件 需要多部操作，全局引入、单文件引入、在文件中注册等等等 非常麻烦。 uni-app 推出了easycom 引入组件模式 只需要在page.json 中配置自动扫描 或 自定义规则导入组件即可下面我会详细说下两种用法。 esaycom 自动导入：一般在组件目录下（components） 目录下按照他的规则 组件文件夹/组件名称.vue 就可以自动导入了 如下图所示 ↓↓↓ 。 查入图片 esaycom 手动编写规则导入：一般报错的位置都在这里 写了自动以规则但是无法使用 ，找不到组件 ，非常头疼。下面是一个示例 请看下方图片 ↓↓↓。 查入图片 这里官网写的示例 让这么引入在这里插入图片描述问题 如果我在多加一个文件夹呢？ 因为全部的组件都这么放的话，问题会很大。因为组件越来越多，严重影响代码质量，美化等等。 如果把组件的作用不同 单分文件夹的时候 这个 自定义规则应该怎么写呢？ 看下图所示↓↓↓↓。 查入图片 把组件单分到文件夹里面。在这里插入图片描述那么这个规则就应该这么写。 查入图片 1234567&quot;easycom&quot;: &#123; &quot;autoscan&quot;: true, &quot;custom&quot;: &#123; &quot;uni-(.*)&quot;: &quot;@&#x2F;components&#x2F;uni-$1.vue&quot;, &#x2F;&#x2F; 匹配components目录内的vue文件 &quot;vue-file-(.*)&quot;: &quot;packageName&#x2F;path&#x2F;to&#x2F;vue-file-$1.vue&quot; &#x2F;&#x2F; 匹配node_modules内的vue文件 &#125;&#125; 自定义easycom配置的示例如果需要匹配node_modules内的vue文件，需要使用packageName/path/to/vue-file-$1.vue形式的匹配规则，其中packageName为安装的包名，/path/to/vue-file-$1.vue为vue文件在包内的路径。 说明easycom方式引入的组件无需在页面内import，也不需要在components内声明，即可在任意页面使用easycom方式引入组件不是全局引入，而是局部引入。例如在H5端只有加载相应页面才会加载使用的组件在组件名完全一致的情况下，easycom引入的优先级低于手动引入（区分连字符形式与驼峰形式）考虑到编译速度，直接在pages.json内修改easycom不会触发重新编译，需要改动页面内容触发。easycom只处理vue组件，不处理小程序组件。暂不处理后缀为.nvue的组件，建议参考uni ui，使用vue后缀，同时兼容nvue页面。nvue页面里的.vue后缀的组件，同样支持easycomtabBar","categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/categories/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/tags/uniapp/"}]},{"title":"wxparse富文本插件","slug":"微信/wxparse富文本插件","date":"2020-05-18T12:41:46.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/05/18/微信/wxparse富文本插件/","link":"","permalink":"https://a-lyc.github.io/2020/05/18/%E5%BE%AE%E4%BF%A1/wxparse%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8F%92%E4%BB%B6/","excerpt":"优点：目前已知唯一可以转化HTML到小程序识别的插件 解决小程序富文本图片过大超出问题let dataAbout = res.data.data.about.replace(/&lt;img/gi, ‘&lt;img style=”width:100%;height:auto” ‘) 缺点：转换一个HTML标签可能需要大量的微信小程序标签还有样式","text":"优点：目前已知唯一可以转化HTML到小程序识别的插件 解决小程序富文本图片过大超出问题let dataAbout = res.data.data.about.replace(/&lt;img/gi, ‘&lt;img style=”width:100%;height:auto” ‘) 缺点：转换一个HTML标签可能需要大量的微信小程序标签还有样式 配置：第一步，下载https://github.com/icindy/wxParse 第二步，放入项目中，我选择pages目录下 第三步，配置 wxml加入： 1&lt;import src=\"../wxParse/wxParse.wxml\"/&gt; 在需要的地方使用： 1&lt;template is&#x3D;&quot;wxParse&quot; data&#x3D;&quot;&#123;&#123;wxParseData:article.nodes&#125;&#125;&quot;&#x2F;&gt; 其中article是后台html值的变量名js加入： 1234567891011121314151617181920var WxParse = require('../wxParse/wxParse.js');//或者import WxParse from '../wxParse/wxParse.js'Page(&#123; data: &#123; article:'&lt;div&gt;我是HTML代码&lt;/div&gt;&lt;h4&gt;&lt;i&gt;我是h1标签&lt;/i&gt;&lt;/h4&gt;' &#125;, //但是要注意的是a标签的转化，需要加入一个方法，示例如下 wxParseTagATap: function (e) &#123; var href = e.currentTarget.dataset.src; console.log(href); wx.redirectTo(&#123; url: href &#125;); &#125;, onLoad: function () &#123; WxParse.wxParse('article', 'html', this.data.article, this, 5); &#125;&#125;) 这里貌似使用es6的import会有错误我在onload事件写下了： 1WxParse.wxParse('article', 'html', this.data.article, this, 5); 注意的是第三个和第四个参数，前几个可以固定不变但是第一个要和数据变量名一致，第三个是后台数据，第四个是指的小程序标签，可以注册多个wxparsewxss加入： 1@import '../wxParse/wxParse.wxss'; 到此完成，但是要注意的是a标签的转化，需要加入一个方法，示例如下： 1234567wxParseTagATap: function (e) &#123;var href = e.currentTarget.dataset.src;console.log(href);wx.redirectTo(&#123;url: href&#125;);&#125; 这个在点击a标签的时候控制台其实是输出了警告信息的此外url也只能是小程序内部地址，这是个限制，他不能跳到外部，这里我想后台编辑的时候可以用二维码替代，小程序跳转外部地址可以使用web-view标签，详情参考官方文档","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"wxparse富文本插件","slug":"wxparse富文本插件","permalink":"https://a-lyc.github.io/tags/wxparse%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8F%92%E4%BB%B6/"}]},{"title":"微信小程序","slug":"微信/微信小程序-1","date":"2020-05-17T05:23:17.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/05/17/微信/微信小程序-1/","link":"","permalink":"https://a-lyc.github.io/2020/05/17/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-1/","excerpt":"最近总结微信的常用的语法：点击阻止冒泡事件bilnd 会有冒泡事件catch 会阻止事件向上冒泡","text":"最近总结微信的常用的语法：点击阻止冒泡事件bilnd 会有冒泡事件catch 会阻止事件向上冒泡 12345678wx:for&#x3D;&quot;&#123;&#123;&#125;&#125;&quot;:wx:for-item：for循环键值对的方式，item点什么，如果不需要索引的话，可以直接使用wx:for&#x3D;&#39;&#123;&#123;data上的值&#125;&#125;&#39;wx:for-index：for循环索引值，获取这个元素在那一个索引的位置wx:if&#x3D;&quot;&#123;&#123;&#125;&#125;&quot;wx:if:可以是一个三元表达式，也可以是一个布尔值，wx:elif:如果上个条件不成立的话，直接走这个条件wx:if:同第一个 this.setData({})和this.datasetData可以写入改变data中某一个的值，data可以获取data中的值，应该是不能修改的，（当前理解） 自定义属性：data-重命名=”传递到js的参数” =&gt; 举例：data-hi=”WeChat”例子： 1&lt;view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\"&gt; Click me! &lt;/view&gt; 12345Page(&#123; tapName: function(event) &#123; console.log(event) &#125;&#125;) 控制台打印的值 12345678910111213141516171819202122232425262728293031323334&#123; \"type\":\"tap\", \"timeStamp\":895, \"target\": &#123; \"id\": \"tapTest\", \"dataset\": &#123; \"hi\":\"WeChat\" &#125; &#125;, \"currentTarget\": &#123;//重点在这 \"id\": \"tapTest\", \"dataset\": &#123; \"hi\":\"WeChat\" &#125; &#125;, \"detail\": &#123; \"x\":53, \"y\":14 &#125;, \"touches\":[&#123; \"identifier\":0, \"pageX\":53, \"pageY\":14, \"clientX\":53, \"clientY\":14 &#125;], \"changedTouches\":[&#123; \"identifier\":0, \"pageX\":53, \"pageY\":14, \"clientX\":53, \"clientY\":14 &#125;]&#125; input value=”“可实现数据的单项绑定，通过bindinput实现双向绑定，同data-XX用法取到用户输入的值 给下一个页面传输数据当前页面： 12345678910111213141516 wx.navigateTo(&#123; url: '../list/list?id=1&amp;d=2',//拼接传输 events: &#123; // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function (data) &#123; console.log(data) &#125;, someEvent: function (data) &#123; console.log(data) &#125;&#125;, success: function (res) &#123; // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit('acceptDataFromOpenerPage', &#123; data: 'test' &#125;) &#125; &#125;) 点击之后打开的页面 1234567891011121314onLoad: function(option) &#123;//在onload的时候接收 console.log(option)//接收拼接的数据 const eventChannel = this.getOpenerEventChannel() eventChannel.emit('acceptDataFromOpenedPage', &#123; data: 'test' &#125;); eventChannel.emit('someEvent', &#123; data: 'test' &#125;); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on('acceptDataFromOpenerPage', function(data) &#123; console.log(data) &#125;)&#125;, 动态修改class和style 12class&#x3D;&quot;page &#123;&#123;typeIndex &#x3D;&#x3D;&#x3D; index ? &#39;active&#39; : &#39;&#39;&#125;&#125;&quot; 如果是true的话添加active，如果是flase的话，不添加。通常用于点击事件等style同理 hidden：根据官网解释是是否显示这个组件，默认是显示的 布尔值 模板语法：创建模板四个文件（js,json,wxml,wxss）可以缺少json，js，wxss，模板wxml上书写模板页面 1234&lt;template name=\"add\"&gt; 我是一个模板 &#123;&#123;add&#125;&#125;&lt;/template&gt; name的值和is的值要对应，，之后data的值是传输到模板中的data，所以说最好模板内的也是和传来的这个值是相对应的，传输对象可用…,多个值应该使用逗号隔开 1234&lt;!-- 首先顶部引用 --&gt;&lt;import src=\"../../template/add.wxml\" /&gt;&lt;!-- 使用模板 --&gt;&lt;template is=\"add\" data=\"&#123;&#123;add&#125;&#125;\"&gt;&lt;/template&gt; 父子组件传递，父传子，通过事件的方式进行传递在子组件中注册点击事件或者其他事件，之后使用this.triggerEvent(“定义的时间名”,发出信息)父组件接收事件使用binld定义的时间名=”事件”比如：子组件发出this.triggerEvent(‘add’, old)父组件接收bilndadd=”add”进行接收处理 混入：类似于vue中的mixin 12var myBehavior &#x3D; require(&#39;my-behavior&#39;)&#x2F;&#x2F;js引入behaviors: [myBehavior]&#x2F;&#x2F;调用","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"微信小程序基础","slug":"微信小程序基础","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}]},{"title":"微信小程序的异步请求-promise封装-async","slug":"微信/微信小程序的异步请求-promise封装-async","date":"2020-05-16T14:23:04.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/05/16/微信/微信小程序的异步请求-promise封装-async/","link":"","permalink":"https://a-lyc.github.io/2020/05/16/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82-promise%E5%B0%81%E8%A3%85-async/","excerpt":"小程序原生发送异步请求: wx.request12345678910// 原生发送异步请求wx.request(&#123; url: '', // 请求的路径 method: \"\", // 请求的方式 data: &#123;&#125;, // 请求的数据 header: &#123;&#125;, // 请求头 success: (res) =&gt; &#123; // res 响应的数据 &#125;&#125;)","text":"小程序原生发送异步请求: wx.request12345678910// 原生发送异步请求wx.request(&#123; url: '', // 请求的路径 method: \"\", // 请求的方式 data: &#123;&#125;, // 请求的数据 header: &#123;&#125;, // 请求头 success: (res) =&gt; &#123; // res 响应的数据 &#125;&#125;) 用 promise 封装 wx.request 1 回顾promise:12345678910111213141516// 1.创建对象const p = new Promise( (resolve,reject) =&gt; &#123; // 逻辑代码 if()&#123; resolve(data) &#125;else&#123; reject(err) &#125;&#125;)// 2.调用方法p.then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 2.2 进行封装 123456789101112131415161718192021222324252627282930313233------------------- 第一, 在utils下新建一个js文件,进行封装 ----------------------- // promise 特点：一创建就立即执行，一般情况下解决这个问题我们会将其封装为一个函数// options:请求时的参数对象function myrequest(options) &#123; return new Promise((resolve, reject) =&gt; &#123; // 逻辑：发送请求到服务器 wx.request(&#123; url: options.url, method: options.method || \"GET\", data: options.data || &#123;&#125;, header: options.header || &#123;&#125;, success: res =&gt; &#123; resolve(res); &#125;, fail: err =&gt; &#123; reject(err); &#125; &#125;); &#125;);&#125;// 暴露给外界export default myrequest;----------------------- 第二, 封装完成后 引入并使用 ----------------------import myrequest from '../../utils/api.js' myrequest(&#123; url: 'xxx', header: &#123; 'content-type': 'json' // 有些接口不需要设置 &#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;) 使用 async &amp; await 来改造 promise 1 概念​ 是 ES7 提出的新技术, 可以将 promise 对象中异步的方法以同步的方式进行书写, 减少代码量 3.2 用法​ async：用来修饰异步代码所在的函数 ​ await: 用来修改异步代码 ​ 结果：异步代码会返回一个结果, 即操作完成后的结果 1234567891011// 使用async和await来改造上面的promise封装代码async getList()&#123; // 用res来接收这个返回值 const res = await myrequest(&#123; url: 'xxx', header: &#123;'content-type': 'json'&#125; // 有些接口不需要设置 &#125;) // 直接对res进行操作 console.log(res)&#125; 3.3 特点​ 异步代码虽然是以同步的方式进行书写，但是依旧是异步执行的 ​ await 修饰的对象一定要返回一个 promise 对象 版权声明：本文为CSDN博主「陈静洁」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/EnidChann/java/article/details/100182948","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"微信小程序的异步请求-promise封装-async","slug":"微信小程序的异步请求-promise封装-async","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82-promise%E5%B0%81%E8%A3%85-async/"}]},{"title":"微信使用Vant-weapp","slug":"微信/微信使用Vant-weapp","date":"2020-05-15T13:18:25.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/05/15/微信/微信使用Vant-weapp/","link":"","permalink":"https://a-lyc.github.io/2020/05/15/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E4%BD%BF%E7%94%A8Vant-weapp/","excerpt":"微信小程序引入Vant组件库Vant Weapp组件库：https://youzan.github.io/vant-weapp/#/intro","text":"微信小程序引入Vant组件库Vant Weapp组件库：https://youzan.github.io/vant-weapp/#/intro 说说我在引入vant组件库的时候的操作方法吧： 1.先在微信开发者工具中打开项目的终端： 2.然后初始化一个package.json文件：输入命令：npm init =&gt; 一定是npm init 然后一路回车 项目就回产生一个package.json文件： 3.接着在vant组件库的官网上找到安装语句：npm i vant-weapp -S –production，在终端输入安装命令，点击回车： 官网安装：https://youzan.github.io/vant-weapp/#/quickstart 4.构建npm：在微信开发者工具的菜单栏中找到工具栏的选项“构建npm”，等待构建完成 查入图片 其中miniprogram_npm下就是vant-weapp组件库； 5.最后，在微信开发者工具的详情里面将“使用npm模块”勾选上，如下 查入图片 6.引用和使用vant组件：（关于如何引用和使用组件可以参考官方文档噢，很齐全） 以引用button按钮为例，官网文档中都写的特别详细了： 查入图片 查入图片","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"Vant-weapp","slug":"Vant-weapp","permalink":"https://a-lyc.github.io/tags/Vant-weapp/"}]},{"title":"自定义的指令","slug":"vue/自定义的指","date":"2020-05-02T06:23:11.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/05/02/vue/自定义的指/","link":"","permalink":"https://a-lyc.github.io/2020/05/02/vue/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8C%87/","excerpt":"主要参数可以参照官网所说的https://cn.vuejs.org/v2/guide/custom-directive.html Vue.directive(‘指令名’,{参数})创建自定义指令参数三个：","text":"主要参数可以参照官网所说的https://cn.vuejs.org/v2/guide/custom-directive.html Vue.directive(‘指令名’,{参数})创建自定义指令参数三个： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。 el：DOMbinding：一个对象，包含propertyvnode：虚拟节点oldVBnode：上一个虚拟节点 123456789101112Vue.directive('auth', &#123;//创建一个自定义指令auth inserted(el, binding, vnode, oldVBnode)&#123;//接收参数 let user = window.sessionStorage.getItem('user') user = user ? JSON.parse(user) : &#123;&#125; let rules = user.ruleNames ? user.ruleNames : [] let v = rules.find(item =&gt; item === binding.value) if(!v)&#123; el.parentNode.removeChild(el) &#125; &#125;&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 自定义指令-待完善","slug":"vue-自定义指令-待完善","permalink":"https://a-lyc.github.io/tags/vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/"}]},{"title":"vue-axios实现登陆注册","slug":"vue/vue-axios实现登陆注册","date":"2020-05-01T07:15:29.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/05/01/vue/vue-axios实现登陆注册/","link":"","permalink":"https://a-lyc.github.io/2020/05/01/vue/vue-axios%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C/","excerpt":"vue的实现等登录注册，使用vuex来管理登录状态，登录的时候就是接收axios成功把用户名等信息保存起来，之后保存到浏览器的方法内（因为刷新的时候要保证登陆状态是存在的，关闭浏览器的时候登陆状态是没有的，退出登录的是时候登录状态没有，） 首先通过axios请求来的数据保存到vuex中去，在mutations中定义几个方法，：","text":"vue的实现等登录注册，使用vuex来管理登录状态，登录的时候就是接收axios成功把用户名等信息保存起来，之后保存到浏览器的方法内（因为刷新的时候要保证登陆状态是存在的，关闭浏览器的时候登陆状态是没有的，退出登录的是时候登录状态没有，） 首先通过axios请求来的数据保存到vuex中去，在mutations中定义几个方法，： 1234567891011121314151617181920212223242526//初始化用户信息 initUser(state)&#123; let user = window.sessionStorage.getItem('user') if(user)&#123; state.user = JSON.parse(user) state.token = state.user.token &#125; console.log('初始化调用成功') &#125;, //登录 login(state,user)&#123; //保存登录的状态 state.user = user; state.token = user.token //存储到本地当中 window.sessionStorage.setItem('user', JSON.stringify(state.user)) window.sessionStorage.setItem('token', JSON.stringify(state.token)) &#125;, //退出登录 logout(state)&#123; //清除状态 state.user = &#123;&#125; state.token = '' //清除本地存储 window.sessionStorage.clear() &#125; 浏览器的sessionStorage方法刷新之后不会被清理（暂时理解）：window.sessionStorage.getItem =&gt; 读取，获取window.sessionStorage.setItem =&gt; 写入window.sessionStorage.clear =&gt; 清除 登录使用： 1234567891011121314151617181920212223submit() &#123; this.$refs.ruleForm.validate(e =&gt; &#123;//框架表单验证 if (!e) return; // 提交表单 this.axios .post(\"url\", this.form)//post请求传入的用户名和信息给后端验证之后返回数据 .then(res =&gt; &#123; //请求成功打印的数据 console.log(res); //存储到本地 //成功之后存储vuex中方法为login this.$store.commit(\"login\", res.data.data); //成功提示 this.$message(\"登陆成功\"); //跳转到后台 this.$router.push(&#123;name:'index'&#125;) &#125;) .catch(err =&gt; &#123; if (err.response.data &amp;&amp; err.response.data.errorCode) &#123; this.$message.error(err.response.data.msg); &#125; &#125;); &#125;); &#125; 退出使用vuex 12345678910111213141516171819202122232425262728logout() &#123; this.axios .post( \"/admin/logout\", &#123;&#125;, &#123; headers: &#123; token: this.user.token &#125; &#125; ) .then(res =&gt; &#123; //退出登陆状态和储存 this.$store.commit(\"logout\"); //返回登录页 this.$router.push(&#123; name: \"login\" &#125;); console.log(res); &#125;) .catch(err =&gt; &#123; if (err.response.data &amp;&amp; err.response.data.errorCode) &#123; this.$message.error(err.response.data.msg); //退出登陆状态和储存 this.$store.commit(\"logout\"); //返回登录页 this.$router.push(&#123; name: \"login\" &#125;); &#125; &#125;); &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 登录注册","slug":"vue-登录注册","permalink":"https://a-lyc.github.io/tags/vue-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"}]},{"title":"router内的query和params","slug":"vue/router内的query和params","date":"2020-04-30T02:38:30.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/04/30/vue/router内的query和params/","link":"","permalink":"https://a-lyc.github.io/2020/04/30/vue/router%E5%86%85%E7%9A%84query%E5%92%8Cparams/","excerpt":"this.$route.query和this.$route.params的使用：this.$route.query根据path来找查在url上有显示的，params根据name来找查在url上没有显示","text":"this.$route.query和this.$route.params的使用：this.$route.query根据path来找查在url上有显示的，params根据name来找查在url上没有显示 一、this.$route.query的使用,1、router/index.js 1234567891011&#123;path:&#39;&#x2F;mtindex&#39;,component: mtindex,&#x2F;&#x2F;添加路由 children:[ &#123; path:&#39;:shopid&#39;, component:guessdetail &#125; ]&#125;, 2、传参数 1234this.$router.push(&#123; path: &#39;&#x2F;mtindex&#x2F;detail&#39;, query:&#123;shopid: item.id&#125; &#125;); 3、获取参数 1this.$route.query.shopid 4、url的表现形式(url中带有参数) 1http:&#x2F;&#x2F;localhost:8080&#x2F;#&#x2F;mtindex&#x2F;detail?shopid&#x3D;1 二、this.$route.params1、router/index.js 123456789101112&#123; path:&#39;&#x2F;mtindex&#39;, component: mtindex, &#x2F;&#x2F;添加路由 children:[ &#123; path:&quot;&#x2F;detail&quot;, name:&#39;detail&#39;, component:guessdetail &#125; ] &#125;, 2、传参数（ params相对应的是name query相对应的是path） 1234this.$router.push(&#123; name: &#39;detail&#39;, params:&#123;shopid: item.id&#125; &#125;); 3、获取参数 1this.$route.params.shopid 4、url的表现形式(url中没带参数) 1http:&#x2F;&#x2F;localhost:8080&#x2F;#&#x2F;mtindex 原文链接：https://www.jianshu.com/p/5deb7e90af76","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"路由","slug":"路由","permalink":"https://a-lyc.github.io/tags/%E8%B7%AF%E7%94%B1/"}]},{"title":"vue实现批量删除使用的数组方法","slug":"vue/vue实现批量删除使用的数组方法","date":"2020-04-28T10:01:51.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/28/vue/vue实现批量删除使用的数组方法/","link":"","permalink":"https://a-lyc.github.io/2020/04/28/vue/vue%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","excerpt":"定义一个方法，之后取到全部的数组，循环遍历使用forEch方法找到有没有符合条件的，（没有返回-1），之后使用findIndedx方法遍历和原数组进行对比，有的话返回一个原数组的索引值，这个索引值有的话forEach这个的值不会返回-1，之后判断，有这个索引进行删除，没有跳过","text":"定义一个方法，之后取到全部的数组，循环遍历使用forEch方法找到有没有符合条件的，（没有返回-1），之后使用findIndedx方法遍历和原数组进行对比，有的话返回一个原数组的索引值，这个索引值有的话forEach这个的值不会返回-1，之后判断，有这个索引进行删除，没有跳过 123456789101112deleteAll()&#123; let arr = this.multipleSelection.forEach(res =&gt; &#123; let index = this.tableData.findIndex(item =&gt; &#123; item.id === res.id &#125;)//返回数组的索引值 if(index !== -1)&#123; this.tableData.splice(index,1) &#125; &#125;) this.multipleSelection = [] //情况循环中的数组 console.log(arr)&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 批量删除","slug":"vue-批量删除","permalink":"https://a-lyc.github.io/tags/vue-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4/"}]},{"title":"tinymce富文本编辑器","slug":"插件/tinymce富文本编辑器","date":"2020-04-25T03:00:59.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/25/插件/tinymce富文本编辑器/","link":"","permalink":"https://a-lyc.github.io/2020/04/25/%E6%8F%92%E4%BB%B6/tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"富文本编辑器的使用方法，官网参考：https://www.tiny.cloud/，在vue中使用，参考如下","text":"富文本编辑器的使用方法，官网参考：https://www.tiny.cloud/，在vue中使用，参考如下 安装tinymce npm install tinymce -S 安装tinymce-vue npm install @tinymce/tinymce-vue -S 下载中文语言包tinymce提供了很多的语言包，这里我们下载中文语言包地址：https://www.tiny.cloud/get-tiny/language-packages/ 下载完后放到静态文件public目录下1、在public目录下新建tinymce，将上面下载的语言包解压到该目录2、在node_modules里面找到tinymce,将skins目录复制到public/tinymce里面 image tinymce使用封装成组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;template&gt; &lt;div class&#x3D;&quot;tinymce-box&quot;&gt; &lt;editor v-model&#x3D;&quot;myValue&quot; :init&#x3D;&quot;init&quot; :disabled&#x3D;&quot;disabled&quot; @onClick&#x3D;&quot;onClick&quot;&gt; &lt;&#x2F;editor&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import tinymce from &#39;tinymce&#x2F;tinymce&#39; &#x2F;&#x2F;tinymce默认hidden，不引入不显示import Editor from &#39;@tinymce&#x2F;tinymce-vue&#39;import &#39;tinymce&#x2F;themes&#x2F;silver&#39;&#x2F;&#x2F; 编辑器插件plugins&#x2F;&#x2F; 更多插件参考：https:&#x2F;&#x2F;www.tiny.cloud&#x2F;docs&#x2F;plugins&#x2F;import &#39;tinymce&#x2F;plugins&#x2F;image&#39;&#x2F;&#x2F; 插入上传图片插件import &#39;tinymce&#x2F;plugins&#x2F;media&#39;&#x2F;&#x2F; 插入视频插件import &#39;tinymce&#x2F;plugins&#x2F;table&#39;&#x2F;&#x2F; 插入表格插件import &#39;tinymce&#x2F;plugins&#x2F;lists&#39;&#x2F;&#x2F; 列表插件import &#39;tinymce&#x2F;plugins&#x2F;wordcount&#39;&#x2F;&#x2F; 字数统计插件export default &#123; components:&#123; Editor &#125;, name:&#39;tinymce&#39;, props: &#123; value: &#123; type: String, default: &#39;&#39; &#125;, disabled: &#123; type: Boolean, default: false &#125;, plugins: &#123; type: [String, Array], default: &#39;lists image media table wordcount&#39; &#125;, toolbar: &#123; type: [String, Array], default: &#39;undo redo | formatselect | bold italic forecolor backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | lists image media table | removeformat&#39; &#125; &#125;, data()&#123; return&#123; init: &#123; language_url: &#39;&#x2F;tinymce&#x2F;langs&#x2F;zh_CN.js&#39;, language: &#39;zh_CN&#39;, skin_url: &#39;&#x2F;tinymce&#x2F;skins&#x2F;ui&#x2F;oxide&#39;, &#x2F;&#x2F; skin_url: &#39;tinymce&#x2F;skins&#x2F;ui&#x2F;oxide-dark&#39;,&#x2F;&#x2F;暗色系 height: 300, plugins: this.plugins, toolbar: this.toolbar, branding: false, menubar: false, &#x2F;&#x2F; 此处为图片上传处理函数，这个直接用了base64的图片形式上传图片， &#x2F;&#x2F; 如需ajax上传可参考https:&#x2F;&#x2F;www.tiny.cloud&#x2F;docs&#x2F;configure&#x2F;file-image-upload&#x2F;#images_upload_handler images_upload_handler: (blobInfo, success, failure) &#x3D;&gt; &#123; const img &#x3D; &#39;data:image&#x2F;jpeg;base64,&#39; + blobInfo.base64() success(img) &#125; &#125;, myValue: this.value &#125; &#125;, mounted () &#123; tinymce.init(&#123;&#125;) &#125;, methods: &#123; &#x2F;&#x2F; 添加相关的事件，可用的事件参照文档&#x3D;&gt; https:&#x2F;&#x2F;github.com&#x2F;tinymce&#x2F;tinymce-vue &#x3D;&gt; All available events &#x2F;&#x2F; 需要什么事件可以自己增加 onClick (e) &#123; this.$emit(&#39;onClick&#39;, e, tinymce) &#125;, &#x2F;&#x2F; 可以添加一些自己的自定义事件，如清空内容 clear () &#123; this.myValue &#x3D; &#39;&#39; &#125; &#125;, watch: &#123; value (newValue) &#123; this.myValue &#x3D; newValue &#125;, myValue (newValue) &#123; this.$emit(&#39;input&#39;, newValue) &#125; &#125;&#125; &lt;&#x2F;script&gt;&lt;style scoped&gt; &lt;&#x2F;style&gt; 组件引用1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class&#x3D;&quot;home&quot;&gt; &lt;tinymce ref&#x3D;&quot;editor&quot; v-model&#x3D;&quot;msg&quot; :disabled&#x3D;&quot;disabled&quot; @onClick&#x3D;&quot;onClick&quot; &#x2F;&gt; &lt;button @click&#x3D;&quot;clear&quot;&gt;清空内容&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;disabled &#x3D; true&quot;&gt;禁用&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F;引用上面新建的组件import tinymce from &#39;@&#x2F;components&#x2F;tinymce.vue&#39;export default &#123; name: &#39;home&#39;, components: &#123; tinymce &#125;, data()&#123; return&#123; msg: &#39;Welcome to Use Tinymce Editor&#39;, disabled: false &#125; &#125;, methods: &#123; &#x2F;&#x2F; 鼠标单击的事件 onClick (e, editor) &#123; console.log(&#39;Element clicked&#39;) console.log(e) console.log(editor) &#125;, &#x2F;&#x2F; 清空内容 clear () &#123; this.$refs.editor.clear() &#125; &#125;&#125;&lt;&#x2F;script&gt;","categories":[{"name":"资源,插件","slug":"资源-插件","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90-%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://a-lyc.github.io/tags/%E8%B5%84%E6%BA%90/"},{"name":"tinymce富文本编辑器","slug":"tinymce富文本编辑器","permalink":"https://a-lyc.github.io/tags/tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"插件","slug":"插件","permalink":"https://a-lyc.github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"vue的依赖注入provide，inject","slug":"vue/vue的依赖注入","date":"2020-04-24T12:02:39.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/24/vue/vue的依赖注入/","link":"","permalink":"https://a-lyc.github.io/2020/04/24/vue/vue%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"vue中使用很频繁的组件可以使用依赖注入的形式去编写，就是在一个公共文件，或者根组件app.vue中定义一个样式，之后使用provide(){return {}}的方法进行导出，之后在子组件中使用inject:[“”]进行导入，下面是举例子说明","text":"vue中使用很频繁的组件可以使用依赖注入的形式去编写，就是在一个公共文件，或者根组件app.vue中定义一个样式，之后使用provide(){return {}}的方法进行导出，之后在子组件中使用inject:[“”]进行导入，下面是举例子说明 App.vue 12345678910111213141516171819202122232425262728&lt;script&gt;export default &#123; name: &quot;app&quot;, &#x2F;&#x2F;依赖注入&#x2F;&#x2F;依赖注入，给全局注册一个依赖 provide()&#123; return &#123; app:this,&#x2F;&#x2F;当前的额this就是app全局可调用app.show即可调用show的方法 &#125; &#125;, data () &#123; return &#123; imageModel: false &#125; &#125;, components: &#123;&#125;, methods: &#123; show()&#123; this.imageModel &#x3D; true &#125;, confirm()&#123; this.imageModel &#x3D; false &#125;, hide()&#123; this.imageModel &#x3D; false &#125; &#125;,&#125;;&lt;&#x2F;script&gt; 子组件：使用注入的依赖 123456789export default &#123;inject:[&#39;app&#39;],methods:&#123; isShow()&#123; console,log(this.app.show)&#x2F;&#x2F;这个值是上面App.vue中定义的一个函数 console,log(this.app.imageModel)&#x2F;&#x2F; false 因为上文中data中定义的是一个false &#125;&#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"全局依赖注入","slug":"全局依赖注入","permalink":"https://a-lyc.github.io/tags/%E5%85%A8%E5%B1%80%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"}]},{"title":"watch的理解","slug":"vue/watch的理解","date":"2020-04-23T01:57:31.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/23/vue/watch的理解/","link":"","permalink":"https://a-lyc.github.io/2020/04/23/vue/watch%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"watch在vue的文档中是这样解释的。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。","text":"watch在vue的文档中是这样解释的。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 值是包括选项的对象：选项包括有三个。第一个handler：其值是一个回调函数。即监听到变化时应该执行的函数。（内可以监听watch的变化如下：）第二个是deep：其值是true或false；确认是否深入监听。（一般监听时是不能监听到对象属性值的变化的，数组的值变化可以听到。）第三个是immediate：其值是true或false；确认是否以当前的初始值执行handler的函数（进入页面就开始 监听）。 $watch可以观察 Vue 实例变化的一个表达式或计算属性函数：1.监听属性的变化，两个参数，参数1：要监听的对象;参数2：监听的函数，函数中有两个参数，变化后的新值，变化之前的旧值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;meta name=\"description\" content=\"Site Logo Script- Click here for a DHTML script that creates a static logo image, positioned in the lower right corner of the browser.\" /&gt; &lt;meta name=\"keywords\" content=\"DHTML, Geocities watermark logo, logo script, static image, DHTML tutorial, free, JavaScript\" /&gt; &lt;title&gt;Dynamic Drive DHTML Scripts- Featured Image Zoomer&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &lt;p&gt;changeNum: &#123;&#123;changeNum&#125;&#125;&lt;/p&gt; &lt;p&gt;watchNum: &lt;input type=\"text\" v-model=\"watchNum\"&gt;&lt;/p&gt; 还可以这么写 &lt;input v-model=\"example1\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let app = new Vue(&#123; el: \"#app\", data: &#123; watchNum: '张三', otherNum: ' / ', changeNum: ' ', example1: ' ', &#125;, watch: &#123; watchNum: &#123; handler(newVal, oldVal) &#123; this.changeNum = this.watchNum + this.otherNum + newVal + '---' + oldVal; console.log(this.changeNum) //全部的值 张三 / 张三 ---undefined -- 输入（李四）改变的时候值：张三李四 / 张三李四 ---张三 console.log(this.watchNum) //张三 -- 改变的时候：张三李四 console.log(this.otherNum) // \"/\" 改变的收 / console.log(newVal) //张三 改变的时候：张三李四 console.log(oldVal) //undefined 改变的时候：张三 &#125;, immediate: true,//页面监听开始的时候就直接调用：见上文解释 deep: true,//见上文解释 &#125; &#125;, example1: \"exampleMethods\", methods: &#123; exampleMethods(newVal, oldVal) &#123; conosle.log(newVal, oldVal) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue watch","slug":"vue-watch","permalink":"https://a-lyc.github.io/tags/vue-watch/"}]},{"title":"vue中的slot-scope=scope","slug":"vue/vue中的slot-scope-scope","date":"2020-04-19T13:35:22.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/19/vue/vue中的slot-scope-scope/","link":"","permalink":"https://a-lyc.github.io/2020/04/19/vue/vue%E4%B8%AD%E7%9A%84slot-scope-scope/","excerpt":"在vue中使用插槽,有匿名插槽,具名插槽,还有一个具有数据的插槽,就是说可以读取插槽上传来的数据,和实例data上的数据不会冲突匿名插槽:,没有命名的外部直接使用,定义一个子组件可以直接向插槽内输入内容具名插槽:,具名插槽,外部需要使用","text":"在vue中使用插槽,有匿名插槽,具名插槽,还有一个具有数据的插槽,就是说可以读取插槽上传来的数据,和实例data上的数据不会冲突匿名插槽:,没有命名的外部直接使用,定义一个子组件可以直接向插槽内输入内容具名插槽:,具名插槽,外部需要使用 数据插槽:组件定义插槽 123456&lt;template&gt; &lt;div&gt; &lt;div&gt;下面是一个slot&lt;&#x2F;div&gt; &lt;slot a&#x3D;&quot;123&quot; b&#x3D;&quot;msg&quot; &gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 使用:slot-scope=”scope” 123456789&lt;div&gt; &lt;mysolt&gt; &lt;template slot-scope&#x3D;&quot;scope&quot;&gt; &lt;div&gt;&#123;&#123;scope&#125;&#125;&lt;&#x2F;div&gt;&#x2F;&#x2F; a&#x3D;&quot;123&quot; b&#x3D;&quot;456&quot; &lt;div&gt;&#123;&#123;scope.a&#125;&#125;&lt;&#x2F;div&gt;&#x2F;&#x2F; 123 &lt;div&gt;&#123;&#123;scope.b&#125;&#125;&lt;&#x2F;div&gt;&#x2F;&#x2F; 456 &lt;&#x2F;template&gt; &lt;&#x2F;mysolt&gt;&lt;&#x2F;div&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 插槽 slot","slug":"vue-插槽-slot","permalink":"https://a-lyc.github.io/tags/vue-%E6%8F%92%E6%A7%BD-slot/"}]},{"title":"vue过滤器语法","slug":"vue/vue过滤器语法","date":"2020-04-17T12:46:25.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/17/vue/vue过滤器语法/","link":"","permalink":"https://a-lyc.github.io/2020/04/17/vue/vue%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AD%E6%B3%95/","excerpt":"Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：","text":"Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： 12&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125; 12&lt;!-- 在 &#96;v-bind&#96; 中 --&gt;&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt; 你可以在一个组件的选项中定义本地的过滤器： 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &#39;&#39; value &#x3D; value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 或者在创建 Vue 实例之前全局定义过滤器： 123456789Vue.filter(&#39;capitalize&#39;, function (value) &#123; if (!value) return &#39;&#39; value &#x3D; value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; &#x2F;&#x2F; ...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 下面这个例子用到了 capitalize 过滤器： john 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数。 过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数： 1&#123;&#123; message | filterA(&#39;arg1&#39;, arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 过滤器","slug":"vue-过滤器","permalink":"https://a-lyc.github.io/tags/vue-%E8%BF%87%E6%BB%A4%E5%99%A8/"}]},{"title":"计算属性中的get和set以及watch的router，本地缓存问题","slug":"vue/计算属性中的get和set以及watch的router","date":"2020-04-16T12:38:15.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/16/vue/计算属性中的get和set以及watch的router/","link":"","permalink":"https://a-lyc.github.io/2020/04/16/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%AD%E7%9A%84get%E5%92%8Cset%E4%BB%A5%E5%8F%8Awatch%E7%9A%84router/","excerpt":"在vue中计算属性有两个值，一个是获取，一个是写入，大部分使用的都是计算属性中的获取功能，少部分使用写入这个功能，这个本人不太懂，知道有这个东西，它可以改变获取的值，不走data的逻辑，set可以间接修改get里面的值，页面直接修改get内的值是修改不了的","text":"在vue中计算属性有两个值，一个是获取，一个是写入，大部分使用的都是计算属性中的获取功能，少部分使用写入这个功能，这个本人不太懂，知道有这个东西，它可以改变获取的值，不走data的逻辑，set可以间接修改get里面的值，页面直接修改get内的值是修改不了的 1234567891011121314computed: &#123; slideMenusActive: &#123; get() &#123; return this.tabBars.list[this.tabBars.active].submenuActive || &quot;0&quot;; &#125;,&#x2F;&#x2F;获取 set(val) &#123; console.log(val) this.tabBars.list[this.tabBars.active].submenuActive &#x3D; val; &#125;&#x2F;&#x2F;写入 &#125;, slideMenus() &#123; return this.tabBars.list[this.tabBars.active].submenu || []; &#125; &#125; 在watch中使用router的时候需要 12345678910111213watch: &#123; &#x2F;&#x2F;获取$route的路由，to是当前from是最后 &#39;$route&#39;(to,from)&#123; &#x2F;&#x2F;下面方法是本地存储--刷新之后还是当前页面 localStorage.setItem(&#39;navActive&#39;,JSON.stringify(&#123;to:&#39;&#39;,from:&#39;&#39;&#125;) localStorage.setItem(&#39;navActive&#39;,JSON.stringify(&#123; top:this.tabBars.active, left:this.slideMenusActive &#125;)) console.log(to,from) this.getRouterBran() &#125; &#125; 上面有本地存储，就要有获取才对 1234567891011&#x2F;&#x2F;初始化__initNavBar()&#123; &#x2F;&#x2F;获取本地存储 自定义的值要一样navActive let r &#x3D; localStorage.getItem(&#39;navActive&#39;) if(r)&#123; r &#x3D; JSON.parse(r) this.tabBars.active &#x3D; r.top this.slideMenusActive &#x3D; r.left &#125; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue get和set以及watch的router 本地缓存问题","slug":"vue-get和set以及watch的router-本地缓存问题","permalink":"https://a-lyc.github.io/tags/vue-get%E5%92%8Cset%E4%BB%A5%E5%8F%8Awatch%E7%9A%84router-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"}]},{"title":"微信小程序授权登录","slug":"微信/微信小程序授权登录","date":"2020-04-12T04:12:59.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/12/微信/微信小程序授权登录/","link":"","permalink":"https://a-lyc.github.io/2020/04/12/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95/","excerpt":"页面中使用点击登录，bottom点击的时候授权登录open-type=”getUserInfo” 1&lt;button open-type&#x3D;&quot;getUserInfo&quot; bindgetuserinfo&#x3D;&quot;onGetUserInfo&quot;&gt;&lt;&#x2F;button&gt;","text":"页面中使用点击登录，bottom点击的时候授权登录open-type=”getUserInfo” 1&lt;button open-type&#x3D;&quot;getUserInfo&quot; bindgetuserinfo&#x3D;&quot;onGetUserInfo&quot;&gt;&lt;&#x2F;button&gt; 在页面加载的时候可以onload的时候可以调用微信小程序 12345678910111213141516171819202122&#x2F;&#x2F; 获取用户信息 wx.getSetting(&#123; success: res &#x3D;&gt; &#123; &#x2F;&#x2F;res.authSetting[&#39;scope.userInfo&#39;]这个值是一个true不然不走授权逻辑 if (res.authSetting[&#39;scope.userInfo&#39;]) &#123; &#x2F;&#x2F; 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 wx.getUserInfo(&#123; success: res &#x3D;&gt; &#123; this.setData(&#123; avatarUrl: res.userInfo.avatarUrl, userInfo: res.userInfo, &#125;) &#x2F;&#x2F;其他参数打印可见 console.log(res) &#125;, &#125;) &#125; &#125;, fail:() &#x3D;&gt;&#123; console.log(&quot;授权失败&quot;) &#125; &#125;) 和onload同级别-上面就可以完成登录授权 12345678910onGetUserInfo: function(e) &#123; if (!this.data.logged &amp;&amp; e.detail.userInfo) &#123; this.setData(&#123; logged: true, avatarUrl: e.detail.userInfo.avatarUrl, userInfo: e.detail.userInfo &#125;) &#125; console.log(e)&#125;,","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"微信小程序授权登录","slug":"微信小程序授权登录","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95/"}]},{"title":"uniapp数据请求封装应用","slug":"uniapp/uniapp数据请求封装应用","date":"2020-04-11T13:45:03.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/04/11/uniapp/uniapp数据请求封装应用/","link":"","permalink":"https://a-lyc.github.io/2020/04/11/uniapp/uniapp%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E5%BA%94%E7%94%A8/","excerpt":"uniapp数据请求封装，存到公共文件夹内，之后引入,内有介绍，挺详细的","text":"uniapp数据请求封装，存到公共文件夹内，之后引入,内有介绍，挺详细的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export default &#123; &#x2F;&#x2F; 全局配置 common:&#123; &#x2F;&#x2F;请求网址 baseUrl:&quot;http:&#x2F;&#x2F;www.wangzhi.cn&#x2F;api&quot;, &#x2F;&#x2F;header头 header:&#123; &#39;Content-Type&#39;:&#39;application&#x2F;json;charset&#x3D;UTF-8&#39;, &#39;Content-Type&#39;:&#39;application&#x2F;x-www-form-urlencoded&#39; &#125;, &#x2F;&#x2F;数据 data:&#123;&#125;, &#x2F;&#x2F;请求方式 method:&#39;GET&#39;, &#x2F;&#x2F;请求格式 dataType:&#39;json&#39; &#125;, &#x2F;&#x2F; 请求 返回promise request(options &#x3D; &#123;&#125;)&#123; &#x2F;&#x2F; 组织参数 options.url &#x3D; this.common.baseUrl + options.url options.header &#x3D; options.header || this.common.header options.data &#x3D; options.data || this.common.data options.method &#x3D; options.method || this.common.method options.dataType &#x3D; options.dataType || this.common.dataType &#x2F;&#x2F; 请求 return new Promise((res,rej)&#x3D;&gt;&#123; &#x2F;&#x2F; 请求之前... todo &#x2F;&#x2F; 请求中... uni.request(&#123; ...options, success: (result) &#x3D;&gt; &#123; &#x2F;&#x2F; 服务端失败 if(result.statusCode !&#x3D;&#x3D; 200)&#123; uni.showToast(&#123; title: result.data.msg || &#39;服务端失败&#39;, icon: &#39;none&#39; &#125;); return rej() &#125; &#x2F;&#x2F; 请求成功 let data &#x3D; result.data.data res(data) &#125;, &#x2F;&#x2F; 请求失败 fail: (error) &#x3D;&gt; &#123; uni.showToast(&#123; title: error.errMsg || &#39;请求失败&#39;, icon: &#39;none&#39; &#125;); return rej() &#125; &#125;); &#125;) &#125;, &#x2F;&#x2F; get请求 get(url,data &#x3D; &#123;&#125;,options &#x3D; &#123;&#125;)&#123; options.url &#x3D; url options.data &#x3D; data options.method &#x3D; &#39;GET&#39; return this.request(options) &#125;, &#x2F;&#x2F; post请求 post(url,data &#x3D; &#123;&#125;,options &#x3D; &#123;&#125;)&#123; options.url &#x3D; url options.data &#x3D; data options.method &#x3D; &#39;POST&#39; return this.request(options) &#125;&#125; get请求，不传递参数 123456&#x2F;&#x2F;定义的变量和url$H.get(&#39;&#x2F;index_category&#x2F;data&#39;).then((res) &#x3D;&gt;&#123; console.log(&quot;请求成功&quot;) &#125;).catch(() &#x3D;&gt;&#123; console.log(&#39;请求失败&#39;) &#125;) 使用1:请求的时候传递参数过去post和get 1234let R &#x3D; await $H.get(&#39;&#x2F;index_category&#x2F;data&#39;,&#123;name:this.name,age:this.age&#125;)&#x2F;&#x2F;给&#x2F;index_category&#x2F;data传输参数，post请求传输的是name，age，传过去的参数返回是一个Promise可以使用.then接收this.$H.post(&#39;&#x2F;index_category&#x2F;data&#39;,&#123;name:this.name,age:this.age&#125;).then(res &#x3D;&gt; &#123;&#125;) 使用2:需要引入之后自定义一个名称， 12345678$H.request(&#123; &#x2F;&#x2F; 网址后面拼接的地址可拼接 url:&#39;&#x2F;index_category&#x2F;data&#39; + this.id + &#39;&#x2F;data&#x2F;&#39; + this.iid, &#125;).then((res) &#x3D;&gt;&#123; console.log(&quot;请求成功&quot;) &#125;).catch(() &#x3D;&gt;&#123; console.log(&#39;请求失败&#39;) &#125;)","categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/categories/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/tags/uniapp/"}]},{"title":"vue axios的get请求接收，传递","slug":"vue/vue的get请求接收，传递","date":"2020-04-11T12:11:28.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/11/vue/vue的get请求接收，传递/","link":"","permalink":"https://a-lyc.github.io/2020/04/11/vue/vue%E7%9A%84get%E8%AF%B7%E6%B1%82%E6%8E%A5%E6%94%B6%EF%BC%8C%E4%BC%A0%E9%80%92/","excerpt":"上次文章有封装好的axios 使用vue封装好的网络请求，可以通过引入的方式进行网络请求，就是引用：","text":"上次文章有封装好的axios 使用vue封装好的网络请求，可以通过引入的方式进行网络请求，就是引用： 1import &#123; getDetail, Goods, DetailActive, DetailInfo &#125; from &quot;@&#x2F;network&#x2F;detail&quot;; 在methods里面处理好之后，在页面加载完成发出网络请求，如何接收网络请求，上次封装有的使用promise.then(()=&gt;{}).catch(()=&gt;{})的方式。之后使用this保存值 如何返回值传入的时候有变动的参数进行拼接，使用params：{type，page….}等进行拼接 12345678export function getDetail(iid)&#123; return request(&#123; url: &#39;&#x2F;detail&#39;, params:&#123; iid &#125; &#125;)&#125; GET：在methods里面处理的时候可以：异步函数（参数1，参数2）进行传输参数 1234567getHomeGoods(type) &#123; let page &#x3D; 1 getHomeGoods(type, page).then(res &#x3D;&gt; &#123; this.goods[type].list.push(...res.data.list); this.goods[type].page +&#x3D; 1; &#125;); &#125; 结合router使用，比如点击进入详情页，可以通过改变router的值改变你url 12345678910111213&#x2F;&#x2F;点击传入this.$router.push(&#39;&#x2F;detail&#x2F;&#39;+this.goodsItem.iid) &#x2F;&#x2F;router接收 path: &#39;&#x2F;detail&#x2F;:iid&#39;, name: &#39;Detail&#39;, component: Detail&#x2F;&#x2F;打开页面找到url上拼接的id this.iid &#x3D; this.$route.params.iid;&#x2F;&#x2F;发出网络请求，把iid传入，请求iid的数据getDetail(this.iid).then(res &#x3D;&gt; &#123;&#125;) 之后页面加载前取到url上的iid，获取方法：this.iid = this.$route.params.iid;（当前页面：route）之后使用把值代入函数的参数内传输给后端，（获取的时候要有一个params：{type，page….}）拼接的值，然后后端返回这个链接随对应的数据","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"axios基础使用","slug":"axios基础使用","permalink":"https://a-lyc.github.io/tags/axios%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"}]},{"title":"uniapp请求数据的方法","slug":"uniapp/uniapp请求数据的方法","date":"2020-04-11T11:08:26.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/04/11/uniapp/uniapp请求数据的方法/","link":"","permalink":"https://a-lyc.github.io/2020/04/11/uniapp/uniapp%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061__init()&#123;uni.request( &#123; &#x2F;&#x2F;第一种 url:&quot;http:&#x2F;&#x2F;ceshi3.dishait.cn&#x2F;api&#x2F;index_category&#x2F;data&quot;, method:&#39;GET&#39;, data:&#123;&#125;, success: (res) &#x3D;&gt; &#123; console.log(res) &#125;, fail: () &#x3D;&gt; &#123; console.log(&quot;请求失败&quot;) &#125;, complete: () &#x3D;&gt; &#123; console.log(&quot;请求完成&quot;) &#125; &#125; ) &#x2F;&#x2F;&#x2F;&#x2F;第二种prominse uni.request(&#123; url:&quot;http:&#x2F;&#x2F;ceshi3.dishait.cn&#x2F;api&#x2F;index_category&#x2F;data&quot;, method:&quot;GET&quot; &#125;).then(data &#x3D;&gt; &#123; let [reeor,result] &#x3D; data console.log(reeor)&#x2F;&#x2F;错误的时候 console.log(result)&#x2F;&#x2F;正确的时候 if(reeor)&#123; return console.log(&quot;错误&quot;) &#125; if(result.statusCode !&#x3D;&#x3D; 200)&#123; return console.log(&quot;请求错误&quot;) &#125; console.log(result.data) &#125;) &#x2F;&#x2F;第三种需要在函数最前面加async 是一个异步便同步的配合await这个使用 let [error,result] &#x3D; await uni.request(&#123; url:&quot;http:&#x2F;&#x2F;ceshi3.dishait.cn&#x2F;api&#x2F;index_category&#x2F;data&quot;, method:&quot;GET&quot; &#125;) if(error)&#123; return console.log(&quot;错误&quot;) &#125; if(result.statusCode !&#x3D;&#x3D; 200)&#123; return console.log(&quot;请求错误&quot;) &#125; let data &#x3D; result.data.data console.log(data) &#x2F;&#x2F;初始化tab this.tabBars &#x3D; data.category &#x2F;&#x2F;初始化页面 this.newsitems &#x3D; this.setNewsitems(data) &#125;","categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/categories/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/tags/uniapp/"}]},{"title":"微信发送数据请求","slug":"微信/微信发送数据请求","date":"2020-04-07T09:21:18.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/07/微信/微信发送数据请求/","link":"","permalink":"https://a-lyc.github.io/2020/04/07/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/","excerpt":"uniapp和微信的类似，发送请求方式","text":"uniapp和微信的类似，发送请求方式 微信 1234567891011121314151617181920212223242526272829303132333435 wx.request(&#123;&#x2F;&#x2F;传输的url url: app.globalData.requestUrl,&#x2F;&#x2F;轮播图 &#x2F;&#x2F;后端给的参数值action后端给的请求放发 data: &#123; action: &#39;taglib&#39;, dopost: &#39;focus&#39;, &#x2F;&#x2F;自己给后端传输的参数 data: &#39;123&#39;, &#125;, &#x2F;&#x2F;请求方式 method: &quot;post&quot;, &#x2F;&#x2F;post请求的三种方式之一 header: &#123; &#39;content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39; &#125;, &#x2F;&#x2F;成功的时候 success: function (data) &#123; &#x2F;&#x2F; console.log(data) that.setData(&#123; imgUrls: data.data.data, &#125;) &#125;, &#x2F;&#x2F;失败的时候 fail: function (data) &#123; console.log(data) &#125;, &#x2F;&#x2F;无论成功与失败 complete:() &#x3D;&gt;&#123; &#125;&#125;) uniapp 12345678910111213uni.request(&#123; url: &#39;https:&#x2F;&#x2F;www.example.com&#x2F;request&#39;, &#x2F;&#x2F;仅为示例，并非真实接口地址。 data: &#123; text: &#39;uni.request&#39; &#125;, header: &#123; &#39;custom-header&#39;: &#39;hello&#39; &#x2F;&#x2F;自定义请求头信息 &#125;, success: (res) &#x3D;&gt; &#123; console.log(res.data); this.text &#x3D; &#39;request success&#39;; &#125;&#125;);","categories":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"微信发送数据请求","slug":"微信发送数据请求","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"}]},{"title":"vue-router官方说明","slug":"vue/vue-router官方说明","date":"2020-04-07T02:09:15.000Z","updated":"2022-03-03T08:33:28.840Z","comments":true,"path":"2020/04/07/vue/vue-router官方说明/","link":"","permalink":"https://a-lyc.github.io/2020/04/07/vue/vue-router%E5%AE%98%E6%96%B9%E8%AF%B4%E6%98%8E/","excerpt":"我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：","text":"我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果： 官方文档说明123456789const User &#x3D; &#123; template: &#39;&lt;div&gt;User&lt;&#x2F;div&gt;&#39;&#125;const router &#x3D; new VueRouter(&#123; routes: [ &#x2F;&#x2F; 动态路径参数 以冒号开头 &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User &#125; ]&#125;) 现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。 一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID： 123const User &#x3D; &#123; template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;&#39;&#125; 你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 $route.params 中。例如：模式，匹配路径，$route.params 12&#x2F;user&#x2F;:username &#x2F;user&#x2F;evan &#123; username: &#39;evan&#39; &#125;&#x2F;user&#x2F;:username&#x2F;post&#x2F;:post_id &#x2F;user&#x2F;evan&#x2F;post&#x2F;123 &#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125; 除了 $route.params 外，$route 对象还提供了其它有用的信息，例如，$route.query (如果 URL 中有查询参数)、$route.hash 等等。你可以查看 API 文档 的详细说明。 使用编程式的添加路由如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path： 12345const userId &#x3D; &#39;123&#39;router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123&#x2F;&#x2F; 这里的 params 不生效router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user router.replace(location, onComplete?, onAbort?)跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 声明式 编程式 router.replace(…)#router.go(n) 命名路由有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。 12345678910111213const router &#x3D; new VueRouter(&#123; routes: [ &#123; path: &#39;&#x2F;user&#x2F;:userId&#39;, name: &#39;user&#39;, component: User &#125; ]&#125;)要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;这跟代码调用 router.push() 是一回事： router.push({ name: ‘user’, params: { userId: 123 }})这两种方式都会把路由导航到 /user/123 路径 传参你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。 12345const router &#x3D; new VueRouter(&#123; routes: [ &#123; path: &#39;&#x2F;search&#39;, component: SearchUser, props: (route) &#x3D;&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。 请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue $router","slug":"vue-router","permalink":"https://a-lyc.github.io/tags/vue-router/"}]},{"title":"uniapp组件之间的传递","slug":"uniapp/uniapp组件之间的传递","date":"2020-04-04T05:25:06.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/04/04/uniapp/uniapp组件之间的传递/","link":"","permalink":"https://a-lyc.github.io/2020/04/04/uniapp/uniapp%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92/","excerpt":"uniapp监听事件 原生导航搜索按钮点击事件,可以和data同级别","text":"uniapp监听事件 原生导航搜索按钮点击事件,可以和data同级别 12345onNavigationBarButtonTap() &#123; uni.navigateTo(&#123; url:&#39;..&#x2F;SearchList&#x2F;SearchList&#39; &#125;) &#125; 点击搜索框事件，可以和data同级别123456uni.onNavigationBarSearchInputClicked(() &#x3D;&gt;&#123; uni.navigateTo(&#123; url:&#39;..&#x2F;search&#x2F;search&#39; &#125;) console.log(123) &#125;) uniapp里面的组件之间传递信息数据，如何接收数据父组件传递给子组件，使用popst：{}和vue一样传递方式 123456789101112&#x2F;&#x2F;父组件传递mag给子组件，mag定义到实例上的&lt;view :magess&#x3D;&quot;mag&quot;&gt;&lt;&#x2F;view&gt;&#x2F;&#x2F;子组件接收，实例上接收,和定义在data中的方法一样使用popst:&#123; magess:&#123; type:Objest, default()&#123; return &#123;&#125; &#125; &#125;&#125; 子组件传递给父组件this.$emit12345678910&#x2F;&#x2F;z子组件定义事件$emit()发出事件this.$emit(&#39;magess&#39;,&#123;name:name,aeg:age&#125;)&#x2F;&#x2F;父组件接收事件&lt;view @magess&#x3D;&quot;mag&quot;&gt;&lt;&#x2F;view&gt;&#x2F;&#x2F;操作传来的事件信息mag(e)&#123;console.log(e)&#125; uni.$emit和uni.$on页面之间传递应该是可以传输vue之间的页面，保证传输tab的页面uni.$off 销毁 12345678&#x2F;&#x2F;页面上定义事件uni.$emit(&#39;magess&#39;,&#123;name:name,aeg:age&#125;)&#x2F;&#x2F;另外的页面进行接收，最好使用箭头函数uni.$on(&#39;magess&#39;,(e) &#x3D;&gt; &#123; console.log(e) &#x2F;&#x2F;这里的this可以直接访问data&#125;) 全局事件总件定义一个js文件，文件内是全局事件触发存储的，类似于vuex 实例在 uni-app 项目根目录下创建 common 目录，然后在 common 目录下新建 helper.js 用于定义公用的方法。 123456789101112const now &#x3D; Date.now || function () &#123; return new Date().getTime(); &#125;; const isArray &#x3D; Array.isArray || function (obj) &#123; return obj instanceof Array; &#125;; export default &#123; websiteUrl, now, isArray &#125; 接下来在 pages/index/index.vue 中引用该模块 1234567891011121314&lt;script&gt; import helper from &#39;..&#x2F;..&#x2F;common&#x2F;helper.js&#39;; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log(&#39;now:&#39; + helper.now()); &#125;, methods: &#123; &#125; &#125; &lt;&#x2F;script&gt; 这种方式维护起来比较方便，但是缺点就是每次都需要引入。 全局变量globalData小程序中有个globalData概念，可以在 App 上声明全局变量。 Vue 之前是没有这类概念的，但 uni-app 引入了globalData概念，并且在包括H5、App等平台都实现了。在 App.vue 可以定义 globalData ，也可以使用 API 读写这个值。globalData支持vue和nvue共享数据。globalData是一种比较简单的全局变量使用方式。定义：App.vue 1234567891011121314151617181920&lt;script&gt; export default &#123; globalData: &#123; text: &#39;text&#39; &#125;, onLaunch: function() &#123; console.log(&#39;App Launch&#39;) &#125;, onShow: function() &#123; console.log(&#39;App Show&#39;) &#125;, onHide: function() &#123; console.log(&#39;App Hide&#39;) &#125; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &#x2F;*每个页面公共css *&#x2F; &lt;&#x2F;style&gt; js中操作globalData的方式如下：赋值：getApp().globalData.text = ‘test’取值：console.log(getApp().globalData.text) // ‘test’ 修改上一个页面的数据getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。（首页点击之后进入一个页面，这个页面点击之后进入下一个，这个函数会生成三个，以此类推），当点击底部的时候是一底部的为首页进入的","categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/categories/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/tags/uniapp/"}]},{"title":"Promise","slug":"js/Promise","date":"2020-04-03T08:32:10.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/04/03/js/Promise/","link":"","permalink":"https://a-lyc.github.io/2020/04/03/js/Promise/","excerpt":"使用方法:Promise需要接收两个函数作为参数，分别代表then（成功）和catch（失败）new Promise本身是一个对象，里面有个函数，函数内有两个返回值分是then（成功）和catch（失败）jq使用promise多个请求嵌套，为了防止回调地狱 12345678910111213141516let data = &#123;&#125;$.get('url').then( res =&gt; &#123; // 返回的第一个请求数据存到data中去名字data1 console.log(res) data.data1 = res // 在进行网络请求， return $get('url')&#125;).then(res =&gt; &#123; // 接受第二个请求的参数存储到data中去名字data2 data.data2 = res console.log(res) // 输出data console.log(data) // data:&#123;data1:res,data2:res&#125;&#125;) Promise new Promise本身不是一个异步操作，但是内部是一个异步的函数传入 .then(res=&gt;{return 12})当你return一个12的时候下一个then接受的参数就是12，当retuen一个Promise的时候接受的是res(data)的回调函数","text":"使用方法:Promise需要接收两个函数作为参数，分别代表then（成功）和catch（失败）new Promise本身是一个对象，里面有个函数，函数内有两个返回值分是then（成功）和catch（失败）jq使用promise多个请求嵌套，为了防止回调地狱 12345678910111213141516let data = &#123;&#125;$.get('url').then( res =&gt; &#123; // 返回的第一个请求数据存到data中去名字data1 console.log(res) data.data1 = res // 在进行网络请求， return $get('url')&#125;).then(res =&gt; &#123; // 接受第二个请求的参数存储到data中去名字data2 data.data2 = res console.log(res) // 输出data console.log(data) // data:&#123;data1:res,data2:res&#125;&#125;) Promise new Promise本身不是一个异步操作，但是内部是一个异步的函数传入 .then(res=&gt;{return 12})当你return一个12的时候下一个then接受的参数就是12，当retuen一个Promise的时候接受的是res(data)的回调函数 1234567891011121314151617181920// Promise一旦创建直接执行内部的函数代码内部是一个异步的代码new Promise((res,rej)=&gt;&#123;fs.readFile('./data/a.txt','utf8',(err,data)=&gt; &#123; if(err)&#123; // 把容器的pending的状态改为rejected状态 = 就是失败状态 rej(err) &#125;else&#123; // 把容器的pending的状态改为resolve状态 = 就是成功状态 res(data) &#125;&#125;) &#125;).then(res =&gt;&#123; return 1 &#125;).then(res =&gt;&#123; // res就是上面return后的值 return res + 1 // 输出2 &#125;).then(res =&gt;&#123; // res就是上面return后的值 return res + 1 // 输出3 &#125;).catch(rej =&gt;&#123;&#125;) 12345678910111213141516const pro &#x3D; new Promise(res,rej &#x3D;&gt;&#123; &#x2F;&#x2F;进行异步处理，这里使用定时器代替 setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;下面两个只执行一个，这里可以进行处理两个变量 rej(&#39;rej&#39;)&#x2F;&#x2F;失败的时候返回 res(&#39;我没错&#39;)&#x2F;&#x2F;成功的时候返回 &#125;, 200);&#125;)pro.then(res &#x3D;&gt; &#123; console.log(res)&#x2F;&#x2F;接收成功的值 &#125;).catch(err &#x3D;&gt; &#123; console.log(err)&#x2F;&#x2F;接收失败的时候的值 &#125;) Promise.all(iterable)这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注） Promise.race(iterable)当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下： 123456789101112131415161718192021var p1 &#x3D; new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, &#39;P1&#39;);&#125;);var p2 &#x3D; new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, &#39;P2&#39;);&#125;);&#x2F;&#x2F; 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); &#x2F;&#x2F; 获得一个Array: [&#39;P1&#39;, &#39;P2&#39;]&#125;);有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：var p1 &#x3D; new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, &#39;P1&#39;);&#125;);var p2 &#x3D; new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, &#39;P2&#39;);&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); &#x2F;&#x2F; &#39;P1&#39;&#125;);","categories":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/tags/ES6/"}]},{"title":"jq小知识点","slug":"js/jq小知识点","date":"2020-04-03T05:28:32.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/04/03/js/jq小知识点/","link":"","permalink":"https://a-lyc.github.io/2020/04/03/js/jq%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"//找到元素let $header = $(‘.comp-menu’) //全局找到命名这个的元素[data-open=”menu”]let $header = $(‘[data-open=”menu”]’)","text":"//找到元素let $header = $(‘.comp-menu’) //全局找到命名这个的元素[data-open=”menu”]let $header = $(‘[data-open=”menu”]’) //执行事件$header.on(‘click’, function () {}) //动态添加css样式$header.css(‘opacity’,’1’) //可以利用添加删除类来实现动画，动画内不要使用display：none//添加类$headerEl.addClass(‘active’) //删除类$headerEl.removeClass(‘active’) //获取卷曲距离$(window).on(‘scroll’, function () { //获取Y轴卷曲的距离 console.log(window.pageYOffset)})","categories":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/categories/ES6/"}],"tags":[{"name":"jq","slug":"jq","permalink":"https://a-lyc.github.io/tags/jq/"}]},{"title":"vue-cli3.0脚手架搭建项目vant","slug":"vue/vue脚手架引入vant","date":"2020-04-02T06:35:44.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/04/02/vue/vue脚手架引入vant/","link":"","permalink":"https://a-lyc.github.io/2020/04/02/vue/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%95%E5%85%A5vant/","excerpt":"node和npm安装完成的情况下，安装vue的3.0脚手架项目，npm i -g @vue/cli ，之后创建项目vue create hello word（项目名称叫hello word），","text":"node和npm安装完成的情况下，安装vue的3.0脚手架项目，npm i -g @vue/cli ，之后创建项目vue create hello word（项目名称叫hello word）， 有icon的话可以引入// 引入iconfont的样式import ‘./assets/iconfont/iconfont.css’ 安装vant（ui框架）npm i vant -S 引入组件 安装插件npm i babel-plugin-import -D 在babel.config.js配置 123456789101112module.exports &#x3D; &#123; presets: [ &#39;@vue&#x2F;app&#39; ], plugins: [ [&#39;import&#39;, &#123; libraryName: &#39;vant&#39;, libraryDirectory: &#39;es&#39;, style: true &#125;, &#39;vant&#39;] ]&#125; 在src/main.js配置 123456789101112131415161718192021import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;import router from &#39;.&#x2F;router&#39;import store from &#39;.&#x2F;store&#39;&#x2F;&#x2F; 引入Vant UI组件的样式import &#39;vant&#x2F;lib&#x2F;index.css&#39;&#x2F;&#x2F; 1.引入axiosimport axios from &#39;axios&#39;Vue.config.productionTip &#x3D; false&#x2F;&#x2F; 2.把axios绑定到vue实例的属性$axiosVue.prototype.$axios &#x3D; axiosnew Vue(&#123; router, store, render: h &#x3D;&gt; h(App)&#125;).$mount(&#39;#app&#39;) 测试效果123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class&#x3D;&quot;home&quot;&gt; home &lt;div class&#x3D;&quot;iconfont icon-iconfonthome0&quot;&gt;&lt;&#x2F;div&gt; &lt;van-button type&#x3D;&quot;primary&quot;&gt;主要按钮&lt;&#x2F;van-button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Vue from &quot;vue&quot;;import &#123; Button &#125; from &quot;vant&quot;;Vue.use(Button);export default &#123; name: &quot;home&quot;, mounted() &#123; &#x2F;&#x2F;使用axios this.$axios .get(&quot;https:&#x2F;&#x2F;www.xxx.com&quot;) .then(res &#x3D;&gt; &#123; console.log(res); &#125;); &#125;&#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;&lt;&#x2F;style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"使用vant-UI库","slug":"使用vant-UI库","permalink":"https://a-lyc.github.io/tags/%E4%BD%BF%E7%94%A8vant-UI%E5%BA%93/"}]},{"title":"jq获取卷曲出的距离","slug":"js/jq获取卷曲出的距离","date":"2020-04-02T02:14:04.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/04/02/js/jq获取卷曲出的距离/","link":"","permalink":"https://a-lyc.github.io/2020/04/02/js/jq%E8%8E%B7%E5%8F%96%E5%8D%B7%E6%9B%B2%E5%87%BA%E7%9A%84%E8%B7%9D%E7%A6%BB/","excerpt":"使用jq获取卷曲的距离，秦哥脚手架","text":"使用jq获取卷曲的距离，秦哥脚手架 1234567891011121314let $headerEl &#x3D; $(&#39;.comp-header&#39;)&#x2F;&#x2F;获取window的卷曲函数$(window).on(&#39;scroll&#39;, function () &#123;&#x2F;&#x2F;判断卷曲距离window.pageYOffset获取卷曲的距离 if (window.pageYOffset !&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;使用添加类删除类的方式 $headerEl.addClass(&#39;active&#39;) &#125; else &#123; $headerEl.removeClass(&#39;active&#39;) &#125;&#125;)","categories":[{"name":"前端模块化脚手架","slug":"前端模块化脚手架","permalink":"https://a-lyc.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"tags":[{"name":"前端脚手架","slug":"前端脚手架","permalink":"https://a-lyc.github.io/tags/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"vue3.0解决跨域问题","slug":"vue/vue解决跨域问题","date":"2020-03-31T10:22:37.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/31/vue/vue解决跨域问题/","link":"","permalink":"https://a-lyc.github.io/2020/03/31/vue/vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"在vue的vue.config.js（自己创建的）里面进行添加 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; '/api': &#123; target: 'https://www.XXXXXXXXX.com/', changeOrigin: true, ws: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125; 使用的时候，发送网络请求：需要/api/请求地址 自己封装的axios： 123456789101112131415161718192021222324252627import axios from 'axios'export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: '/api', // '/api': 'https://www.XXXXXXXXX.com/', &#125;) // 2.axios的拦截器 // 2.1.请求拦截的作用 instance.interceptors.request.use(config =&gt; &#123; return config &#125;,err =&gt; &#123; return err.data &#125;) // 2.2.响应拦截 instance.interceptors.response.use(res =&gt; &#123; return res.data &#125;,err =&gt; &#123; return err.data &#125;) // 3.发送真正的网络请求 return instance(config)&#125; 调用网络请求： 1234567891011121314151617import &#123;request&#125; from &quot;.&#x2F;request&quot;;&#x2F;&#x2F;前面的api是地址必加export function getCeshi()&#123; return request(&#123; url: &#39;&#x2F;api&#x2F;XXX.php&#39;, &#125;)&#125;export function getArea(city,area)&#123; return request(&#123; url: &#39;&#x2F;api&#x2F;XXX.php&#39;, params:&#123; city, area &#125; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"跨域","slug":"跨域","permalink":"https://a-lyc.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"ES6之async和await同步异步","slug":"js/ES6之async和await同步异步","date":"2020-03-30T08:42:45.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/03/30/js/ES6之async和await同步异步/","link":"","permalink":"https://a-lyc.github.io/2020/03/30/js/ES6%E4%B9%8Basync%E5%92%8Cawait%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/","excerpt":"async和await是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。async 它用的是try/catch 来捕获异常，把await 放到 try 中进行执行，如有异常，就使用catch 进行处理。async返回值是一个Promise 对象，也就是说可以调用then()","text":"async和await是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。async 它用的是try/catch 来捕获异常，把await 放到 try 中进行执行，如有异常，就使用catch 进行处理。async返回值是一个Promise 对象，也就是说可以调用then() 1234567asyncasync function testAsync() &#123; return &quot;hello async&quot;;&#125;const result &#x3D; testAsync();console.log(result); 打印输出的是一个Promise 对象，async 函数会返回一个 Promise 对象。在最外层不能用 await 获取其返回值的情况下，使用 then() 链来处理这个 Promise 对象。 123testAsync().then(v &#x3D;&gt; &#123; console.log(v); &#x2F;&#x2F; 输出 hello async&#125;); 当 async 函数没有返回值时，返回 Promise.resolve(undefined) awaitawait只能放在async函数内部使用 await 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await 也可以用于一个同步的值。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 同步代码 const a = await ‘hello world’// 相当于const a = await Promise.resolve(‘hello world’);// 所以直接写同步代码即可，不需要await关键字const a = ‘hello world’;异步代码 // 2s 之后返回双倍的值function doubleAfter2seconds(num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2 * num) }, 2000); })} async function testResult () { let result = await doubleAfter2seconds(30); console.log(result);} testResult();// 2s 之后，输出了60.执行顺序案例一// 2s 之后返回双倍的值function doubleAfter2seconds(num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2 * num) }, 2000); })} async function testResult () { console.log(‘内部调用前’) // 2 let result = await doubleAfter2seconds(30); console.log(result); // 4 console.log(‘内部调用后’) // 5} console.log(‘外部调用前’) // 1testResult();console.log(‘外部调用后’) // 3// — 依次输出// 外部调用前// 内部调用前// 外部调用后// — 2s 之后输出// 60// 内部调用后分析一下上面的执行顺序：1、首先打印输出外部调用前，同步代码，顺序执行。2、然后调用方法testResult()，打印输出内部调用前，同步代码，顺序执行。3、再执行异步方法doubleAfter2seconds， 1&gt;如果没用await关键字，此后的执行顺序应该是 内部调用后，外部调用后，2s 之后输出60 因为异步方法不阻塞其他代码的执行，最后再输出60 2&gt;这里使用了await关键字，所以到这里后会等待异步返回结果，再往下执行。4、当testResult函数内部await阻塞执行后，不会影响到testResult函数外面 async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 所以，在调用testResult函数后，会继续向下执行，打印输出外部调用后5、当2s之后，异步函数doubleAfter2seconds执行完成，返回结果，打印输出606、因为await将异步变成同步，所以在输出60后，同步执行，再输出内部调用后 案例二代码 console.log(“1”)异步处理函数：console.log（2）console.log(3)结果 正常情况 132用async await 123例子// 2s 之后返回双倍的值function doubleAfter2seconds(num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2 * num) }, 2000); })} async function testResult () { let first = await doubleAfter2seconds(10); let second = await doubleAfter2seconds(20); console.log(first + second);}错误处理方式一 统一处理// 2s 之后返回双倍的值 1234567891011121314151617181920212223&#x2F;&#x2F;不使用asyncfunction doubleAfter2seconds(num) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(2 * num) &#125;, 2000); &#125;)&#125;&#x2F;&#x2F;使用asyncasync function testResult () &#123; let first &#x3D; await doubleAfter2seconds(10); let second &#x3D; await doubleAfter2seconds(20); let res &#x3D; first + second; return res;&#125;testResult().then(res &#x3D;&gt; &#123; console.log(res); &#125;).catch(error &#x3D;&gt; &#123; console.log(error); &#125;); 方式二 try…catch// 2s 之后返回双倍的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function doubleAfter2seconds(num) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(2 * num) &#125;, 2000); &#125;)&#125;async function testResult () &#123; try &#123; let first &#x3D; await doubleAfter2seconds(10); let second &#x3D; await doubleAfter2seconds(20); let res &#x3D; first + second; return res; &#125; catch (error) &#123; console.log(error); &#125;&#125;testResult()在接口中使用(axios)created () &#123; this.init()&#125;,methods: &#123; async init () &#123; try &#123; let first &#x3D; await this.getOne(); let second &#x3D; await this.getTwo(); let res &#x3D; first + second; console.log(res); &#125; catch (error) &#123; console.log(error); &#125; &#125;, getOne () &#123; const params &#x3D; &#123;name: &#39;one&#39;&#125; return new Promise((resolve, reject) &#x3D;&gt; &#123; axios.get(&#39;&#x2F;one&#39;, &#123; params&#125;).then((res) &#x3D;&gt; &#123; if (res.status &#x3D;&#x3D;&#x3D; 200) &#123; resolve(res) &#125; &#125;).catch((err) &#x3D;&gt; &#123; reject(err) &#125;) &#125;) &#125;, getTwo () &#123; const params &#x3D; &#123;name: &#39;two&#39;&#125; return new Promise((resolve, reject) &#x3D;&gt; &#123; axios.get(&#39;&#x2F;two&#39;, &#123; params&#125;).then((res) &#x3D;&gt; &#123; if (res.status &#x3D;&#x3D;&#x3D; 200) &#123; resolve(res) &#125; &#125;).catch((err) &#x3D;&gt; &#123; reject(err) &#125;) &#125;) &#125;,&#125;, 它用的是try/catch 来捕获异常，把await 放到 try 中进行执行，如有异常，就使用catch 进行处理。 123456789101112&#x2F;&#x2F; async&#x2F;awaitasync function show()&#123; let a &#x3D; 12; let b &#x3D; 4; try&#123; let data &#x3D; await $.ajax(&#123;url:&#39;data&#x2F;1.txt&#39;,dataType:&#39;json&#39;&#125;); console.log(&quot;async-try&quot;,data); &#125;catch(e)&#123; console.log(&quot;async-catch&quot;,e) &#125;&#125;show();","categories":[{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/categories/ES6/"}],"tags":[{"name":"await async","slug":"await-async","permalink":"https://a-lyc.github.io/tags/await-async/"}]},{"title":"js找不到this问题","slug":"js/js找不到this问题","date":"2020-03-30T03:29:37.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/03/30/js/js找不到this问题/","link":"","permalink":"https://a-lyc.github.io/2020/03/30/js/js%E6%89%BE%E4%B8%8D%E5%88%B0this%E9%97%AE%E9%A2%98/","excerpt":"在函数中找不到this的问题，可以重新定义一个this指向，that指向最外层data中this的this","text":"在函数中找不到this的问题，可以重新定义一个this指向，that指向最外层data中this的this 12345678910111213141516171819202122232425262728293031async selectGuwen (project_id) &#123; var that &#x3D; this that.showGuwen &#x3D; true that.list_id &#x3D; project_id uni.request(&#123; url: &#39;&#39;, data: &#123; action: &#39;adviser&#39;, dopost: &#39;adviser_list&#39;, openid:this.openId, project_id:project_id &#125;, method: &quot;post&quot;, header: &#123; &#39;content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39; &#125;, success: function (data) &#123; console.log(data)&lt;!-- this.guwenData &#x3D; data.data.data --&gt;&#x2F;**&#x2F;&#x2F;这个位置的this是找不到的，返回undefind&#x2F;&#x2F;指向的是这个父级函数中的data*找的是async selectGuwen 函数内的guwenData，*所以在async selectGuwen 重定义一下this，去找data中的this*&#x2F; that.guwenData &#x3D; data.data.data&#x2F;&#x2F; &#125;, error: function (data) &#123; console.log(data) &#125; &#125;) &#125;,","categories":[],"tags":[]},{"title":"mixin什么是混入","slug":"vue/mixin什么是混入","date":"2020-03-28T10:09:51.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/03/28/vue/mixin什么是混入/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/vue/mixin%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B7%E5%85%A5/","excerpt":"就是在一个公共的js中可以直接引入梦里面可以定义data，metahds，components，directives等，直接添加到相应的方法内。metahds中会添加子级，但是重名的时候会直接替换","text":"就是在一个公共的js中可以直接引入梦里面可以定义data，metahds，components，directives等，直接添加到相应的方法内。metahds中会添加子级，但是重名的时候会直接替换 生命周期是可以的有冲突的时候以组件内的优先在外面定义一个js文件如mixin.js导出文件 123export const timeListenerMiXin&#x2F;&#x2F;导出名称 &#x3D; &#123;data()&#123;&#125;&#125; 引入 1import &#123;timeListenerMiXin&#125; from &#39;@&#x2F;common&#x2F;mixin&#39;; 实例中调用 : 12name: &quot;Detail&quot;,mixins:[timeListenerMiXin], 之后MiXin里面的timeListenerMiXin内的组件条件（data，popst等）会应用到导入的组件中，直接使用this可以调用","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"mixin混入","slug":"mixin混入","permalink":"https://a-lyc.github.io/tags/mixin%E6%B7%B7%E5%85%A5/"}]},{"title":"vue基础","slug":"vue/vue基础","date":"2020-03-28T09:29:25.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/28/vue/vue基础/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/vue/vue%E5%9F%BA%E7%A1%80/","excerpt":"vue属性methods:{}//定义方法属性computed:{}//计算属性watch:{}//监听属性变化components:{}//模板注册props:{}//获取父组件的数据","text":"vue属性methods:{}//定义方法属性computed:{}//计算属性watch:{}//监听属性变化components:{}//模板注册props:{}//获取父组件的数据 生命周期 内可以传输参数created(abc) {}使用前导入： 1234import &#123; ref, computed, watch, getCurrentInstance,onMounted,onRenderTracked,onRenderTriggered,onBeforeMount,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,onErrorCaptured&#125; from &quot;vue&quot;; setup(){} ：生命周期函数需要在这个函数内执行两种形式的生命周期函数可以共存（当然实际使用的时候最好只选用一种），它们都会被执行。Composition API形式的生命周期函数都是在 setup 方法中被调用注册。最后，在实际的开发过程中，请注意一下Options API形式的组件生命周期钩子和Composition API之间的实际对应关系： beforeMount 3.0=&gt; onBeforeMount官方说明：在挂载开始之前被调用：相关的 render 函数首次被调用。 解释：当模板在内存中编译完成，会立即执行实例创建阶段的第三个生命周期函数，这个函数就是beforeMount，此时内存中的模板结构，还没有真正渲染到页面上；此时，页面上看不到真实的数据，用户看到的只是一个模板页面而已； mounted 3.0=&gt; onMounted官方说明：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 解释：mounted是组件创建阶段最后的一个生命周期函数；此时，页面已经真正的渲染好了，用户可以看到真实的页面数据了；当这个生命周期函数执行完，组件就离开了创建阶段，进入到了运行中的阶段；如果大家使用到一些第三方的UI插件，而且这个插件还需要被初始化，那么，必须在mounted中来初始化插件； beforeUpdate 3.0=&gt; onBeforeUpdate官方说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 解释：在执行beforeUpdate运行中的生命周期函数的时候，数据肯定是最新的；但是页面上呈现的数据还是旧的 updated 3.0=&gt; onUpdated官方说明：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 解释：页面也完成了更新，此时，data数据是最新的，同时，页面上呈现的数据也只最新的。 beforeDestroy 3.0=&gt; onBeforeUnmount官方说明：实例销毁之前调用。在这一步，实例仍然完全可用。 解释：当执行beforeDestroy的时候，组件即将被销毁，但是还没有真正开始销毁，此时组件还是正常可用的；data、methods等数据或方法，依旧可以被正常访问 destroyed 3.0=&gt; onUnmounted官方说明：vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 解释：组件已完成了销毁，组件无法使用，data和methods都不可使用。 errorCaptured 3.0=&gt; onErrorCaptured代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;template&gt; &lt;div class&#x3D;&quot;about&quot;&gt; &lt;h1&gt;test count: &#123;&#123; count &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;test: &#123;&#123; test &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;computed: &#123;&#123; doubleCount &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;vuex: &#123;&#123; a &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1 @click&#x3D;&quot;getgreet&quot;&gt;vue3.0的computed和watch，使用方式&lt;&#x2F;h1&gt; &lt;button @click&#x3D;&quot;add(&#39;1123456465645465&#39;)&quot;&gt;增加&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;update(&#39;1123456465645465&#39;)&quot;&gt;更改&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; ref, computed, watch, getCurrentInstance,onMounted,onRenderTracked,onRenderTriggered,onBeforeMount,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,onErrorCaptured&#125; from &quot;vue&quot;;export default &#123; setup() &#123; const &#123; ctx &#125; &#x3D; getCurrentInstance(); &#x2F;&#x2F; 获取当前实例 onBeforeMount(()&#x3D;&gt;&#123; console.log(&quot;在挂载开始之前被调用&quot;) &#125;) onBeforeUnmount(()&#x3D;&gt;&#123; console.log(&quot;实例销毁之前调用&quot;) &#125;) onBeforeUpdate(()&#x3D;&gt;&#123; console.log(ctx) console.log(&quot;数据更新时调用&quot;) &#125;) onUnmounted(()&#x3D;&gt;&#123; console.log(&quot;组件已完成了销毁&quot;) &#125;) onErrorCaptured(()&#x3D;&gt;&#123; console.log(&quot;在错误捕获&quot;) &#125;) onUpdated(()&#x3D;&gt;&#123; console.log(ctx) console.log(&quot;页面也完成了更新&quot;) &#125;) onMounted(() &#x3D;&gt; &#123; console.log(&quot;挂载后 &gt;&gt;&gt;&gt;&gt;&gt;01&quot;); &#125;); onRenderTracked((e) &#x3D;&gt; &#123; console.log(&#39;渲染跟踪&#39;); console.log(e); &#125;); onRenderTriggered((e) &#x3D;&gt; &#123; console.log(&#39;渲染 - 触发&#39;) console.log(e); &#125;); &#x2F;&#x2F; 页面加载的时候触发 const count &#x3D; ref(0); console.log(getCurrentInstance()); console.log(ctx.$router.currentRoute.value); &#x2F;&#x2F; 获取路由 const a &#x3D; computed(() &#x3D;&gt; ctx.$store.state.test.a); &#x2F;&#x2F; 计算属性获取vuex上的属性 const update &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 修改vuex的信息 ctx.$store.commit(&quot;setTestA&quot;, count.value * 10); console.log(ctx.$store.state.test.a); &#125;; let test &#x3D; ref(&quot;我们都是好孩子&quot;); &#x2F;&#x2F; 定义test默认显示内容 const add &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 点击动作 test.value &#x3D; &quot;我是好人&quot;; &#x2F;&#x2F; 修改值 count.value++; &#x2F;&#x2F; count加一 &#125;; &#x2F;&#x2F; function time() &#123; &#x2F;&#x2F; setInterval(()&#x3D;&gt;&#123; &#x2F;&#x2F; count.value++ &#x2F;&#x2F; &#125;,100) &#x2F;&#x2F; &#125; &#x2F;&#x2F; time() watch( () &#x3D;&gt; &#123; &#x2F;&#x2F; 页面加载就读取这个信息 监听属性的变化 console.log(&quot;---- 1 ----&quot;); console.log(count.value); count.value; &#125;, (val) &#x3D;&gt; &#123; console.log(&quot;---- 2 ----&quot;); console.log(&#96;count is $&#123;val&#125;&#96;); &#125; ); const doubleCount &#x3D; computed(() &#x3D;&gt; &#123; &#x2F;&#x2F; 计算属性获取 count.value * 2 return count.value * 2; &#125;); return &#123; &#x2F;&#x2F; 返回定义的对象 count, test, doubleCount, add, a, update, &#125;; &#125;, mounted() &#123; &#x2F;&#x2F; 这个比上面的on要晚 console.log(&#39;挂载后 &gt;&gt;&gt;&gt;&gt;&gt;02&#39;) &#125;, methods: &#123; getgreet() &#123; console.log(&quot;---- methods的点击动作 ----&quot;); console.log(this.update); &#125;, &#125;,&#125;;&lt;&#x2F;script&gt; 组件传递props：父传子ref：子传父//定义到父组件模板上ref=“scroll” 通过this.$refs.scrollemit：子传父//子组件发出事件this.$emit(“scroll”, position); 父组件接收@scroll=”” 事件监听基本使用v-oncev-html=“”v-text=“”v-cloakv-prev-bindv-on:v-for=“变量 in 数组或对象”v-if/v-elsev-showladet，点击输入框会有一个聚焦状态v-model=“”数据的双向绑定事件@input=“” 修饰符stop；//可以阻止事件冒泡prevent；//阻止系统自动提交.enter；//键盘按下回车事件.native；//组件定义事件的时候使用@cilkc.native=””.once；//只执行一次的事件 插槽语法slot name=”left“单个替换 html使用的时候需要更具名字进行替换例子： 左边 按钮 1 如果html没有名字，替换模板没有名字的数据—注意模板是给slot一个name=“” 使用的时候是给buttom slot=“”的 :img加载完成 @load=“方法” 数据传输给对象需要新加建给对象this.res.data = res//data是对象中新加的值 数据传输给数组的时候需要push进去，或者用数组其他方法","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 基本生命周期","slug":"vue-基本生命周期","permalink":"https://a-lyc.github.io/tags/vue-%E5%9F%BA%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"vue的axios封装好的","slug":"vue/vue的axios封装好的","date":"2020-03-28T09:17:43.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/28/vue/vue的axios封装好的/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/vue/vue%E7%9A%84axios%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84/","excerpt":"下载安装vue - axios ，npm install vue-axios –save，，通过axios和后端链接，获取数据，","text":"下载安装vue - axios ，npm install vue-axios –save，，通过axios和后端链接，获取数据， 新建api文件夹内的index文件1234567891011121314151617181920212223242526272829import axios from &#39;axios&#39;&#x2F;&#x2F;git请求export function request(config) &#123; &#x2F;&#x2F; 1.创建axios的实例 const instance &#x3D; axios.create(&#123; baseURL: &#39;网址链接&#39;, &#125;) &#x2F;&#x2F; 2.axios的拦截器 &#x2F;&#x2F; 2.1.请求拦截的作用 instance.interceptors.request.use(config &#x3D;&gt; &#123; console.log(&quot;请求拦截器&quot;) return config &#125;,err &#x3D;&gt; &#123; return err.data &#125;) &#x2F;&#x2F; 2.2.响应拦截 instance.interceptors.response.use(res &#x3D;&gt; &#123; console.log(&quot;响应拦截&quot;) return res.data &#125;,err &#x3D;&gt; &#123; return err.data &#125;) &#x2F;&#x2F; 3.发送真正的网络请求 return instance(config)&#125; 如果后端需要获取数据可传输数据给后端：params:是传输数据的参数 - api文件夹内新建文件导入request 即可使用axios123456789101112131415161718192021222324import &#123;request&#125; from &quot;.&#x2F;request&quot;;export function getHomeMultidata()&#123; return request(&#123; url: &#39;XXX&#39;, method:&#39;post&#39;, data: &#123; firstName: &#39;Fred&#39;, lastName: &#39;Flintstone&#39; &#125; &#125;)&#125;&#x2F;&#x2F; get请求传值export function getHomeGoods(type,page)&#123; return request(&#123; url: &#39;XXX&#39;,&#x2F;&#x2F;&#96;XXX&gt;?data&#x3D;$&#123;data&#125;&amp;page&#x3D;$&#123;page&#125;&#96; &#x2F;&#x2F;传到后端一个type和page获取相应的数据 params:&#123; type, page &#125; &#125;)&#125; 应用：created生命周期内12345 created()&#123; this.getHomeMultidata().then(res &#x3D;&gt; &#123; console.log(res)&#125;) &#125; 最好这样写：123456789101112methods: &#123; getHomeMultidata() &#123; getHomeMultidata().then(res &#x3D;&gt; &#123; console.log(res); &#125;).catch(() &#x3D;&gt; &#123; console.log(&#39;请求失败&#39;) &#125;); &#125;, &#125;, created()&#123; this.getHomeMultidata() &#125; 可以封装一个class类来储存数据12345export class Goods&#123; constructor(itemInfo)&#123;&#x2F;&#x2F;异步请求之后传来的值 this.title &#x3D; itemInfo.title&#x2F;&#x2F;this指向当前实例对象 &#125;&#125; 使用：在总的数据请求中把数据给到data中的Goods12this.Goods &#x3D; new Goods(res.result.itemInfo&#125;&#x2F;&#x2F;把异步请求到的数据传输给Goods，之后Goods接收之后处理接收的信息&#x2F;&#x2F; data中的this.Goods进行接收 常识：导入main.js：import axios from ‘axios’使用：导出：export class Goods{}//导出一个类名为Goods的 123456789101112axios(&#123;url:&#39;&#39;,method:&#39;&#39;&#x2F;&#x2F;修改请求方式（个get等）params:&#123;&#x2F;&#x2F;针对get请求参数拼接 type:&quot;pop&quot;, page:1&#125;&#125;).then( res &#x3D;&gt; &#123;console.log(res)&#125;).catch(()&#x3D;&gt;&#123; console.log(&#39;失败&#39;)&#125;) params：{} get参数拼接的服务器真实返回的是data的数据axis请求方式常见的配置选项请求多个数据，一起返回结果使用axios.all([axios(),axios()]).then(()=&gt;{})///all里面是数组全局配置axios.defaults.baseURL = “”; 创建实例的axios1234567const app &#x3D; axios.create(&#123; 公用的如：baseUrl：&#39;&#39; &#125;)使用： app(&#123; u rl:&quot;&quot;, &#125;).then(()&#x3D;&gt;&#123;&#125;) 请求方式axios(config) axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 常见的配置请求地址url: ‘/user’, 请求类型method: ‘get’, 请根路径baseURL: ‘http://www.baidu.com/api&#39;, 请求前的数据处理transformRequest:[function(data){}], 请求后的数据处理transformResponse: [function(data){}], 自定义的请求头headers:{‘x-Requested-With’:’XMLHttpRequest’}, URL查询对象params:{ id: 12 }, 查询对象序列化函数paramsSerializer: function(params){ }request bodydata: { key: ‘aa’}, 超时设置stimeout: 1000, 跨域是否带TokenwithCredentials: false, 自定义请求处理adapter: function(resolve, reject, config){}, 身份验证信息auth: { uname: ‘’, pwd: ‘12’}, 响应的数据格式 json / blob /document /arraybuffer / text / streamresponseType: ‘json’,","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue axios封装基础","slug":"vue-axios封装基础","permalink":"https://a-lyc.github.io/tags/vue-axios%E5%B0%81%E8%A3%85%E5%9F%BA%E7%A1%80/"}]},{"title":"$router使用方法","slug":"vue/router使用方发","date":"2020-03-28T03:38:10.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/03/28/vue/router使用方发/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/vue/router%E4%BD%BF%E7%94%A8%E6%96%B9%E5%8F%91/","excerpt":"我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由：当vue打包的时候打包生成的路由路径打不开，调整router中的//mode: “history”,，将他注释，是不让url指向发生改变","text":"我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由：当vue打包的时候打包生成的路由路径打不开，调整router中的//mode: “history”,，将他注释，是不让url指向发生改变 常识：返回上一层：this.$router.go(-1) tag=“渲染的标签名”to=“模板名字”linkActiveClasss：“active” //修改点击切换的时候的classactive-class=“active” //默认选中的class修改 123&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;router-link&gt;&#x2F;&#x2F;防止模板的标签，to&#x3D;“模板名字”&lt;router-link to&#x3D;&quot;&#x2F;About&quot;&gt;关于&lt;&#x2F;router-link&gt;&#x2F;&#x2F;防止模板的标签，to&#x3D;“模板名字”&lt;router-view&gt;&lt;&#x2F;router-view&gt;&#x2F;&#x2F;模板里面内容显示的区域 拿到路由对象$router拿到最大的路由this.$router.方法如：replaceStateurl监听$route拿到当前路由的数据 导航守卫：前置钩子（守卫guard）：beforeEach 函数类型，函数内包含三个参数to,from,next,next()是必须有的router.beforeEach((to,from,next) =&gt;{})后置的钩子（钩子hook）：afterEach 函数类型，函数内有两个参数，to,from；router.beforeEach((to,from) =&gt;{}) 缓存数据keep-ailve–清除缓存每次点击重新创建 1&lt;keep-alive exclude&#x3D;&quot;创建模板的name,name2,name3&quot;&gt;&#x2F;&#x2F;那些不缓存 router：123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F;创建导入，总结整合目录这个是起一个项目的基本&#x2F;**找到对应的vue文件命名一下，之后使用*&#x2F;const Home &#x3D; () &#x3D;&gt; import(&#39;views&#x2F;home&#x2F;Home&#39;);&#x2F;&#x2F;创建与个routerconst routes &#x3D; [&#x2F;&#x2F;默认的路径，打开直接是&#x2F;home &#123; path:&#39;&#x2F;&#39;, redirect:&#39;&#x2F;home&#39; &#125;, &#x2F;&#x2F;导入的目录 &#123; path: &#39;&#x2F;home&#39;, name: &#39;Home&#39;, component: Home &#125;&#x2F;&#x2F;详情页传递，因为:iid可以传来参数更改url的请求，可以通过vue axios来更改这个值 &#123; path: &#39;&#x2F;detail&#x2F;:iid&#39;, name: &#39;Detail&#39;, component: Detail &#125;,]&#x2F;&#x2F;实例化const router &#x3D; new VueRouter(&#123; mode: &#39;history&#39;, base: process.env.BASE_URL, routes&#125;)&#x2F;&#x2F;导出export default router vue axios接收参数 123456789101112import &#123; request &#125; from &quot;.&#x2F;request&quot;;export function getDetailActive(iid) &#123; return request(&#123; url: &#39;&#x2F;detail&#39;, &#x2F;&#x2F;拼接的参数 params: &#123; iid &#125; &#125;)&#125; 如何传入axios接收参数： 12345678910&#x2F;&#x2F;生命周期 - 创建完成（可以访问当前this实例）created() &#123; &#x2F;&#x2F;获取route中的iid，注意是当前路由的iid const iid &#x3D; this.$route.params.iid &#x2F;&#x2F;axios发来的getDetailActive需要传参 getDetailActive(iid).then(res &#x3D;&gt; &#123; console.log(res) &#125;)&#125;, 如何改变url路径 12&#x2F;&#x2F;监听事件····detail在router中定义过后缀名一定同一（iid） this.$router.push(&#39;&#x2F;detail&#x2F;&#39; + &#39;找到iid，或者唯一的id&#39;)","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"$router","slug":"router","permalink":"https://a-lyc.github.io/tags/router/"}]},{"title":"父子之间传递信息和ref，$el","slug":"vue/父子之间传递信息","date":"2020-03-28T02:53:02.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/28/vue/父子之间传递信息/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/vue/%E7%88%B6%E5%AD%90%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/","excerpt":"父子之间传递信息和ref，$el $emit子组件定义事件，父组件接收//父组件访问子组件","text":"父子之间传递信息和ref，$el $emit子组件定义事件，父组件接收//父组件访问子组件 子组件： 12345methods:&#123; addToCart(index)&#123; this.$emit(&#39;addCart&#39;,index) &#125;,&#125; 父组件 12&#x2F;&#x2F;addToCart:可以自己定义事件内容,还可以取到传来的参数 &lt;detail-bottom-bar @addCart&#x3D;&quot;addToCart&quot;&gt;&lt;&#x2F;detail-bottom-bar&gt; popst父组件传数据，子组件接收,父组件传输给子组件的信息，子组件是不可以进行修改的，需要传入data中另存一份进行修改，这个数据和父组件的数据是没有双向绑定的，如果需要子组件修改后的数据需要通过子组件传输的方式进行传输 父组件： 123&#x2F;&#x2F;父组件把goods传入子组件:good&#x3D;&quot;goods&quot;&#x2F;&#x2F;good和子组件关联的 子组件 12345678910props: &#123; &#x2F;&#x2F;子组件的good是父组件传来的goods 是数组或对象可以循环遍历，别的值可用&#123;&#123;&#125;&#125; good:&#123; type:Array, &#x2F;&#x2F;数组和对象默认值是一个函数 default()&#123; return [] &#125; &#125;&#125;, ref1&lt;scroll ref&#x3D;&quot;scroll&quot;&gt;&lt;&#x2F;scroll&gt; 获取scroll对象的Vue Component里面的组件 使用//自行打印看看 1this.$refs.scroll $el //自行打印看看$el获取整个页面的DOM就是整个页面的HTML 补充：有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。父组件访问子组件：使用$children或$refs子组件访问父组件：使用$parent $children我们先来看下$children的访问this.$children是一个数组类型，它包含所有子组件对象。我们这里通过一个遍历，取出所有子组件的message状态。 $children的缺陷：通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs $refs的使用：$refs和ref指令通常是一起使用的。首先，我们通过ref给某一个子组件绑定一个特定的ID。其次，通过this.$refs.ID就可以访问到该组件了。 如果我们想在子组件中直接访问父组件，可以通过$parent注意事项：尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了。如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题。另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"ref refs 组件传递","slug":"ref-refs-组件传递","permalink":"https://a-lyc.github.io/tags/ref-refs-%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92/"}]},{"title":"sceoll插件应用","slug":"js/sceoll应用","date":"2020-03-28T02:51:51.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/03/28/js/sceoll应用/","link":"","permalink":"https://a-lyc.github.io/2020/03/28/js/sceoll%E5%BA%94%E7%94%A8/","excerpt":"如果滚动不好用使用contentScroll执行组件中的refresh() 或者 @load=””给scroll中组件内的图片加上这个属性之后传出来执行refresh()","text":"如果滚动不好用使用contentScroll执行组件中的refresh() 或者 @load=””给scroll中组件内的图片加上这个属性之后传出来执行refresh() scroll 网址：https://better-scroll.github.io/ 安装:npm install @better-scroll/core@next –save 其余插件介绍 目前支持鼠标滚轮有：核心滚动 npm install @better-scroll/mouse-wheel@next --save 下拉动作 npm install @better-scroll/pull-down@next --save 样式美观的滚动条 npm install @better-scroll/scroll-bar@next --save 用于轮播和 swipe 效果 npm install @better-scroll/slide@next --save上拉加载插件 npm install @better-scroll/pull-up@next –save 模板使用方法 通过ref=“scroll” :prode-type=”3” 3为监听滚动到拿了 :pullUpLoad=”true” 需要安装插件，监听上拉加载 @scroll=”事件名” 返回参数“position”–返回顶部： 12345&#x2F;&#x2F;内容滚动到一定位置返回按钮显示 contentScroll(position) &#123; this.isShowBackTop &#x3D; -position.y &gt; 1000; &#125;,这个方法返回一个true，定义一个组件为flase的时候为隐藏，ture为显示 @pullingUp=“事件” 上拉加载事件加载更多 123456789101112131415161718data中有个列表名称所以能直接使用currentType：“pop”找到异步传来的函数调用列表名this.getHomeGoods(this.currentType);&#x2F;&#x2F;异步请求，有列表名称和页码getHomeGoods(type) &#123; &#x2F;&#x2F;获取当前第几页 const page &#x3D; this.goods[type].page + 1; &#x2F;&#x2F;异步请求 getHomeGoods(type, page).then(res &#x3D;&gt; &#123; &#x2F;&#x2F;ES6语法追加到某个数组中 this.goods[type].list.push(...res.data.list) this.goods[type].page +&#x3D; 1; &#x2F;&#x2F;监听连续加载 this.$refs.scroll.finishPullUp(); &#125;); &#125; 使用12345678&#x2F;&#x2F;组件上&lt;scroll class&#x3D;&quot;content&quot; ref&#x3D;&quot;scroll&quot; :probe-type&#x3D;&quot;2&quot; @scroll&#x3D;&quot;contentScroll&quot;&gt;&lt;&#x2F;scroll&gt;import Scroll from &quot;@&#x2F;components&#x2F;common&#x2F;scroll&#x2F;Scroll&quot;; &#x2F;&#x2F;scrol滚动 contentScroll() &#123; this.$refs.scroll.refresh(); &#125;, 如果滚动不好用使用contentScroll执行组件中的refresh() 或者 @load=””给scroll中组件内的图片加上这个属性之后传出来执行refresh()","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue插件","slug":"vue插件","permalink":"https://a-lyc.github.io/tags/vue%E6%8F%92%E4%BB%B6/"}]},{"title":"vuex和全局组件传递的使用","slug":"vue/vuex和全局组件传递的使用","date":"2020-03-27T13:14:50.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/27/vue/vuex和全局组件传递的使用/","link":"","permalink":"https://a-lyc.github.io/2020/03/27/vue/vuex%E5%92%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用vuex中的state需要在组件中导入，计算属性中使用…mapState({name: state =&gt; state.XX.XXX.XXX})，使用方法的时候可以直接this.$store.commit(“logout”);就是调用mutations上的方法","text":"使用vuex中的state需要在组件中导入，计算属性中使用…mapState({name: state =&gt; state.XX.XXX.XXX})，使用方法的时候可以直接this.$store.commit(“logout”);就是调用mutations上的方法 vuex和全局组件传递的使用，传给vuex的时候是一个确切的值，页面通过this.$store.dispatch(“”,{})的属性给Action值进行整合，Action之后通过commit属性给mutations值，之后mutations直接把值给state vuex 向vuex中传递参数 执行一个动作或者一个事件如：页面加载，点击。处于活跃状态等生命周期 vuex的目录结构：//保存状态的：state/保存方法的：mutations：//单独页面，统一导入//计算属性：Getters；//单独页面，统一导入//处理异步的操作：Action；//单独页面，统一导入-Action 提交的是 mutation，而不是直接变更状态-//划分模块，Module 页面使用使用this.$store.dispatch传输给VUEX中的actions—–1：Action 提交的是 mutation，而不是直接变更状态；2：Action 可以包含任意异步操作。Action返回值可以是一个Promise通过.then可以调用返回值—–id=”0” 123456789101112&#x2F;**引号内是发出的事件，vuex actions中接收，*this.index是data或者其他地方的参数。可以是任何形式的，如&#123;&#125;，[]*&#x2F;this.$store.dispatch(&#39;addClick&#39;,this.index)&#x2F;&#x2F;Promise -----id&#x3D;&quot;0&quot;this.$store.dispatch(&#39;addClick&#39;,this.index).then(res &#x3D;&gt; &#123; &#x2F;&#x2F;打印的是在vuex中的actions里面的resolve() id：01 console.log(res)&#125;) actions接收页面传来的数据你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters 123456789&#x2F;&#x2F;传入的方法，之后给到mutations actions: &#123; &#x2F;&#x2F;事件名称接收addClick &#x2F;&#x2F;第一个参数是固定的，第二个payLoad传来的参数 addClick(context, payLoad) &#123; &#x2F;&#x2F;返回的是上一级调用Promise的res（使用dispatch传输给VUEX中的actions）id：01 resolve(&#39;当前数量+1&#39;) &#125;, &#125;, actions使用commit传输给VUEX中的mutations 1234&#x2F;&#x2F;接收到参数通过commit给mutations getTabControl()&#123;&#125;actions&#123; context.commit(&#39;getTabControl&#39;,payLoad)&#125; 也可以在页面直接传递 123456this.$store.commit(&#39;getTabControl&#39;,this.index)&#x2F;**引号内是发出的事件，vuex mutations中接收，*this.index是data或者其他地方的参数。可以是任何形式的，如&#123;&#125;，[]*payLoad接收，可以其他名字，但不建议*&#x2F; mutations接收actions和页面传来的参数 12345678910111213&#x2F;&#x2F;传入的方法最好是是单一的 getTabControlmutations: &#123; &#x2F;&#x2F;需要通过state.tabcontrol赋值给state &#x2F;* *参数： *payLoad--传输来的值 *state----state系统定义的第一个参数 * *&#x2F; getTabControl(state, payLoad)&#123; state.tabcontrol &#x3D; payLoad &#125; &#125;, vuex页面上的应用 12345678910111213141516171819&#x2F;&#x2F;导入vuex会找到Actions内定义的方法进行传入&#x2F;**mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性*mapActions 辅助函数仅仅是将 store 中的 actions 映射到methods ......*&#x2F;import &#123;mapActions&#125; from &#39;vuex&#39;&#x2F;&#x2F;使用vuex methods : &#123; &#x2F;&#x2F;数组方式使用，还可以对象方式等 ...mapActions([ &#x2F;&#x2F;tabcontrol是Actions内的一个方法，进行导入的是在计算属性内， &#39;tabcontrol&#39; ]), &#125;,&#x2F;&#x2F;调用vuex的数据，由于此步骤的上一步进行了导入，所以这里可以直接操作this.tabcontrol&#x2F;&#x2F;可以直接达到 async/await 1234567891011&#x2F;&#x2F; 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit(&#39;gotData&#39;, await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch(&#39;actionA&#39;) &#x2F;&#x2F; 等待 actionA 完成后执行下面的 commit(&#39;gotOtherData&#39;, await getOtherData()) &#125;&#125; vuex中接收传来的参数 12345678910111213141516171819202122232425262728export default new Vuex.Store(&#123;&#x2F;&#x2F;不可以直接修改state内的值 state: &#123; tabcontrol:&#39;pop&#39;,&#x2F;&#x2F;接收到的实际参数,其他页面可应用的参数 &#125;,&#x2F;&#x2F;传入的方法最好是是单一的mutations: &#123; getTabControl(state, payLoad)&#123; state.tabcontrol &#x3D; payLoad &#125;&#x2F;&#x2F;需要通过state.tabcontrol赋值给state &#125;, &#x2F;&#x2F;传入的方法，之后给到mutations actions: &#123; tabcontrols(context, payLoad) &#123; &#x2F;&#x2F;返回的是上一级调用Promise的res（使用dispatch传输给VUEX中的actions） resolve(&#39;当前数量+1&#39;) &#x2F;&#x2F;接收到参数通过commit给mutations context.commit(&#39;getTabControl&#39;,payLoad) &#125;, &#125;, modules: &#123; &#125;&#125;) $bus 自定义后缀min.js定义一下 1Vue.prototype.$bus &#x3D; new Vue() 传出： 12&#x2F;&#x2F;使用$bus.$emit传出this.$bus.$emit(&#39;itemImages&#39;,parameter) 接收： 12接收 this.$bus.$on(&quot;itemImages&quot;, () &#x3D;&gt; &#123;&#125;);","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue 全局组件传递","slug":"vue-全局组件传递","permalink":"https://a-lyc.github.io/tags/vue-%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92/"}]},{"title":"如何创建一个博客网站","slug":"如何创建一个博客网站","date":"2020-03-27T02:46:43.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/27/如何创建一个博客网站/","link":"","permalink":"https://a-lyc.github.io/2020/03/27/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"如何创建一个博客网站 如何创建一个博客网站参考网址：https://hexo.io/zh-cn/docs/","text":"如何创建一个博客网站 如何创建一个博客网站参考网址：https://hexo.io/zh-cn/docs/ 准备条件安装npm安装node安装git概述安装Hexo npm install -g hexo-cli npm install hexo 新建文件后输入：hexo init &lt;文件夹名&gt; 新建文件之后新建完成后，指定文件夹的目录如下.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes hexo init cd 文件夹 npm i 配置 https://hexo.io/zh-cn/docs/configuration 添加文章 hexo new ’文章名称加双引号‘ 文章路径 参数描述-p, –path自定义新文章的路径-r, –replace如果存在同名文章，将其替换-s, –slug文章的 Slug，作为新文章的文件名和发布后的 URL hexo new page –path about/me “About me” 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me” 文章 Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：title: Hello World date: 2013/7/13 20:46:25以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数描述默认值layout布局title标题文章的文件名date建立日期文件建立日期updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址keywords仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） https://hexo.io/zh-cn/docs/front-matter https://hexo.io/zh-cn/docs/tag-plugins 生成静态文件 hexo g 选项描述-d, –deploy文件生成后立即部署网站-w, –watch监视文件变动-b, –bail生成过程中如果发生任何未处理的异常则抛出异常-f, –force强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate-c, –concurrency最大同时生成文件的数量，默认无限制 静态模式在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate，此模式通常用于生产环境（production mode）下。$ hexo server -s 草稿发布 hexo publish [layout] “草稿名称” 草稿建立 hexo new draft “new draft” 生成文件使用 Hexo 生成静态文件快速而且简单。 hexo generate 监视文件变动 Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入 hexo generate –watch 完成后部署 您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。 简写 上面两个命令可以简写为 $ hexo g -d $ hexo d -g - hexo generate --deploy - hexo deploy --generate模版 hexo new photo “My Gallery” 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：$ hexo new photo “My Gallery”在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：变量描述layout布局title标题date文件建立日期 启动服务器选项描述-p, –port重设端口-s, –static只使用静态文件-l, –log启动日记记录，使用覆盖记录格式 hexo serve 部署网站部署网站。参数描述-g, –generate部署之前预先生成静态文件 hexo d 清除缓存文件$ hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 hexo clean 列出网站资料list$ hexo list 列出网站资料 hexo list 引用资源 服务器部署过程安装Hexo npm install -g hexo-cli npm install hexo 新建文件后输入：hexo init &lt;文件夹名&gt; 进环境 hexo server 部署 hexo deploy 清除缓存 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令 hexo clean git上操作 在gti新建一个和用户名相同的储存库 之后安装 Travis CI 新建一个 repository。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io。将你的 Hexo 站点文件夹推送到 repository 中。默认情况下不应该 public 目录将不会被推送到 repository 中，你应该检查 .gitignore 文件中是否包含 public 一行，如果没有请加上。将 Travis CI 添加到你的 GitHub 账户中。前往 GitHub 的 Applications settings，配置 Travis CI 权限，使其能够访问你的 repository。你应该会被重定向到 Travis CI 的页面。如果没有，请 手动前往。在浏览器新建一个标签页，前往 GitHub 新建 Personal Access Token，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件：sudo: falselanguage: node_jsnode_js: 10 # use nodejs v10 LTScache: npmbranches:only: master # build master branch onlyscript: hexo generate # generate static filesdeploy:provider: pagesskip-cleanup: truegithub-token: $GH_TOKENkeep-history: trueon:branch: masterlocal-dir: public将 .travis.yml 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 gh-pages 分支下在 GitHub 中前往你的 repository 的设置页面，修改 GitHub Pages 的部署分支为 gh-pages。前往 https://&lt;你的 GitHub 用户名&gt;.github.io 查看你的站点是否可以访问。这可能需要一些时间。Project page如果你更希望你的站点部署在 &lt;你的 GitHub 用户名&gt;.github.io 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt; 访问。你需要检查你的 Hexo 配置文件，将 url 修改为 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;、将 root 的值修改为 /&lt;repository 的名字&gt;/Private repositoryThe following instruction is adapted from one-command deployment page.Install hexo-deployer-git.Add the following configurations to _config.yml, (remove existing lines if any) deploy: type: git repo: https://github.com// example, https://github.com/hexojs/hexojs.github.io branch: gh-pagesRun hexo clean &amp;&amp; hexo deploy.Check the webpage at username.github.io. https://hexo.io/zh-cn/docs/github-pages 保存上传的git命令 注意修改子用户名 URLIf your site is put in a subdirectory, set url as ‘http://yoursite.com/child&#39; and root as ‘/child/‘url: http://yoursite.comroot: /child/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing ‘index.html’ from permalinks trailing_html: true # Set to false to remove trailing ‘.html’ from permalinks 发表文章过程需要进入环境查看 hexo serve 发表文章 hexo new ‘文章标题’ 生成静态 hexo generate 上传服务器 hexo deploy 源码上传 软件上传源码","categories":[{"name":"资源","slug":"资源","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"零散资源","slug":"零散资源","permalink":"https://a-lyc.github.io/tags/%E9%9B%B6%E6%95%A3%E8%B5%84%E6%BA%90/"}]},{"title":"基于秦哥脚手架创建项目","slug":"基于秦哥脚手架创建项目","date":"2020-03-27T02:16:44.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/27/基于秦哥脚手架创建项目/","link":"","permalink":"https://a-lyc.github.io/2020/03/27/%E5%9F%BA%E4%BA%8E%E7%A7%A6%E5%93%A5%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/","excerpt":"前后端分离项目，但是不使用 vue，react，angular（也就是说没有现成的脚手架） generator-jason 前端模块化脚手架","text":"前后端分离项目，但是不使用 vue，react，angular（也就是说没有现成的脚手架） generator-jason 前端模块化脚手架 InstallationFirst, install Yeoman and generator-jason using npm (we assume you have pre-installed node.js). 12npm install -g yonpm install -g generator-jason Then generate your new project: 12yo jasonnpm run dev -&gt; localhost:8080 使用场景 非前后端分离，后端模板项目 前后端分离项目，但是不使用 vue，react，angular（也就是说没有现成的脚手架） 目录解析1234567891011121314151617181920212223242526管理员目录，项目会生成一个管理员目录启动开发环境后可以在 http://localhost:8080/admin.html 中查看全部页面的链接 和 组件- admin打包后的目录- dist项目源码src 资产目录，css，js，font - assets 组件目录，由于使用的 ejs 作为 html 语言，可通过 require 的方式引入并且传入 prop，实现组件化 其中 components/index.js 会在 main.js 中执行，初始化组件 - components 国际化目录 - i18n 页面目录，存放着页面组件 - views 项目公共配置 - main.js 组件化 components 和 views 目录下的 A 文件夹作为模板，复制改名用即可 ejs require 实现&lt;% ‘脚本’ 标签，用于流程控制，无输出，任意类型。 %&gt; &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 ejs基本使用方法，循环，判断，赋值，传值 123456789101112&#x2F;&#x2F;组件模板中定义：&#x2F;**如果text有值的时候是假的，之后执行假的，也就是显示组件上的值*&#x2F;&lt;%if (!text) var text &#x3D; &#39;&#39;;%&gt;&#x2F;&#x2F;定义之后使用 &lt;div class&#x3D;&quot;product-active-title&quot;&gt; &lt;%&#x3D; text %&gt; &lt;&#x2F;div&gt; 12345678910111213&#x2F;**组件内可以进行判断，ejs可以写判断的代码*&#x2F;&lt;% if (title) &#123; %&gt; &lt;%&#x3D; title %&gt;&lt;% &#125; %&gt;&lt;!-- ejs 中引入组件 --&gt;&lt;%&#x3D; require(&#39;..&#x2F;..&#x2F;components&#x2F;A&#x2F;index.ejs&#39;)(&#123; &#x2F;&#x2F; 可传参数任意类型 title: &#39;我是title&#39;， arr：[&#123;name:&#39;mame&#39;&#125;]&#125;) %&gt; 12345678910&#x2F;&#x2F;组件内进行判断 -三元表达式&lt;%if (!dir) var dir &#x3D; &#39;x&#39;;var coverPath &#x3D; dir &#x3D;&#x3D;&#x3D; &#39;x&#39; ? require(&#39;.&#x2F;images&#x2F;article-x.jpg&#39;) : require(&#39;.&#x2F;images&#x2F;article-y.jpg&#39;)%&gt;&#x2F;&#x2F;模板使用&lt;a class&#x3D;&quot;comp-article &lt;%&#x3D; dir %&gt;&quot; href&#x3D;&quot;#&quot;&gt; &lt;b class&#x3D;&quot;comp-article-media-inner&quot; style&#x3D;&quot;background-image: url(&lt;%&#x3D; coverPath %&gt;);&quot;&gt;&lt;&#x2F;b&gt;&lt;&#x2F;a&gt; //使用循环,定义 12345678910111213141516&#x2F;**if判断这传来的参数，有传来的参数的时候显示传来的参数，没有显示[ &#39;1&#39;, &#39;2&#39; ]*注意 &lt;% 循环 %&gt; 注意是&lt;% %&gt; 之后内如何显示参数：&lt;%&#x3D; 参数值[i索引值] %&gt; *&#x2F;&lt;%if (!dataArr) var dataArr &#x3D; [ &#39;1&#39;, &#39;2&#39; ]%&gt;&#x2F;&#x2F;模板使用&lt;div class&#x3D;&quot;comp-tab&quot;&gt; &lt;% for (var i &#x3D; 0; i &lt; dataArr.length; i++) &#123; %&gt; &lt;a class&#x3D;&quot;comp-tab-item &lt;%&#x3D; i &#x3D;&#x3D;&#x3D; 0 ? &#39;active&#39; : &#39;&#39; %&gt;&quot; href&#x3D;&quot;#&quot;&gt; &lt;%&#x3D; product[ i ].name %&gt; &lt;%&#x3D; product[ i ].age %&gt; &lt;&#x2F;a&gt; &lt;% &#125; %&gt;&lt;&#x2F;div&gt; //ejs使用 12345678910111213141516171819&#x2F;**使用require导入这个模板之后可使用定义的参数进行传参，使用逗号进行隔开，传输值，*例子是传输一个字符串的方式*&#x2F;&lt;%&#x3D; require(&#39;..&#x2F;..&#x2F;components&#x2F;list&#x2F;index.ejs&#39;)(&#123; text:&quot;Apis&quot;, product:[&#123;name:&quot;nihao&quot;,age:&#39;18&#39;&#125;,&#123;name:&quot;nihao&quot;,age:&#39;18&#39;&#125;]&#125;) %&gt;&#x2F;&#x2F;条件判断&lt;% if(false) &#123; %&gt; &lt;div&gt; 我是显示的 &lt;&#x2F;div&gt; &lt;% &#125;else&#123; %&gt; &lt;div&gt; 我是隐藏的 &lt;&#x2F;div&gt;&lt;% &#125; %&gt; 注意 views 打包时，页面组件的 css 和 js 的名称，进行了单独的处理 将按照页面组件的目录名编译成 hash 字符串（相同页面的 css 和 js 名称是一样的）目的是实现页面组件的中文目录命名，方便开发（后端模板项目建议中文命名，前后端分离项目不建议中文命名） html 路径问题 使用下面方法引入即可 12&lt;img src&#x3D;&quot;&lt;%&#x3D; require(&#39;.&#x2F;images&#x2F;abc.jpg&#39;) %&gt;&quot;&gt;&lt;div style&#x3D;&quot;background-image: url(&lt;%&#x3D; require(&#39;.&#x2F;images&#x2F;abc.jpg&#39;) %&gt;)&quot;&gt;&lt;&#x2F;div&gt; css使用说明 include引入外部文件 res是一个变量 @include res(width,100px,20/100);@include res(width,100px,(xs:10px,md:20px)); import引入’css路径’ ~包内的css @import “../../assets/styles/utils”;@import “~jason-css/src/responsive/util”; 生成的 css 文件说明 vendor 第三方模块 css（node_modules） common 项目中的通用样式以及组件样式（assets，components） hash.css 各个页面的单独样式（views/**/index.scss） 生成的 js 文件说明 vendor 第三方模块（node_modules） common 项目中的工具库以及组件（assets，components） main main.js hash.js 各页面单独的业务逻辑（views/**/index.js）","categories":[{"name":"前端模块化脚手架","slug":"前端模块化脚手架","permalink":"https://a-lyc.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"tags":[{"name":"前端脚手架","slug":"前端脚手架","permalink":"https://a-lyc.github.io/tags/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"px转换单位为vw和rpx的插件","slug":"vue/px转换单位为rpx","date":"2020-03-25T12:32:56.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/03/25/vue/px转换单位为rpx/","link":"","permalink":"https://a-lyc.github.io/2020/03/25/vue/px%E8%BD%AC%E6%8D%A2%E5%8D%95%E4%BD%8D%E4%B8%BArpx/","excerpt":"vwpostcss-px-to-viewport，将px单位自动转换成viewport单位，用起来超级简单，postcss-px-to-viewport 文档· 如果不想转换为Px，大写的P就好","text":"vwpostcss-px-to-viewport，将px单位自动转换成viewport单位，用起来超级简单，postcss-px-to-viewport 文档· 如果不想转换为Px，大写的P就好 安装 –dev是安装到开发环境中 打包之后的依赖 npm install postcss-px-to-viewport –save-dev 引入vue项目，再postcss.config.js引入12345678910111213141516171819202122232425module.exports &#x3D; &#123; plugins: &#123; autoprefixer: &#123;&#125; &#125;, &quot;postcss-px-to-viewport&quot;: &#123; viewportWidth: 750, &#x2F;&#x2F; 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, &#x2F;&#x2F; 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, &#x2F;&#x2F; 指定&#96;px&#96;转换为视窗单位值的小数位数 viewportUnit: &quot;vw&quot;, &#x2F;&#x2F;指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&#39;.ignore&#39;,&#39;tab-bar&#39;,&#39;tab-bar-item&#39;],&#x2F;&#x2F; 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, &#x2F;&#x2F; 小于或等于&#96;1px&#96;不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false &#x2F;&#x2F; 允许在媒体查询中转换&#96;px&#96; &#125;&#125;; 参数解析12345678910111213141516&#123; unitToConvert: &#39;px&#39; viewportWidth: 320, unitPrecision: 5, propList: [&#39;*&#39;], viewportUnit: &#39;vw&#39;, fontViewportUnit: &#39;vw&#39;, selectorBlackList: [], minPixelValue: 1, mediaQuery: false, replace: true, exclude: [], landscape: false, landscapeUnit: &#39;vw&#39;, landscapeWidth: 568&#125; unitToConvert (String) 要转换的单位，默认是’px’viewportWidth (Number) viewport的宽度，默认是320，可根据设计稿来，750的设计稿就写750unitPrecision (Number) 指定px转换为视窗单位值的小数位数，默认是5propList (Array) 指定可以转换的css属性，默认是[‘*’]，代表全部属性进行转换 精确匹配 代表全部属性在字符串前面或者后面用，如 [‘*position‘] 会匹配background-position-y用！则该属性排除. 如: [‘*’, ‘!letter-spacing’]Combine the “not” prefix with the other prefixes. Example: [‘’, ‘!font’] viewportUnit (String)指定需要转换成的视窗单位，默认vwfontViewportUnit (String)指定字体需要转换成的视窗单位，默认vwselectorBlackList (Array) 指定不转换为视窗单位的类，保留px，值为string或正则regexp，建议定义一至两个通用的类名 值为string类型， 检查字符是否包含 [&apos;body&apos;] 匹配 .body-class值为regexp类型，正则匹配. [/^body$/] 匹配 body 而不是 .body ​​​​​​​minPixelValue (Number) 默认值1，小于或等于1px不转换为视窗单位,mediaQuery (Boolean) 是否在媒体查询时也转换px，默认falsereplace (Boolean) replaces rules containing vw instead of adding fallbacks.exclude (Array or Regexp) 设置忽略文件，如node_modules 如果是regexp, 忽略全部匹配文件. 如果是数组array, 忽略指定文件. 可能遇到的问题1、@keyframes 和media查询里的px默认是不转化的，设置mediaQuery： true则媒体查询里也会转换px @keyframes可以暂时手动填写vw单位的转化结果 px2rem如何在vue-cli3.0中使用postcss-plugin-px2rem 插件插件的作用是 自动将vue项目中的px转换为rem 。 为什么这三个中要推荐 postcss-plugin-px2rem呢？ 因为 postcss-plugin-px2rem 这个插件 配置选项上有 exclude 属性，它可以配置 是否对 某个文件夹下的所有css文件不进行从px到rem的转换。 所以我们可以利用这个特性，把项目中的 node_module 文件夹排除掉。这样如果我们项目中是用了，前端UI框架的话，就不会吧UI框架（Vant,Element等）中的 px单位转换成rem了 postcss-plugin-px2rem 官方文档：https://www.npmjs.com/package/postcss-plugin-px2rempostcss-pxtorem 官方文档：https://www.npmjs.com/package/postcss-pxtorem postcss-px2rem 官方文档：https://www.npmjs.com/package/postcss-px2rem 使用npm安装插件：npm i postcss-plugin-px2rem –save -dev 具体配置方法如下：在vue-cli3.0中。去掉了build和config文件夹。所有的配置都放到了vue.config.js中（默认为空，如果没有这个文件自己写一个）。 反向代理的配置 1234567891011121314module.exports &#x3D; &#123; &#x2F;&#x2F;反向代理的配置 devServer: &#123; proxy: &#123; &#39;&#x2F;api&#39;: &#123; target: &#39;http:&#x2F;&#x2F;-,&#x2F;&#x2F;目标地址 ws: true, &#x2F;&#x2F;&#x2F;&#x2F; 是否启用websockets changeOrigin: true, &#x2F;&#x2F;开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite: &#123;&#39;^&#x2F;api&#39;: &#39;&#x2F;&#39;&#125; &#x2F;&#x2F;这里重写路径 &#125; &#125; &#125;,&#125; 在vue-cli3中使用postcss-px2rem 配置类似，如下： 使用postcss-px2rem时的vue.config.js配置：1234567891011121314module.exports &#x3D; &#123; lintOnSave: true, css: &#123; loaderOptions: &#123; postcss: &#123; plugins: [ require(&#39;postcss-px2rem&#39;)(&#123; &#x2F;&#x2F;配置项，详见官方文档 remUnit: 30 &#125;), &#x2F;&#x2F; 换算的基数 ] &#125; &#125; &#125;,&#125; 记得npm i 安装包； 可能遇到的坑： 如果个别地方不想转化px。可以简单的使用大写的 PX 或 Px 。","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue插件","slug":"vue插件","permalink":"https://a-lyc.github.io/tags/vue%E6%8F%92%E4%BB%B6/"},{"name":"单位转换","slug":"单位转换","permalink":"https://a-lyc.github.io/tags/%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2/"}]},{"title":"vue插件懒加载和移动端延迟","slug":"vue/vue插件懒加载和移动端延迟","date":"2020-03-25T12:27:58.000Z","updated":"2022-03-03T08:33:28.856Z","comments":true,"path":"2020/03/25/vue/vue插件懒加载和移动端延迟/","link":"","permalink":"https://a-lyc.github.io/2020/03/25/vue/vue%E6%8F%92%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BB%B6%E8%BF%9F/","excerpt":"在移动端会使用fastClick插件 安装npm i fastclick","text":"在移动端会使用fastClick插件 安装npm i fastclick 导入：min.js中：import FastClick from ‘fastclick’ 调用：//解决移动端的300ms延迟FastClick.attach(document.body) 图片懒加载 安装npm i vue-lazyload -save 导入:min.js:import VuelazyLoad from ‘vue-lazyload’//使用图片懒加载插件Vue.use(VuelazyLoad) 使用:img :src=“./img.jpg”修改成v-lazy=“./img.jpg”","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue插件 懒加载 移动端延迟","slug":"vue插件-懒加载-移动端延迟","permalink":"https://a-lyc.github.io/tags/vue%E6%8F%92%E4%BB%B6-%E6%87%92%E5%8A%A0%E8%BD%BD-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BB%B6%E8%BF%9F/"}]},{"title":"vsCoods快捷创建模板","slug":"vsCoods快捷创建模板","date":"2020-03-24T10:42:04.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/03/24/vsCoods快捷创建模板/","link":"","permalink":"https://a-lyc.github.io/2020/03/24/vsCoods%E5%BF%AB%E6%8D%B7%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF/","excerpt":"在一个Vue的项目中，反复的新建.vue文件是一个必不可少的工序。本着科技让人偷懒的原则，我们可以利用VSCode的snippet在.vue文件创建后能轻松地生成一套模板。","text":"在一个Vue的项目中，反复的新建.vue文件是一个必不可少的工序。本着科技让人偷懒的原则，我们可以利用VSCode的snippet在.vue文件创建后能轻松地生成一套模板。 第一步：使用ctrl+shift+p（文件-首选项-用户代码片段）输入vue 自动打开vue.json 的文件输入模板模板具体格式：$0 鼠标在的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;!-- $1 --&gt;&quot;, &quot;&lt;template&gt;&quot;, &quot;&lt;div class&#x3D;&#39;$&#123;2:webapp&#125;&#39;&gt;$5&lt;&#x2F;div&gt;&quot;, &quot;&lt;&#x2F;template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;&#x2F;&#x2F;这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）&quot;, &quot;&#x2F;&#x2F;例如：import 《组件名称》 from &#39;《组件路径》&#39;;&quot;, &quot;&quot;, &quot;export default &#123;&quot;, &quot;name:&#39;$&#123;2:another&#125;&#39;,&quot;, &quot;&#x2F;&#x2F;import引入的组件需要注入到对象中才能使用&quot;, &quot;components: &#123;&#125;,&quot;, &quot;data() &#123;&quot;, &quot;&#x2F;&#x2F;这里存放数据&quot;, &quot;return &#123;&quot;, &quot;&quot;, &quot;&#125;;&quot;, &quot;&#125;,&quot;, &quot;&#x2F;&#x2F;监听属性 类似于data概念&quot;, &quot;computed: &#123;&#125;,&quot;, &quot;&#x2F;&#x2F;监控data中的数据变化&quot;, &quot;watch: &#123;&#125;,&quot;, &quot;&#x2F;&#x2F;方法集合&quot;, &quot;methods: &#123;&quot;, &quot;&quot;, &quot;&#125;,&quot;, &quot;&#x2F;&#x2F;生命周期 - 创建完成（可以访问当前this实例）&quot;, &quot;created() &#123;&quot;, &quot;&quot;, &quot;&#125;,&quot;, &quot;&#x2F;&#x2F;生命周期 - 挂载完成（可以访问DOM元素）&quot;, &quot;mounted() &#123;&quot;, &quot;&quot;, &quot;&#125;,&quot;, &quot;beforeCreate() &#123;&#125;, &#x2F;&#x2F;生命周期 - 创建之前&quot;, &quot;beforeMount() &#123;&#125;, &#x2F;&#x2F;生命周期 - 挂载之前&quot;, &quot;beforeUpdate() &#123;&#125;, &#x2F;&#x2F;生命周期 - 更新之前&quot;, &quot;updated() &#123;&#125;, &#x2F;&#x2F;生命周期 - 更新之后&quot;, &quot;beforeDestroy() &#123;&#125;, &#x2F;&#x2F;生命周期 - 销毁之前&quot;, &quot;destroyed() &#123;&#125;, &#x2F;&#x2F;生命周期 - 销毁完成&quot;, &quot;activated() &#123;&#125;, &#x2F;&#x2F;如果页面有keep-alive缓存功能，这个函数会触发&quot;, &quot;&#125;&quot;, &quot;&lt;&#x2F;script&gt;&quot;, &quot;&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;&quot;, &quot;&#x2F;&#x2F;@import url($3); 引入公共css类&quot;, &quot;.$&#123;2:another&#125; &#123;&#125;&quot;, &quot;&lt;&#x2F;style&gt;&quot; ], &quot;description&quot;: &quot;Log output to console&quot; &#125; 第二步: 添加配置，让vscode允许自定义的代码片段提示出来文件 –&gt; 首选项 –&gt; 设置 —&gt; 添加这2项// Specifies the location of snippets in the suggestion widget“editor.snippetSuggestions”: “top”,// Controls whether format on paste is on or off“editor.formatOnPaste”: true","categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"}],"tags":[{"name":"vue vsCoods快捷创建模板","slug":"vue-vsCoods快捷创建模板","permalink":"https://a-lyc.github.io/tags/vue-vsCoods%E5%BF%AB%E6%8D%B7%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF/"}]},{"title":"map导入点击地图出现","slug":"vue/map导入点击地图出现","date":"2020-03-23T01:54:48.000Z","updated":"2022-03-03T08:33:28.828Z","comments":true,"path":"2020/03/23/vue/map导入点击地图出现/","link":"","permalink":"https://a-lyc.github.io/2020/03/23/vue/map%E5%AF%BC%E5%85%A5%E7%82%B9%E5%87%BB%E5%9C%B0%E5%9B%BE%E5%87%BA%E7%8E%B0/","excerpt":"需要引入jsnpm i –save jason-webmap安装，使用秦哥脚手架自动安装的然后建立一个wenmap的文件，","text":"需要引入jsnpm i –save jason-webmap安装，使用秦哥脚手架自动安装的然后建立一个wenmap的文件， webmap-Js： 12345678910import webmap from &#39;jason-webmap&#39;;import &#39;~jason-webmap&#x2F;dist&#x2F;jason-webmap.css&#39;;&#x2F;&#x2F; or&#x2F;&#x2F; 推荐，可通过变量定制import &#39;~jason-webmap&#x2F;src&#x2F;style.scss&#39;;webmap(&#123; &#x2F;&#x2F; 激活 map 的按钮选择器 选择器是根据a标签的open-map来的，可以写成a[open-map&#x3D;”webmap”] openSelector: &#39;a[open-map&#x3D;webmap]&#39;, &#x2F;&#x2F; 跟随者 map 一同移动的内容选择器 最好市body市第一父级，之后有个自己名称叫做comp-root类名 moveSelector: &#39;.comp-root&#39;&#125;) webmap-ejs 123456789101112131415161718192021222324252627282930313233&lt;aside class&#x3D;&quot;jason-map&quot;&gt; &lt;div class&#x3D;&quot;jason-map-content&quot;&gt; &lt;h3 class&#x3D;&quot;jason-map-heading&quot;&gt;网站导航&lt;&#x2F;h3&gt; &lt;div&gt; &lt;div class&#x3D;&quot;jason-map-item&quot;&gt; &lt;h4 class&#x3D;&quot;jason-map-title&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司简介&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt; &lt;ul class&#x3D;&quot;jason-map-ilist&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;jason-map-item&quot;&gt; &lt;h4 class&#x3D;&quot;jason-map-title&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司简介&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt; &lt;ul class&#x3D;&quot;jason-map-ilist&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;导航&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;jason-map-footer&quot;&gt; &lt;h5&gt;版权所有&lt;&#x2F;h5&gt; &lt;h5&gt;xxxxxxx 有限公司 &lt;&#x2F;h5&gt; &lt;p class&#x3D;&quot;mt-xs-10&quot;&gt;鲁ICP备 xxxxxxx 号&lt;&#x2F;p&gt; &lt;p&gt;网站设计：jason&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;aside&gt; webmap - Css： 12@import &quot;..&#x2F;..&#x2F;assets&#x2F;styles&#x2F;utils&quot;;@import &#39;~jason-webmap&#x2F;src&#x2F;style.scss&#39;; 需要导入css定制的时候可以使用强制执行来做 footer组件-ejs 123&lt;a href&#x3D;&quot;#&quot; open-map&#x3D;&quot;webmap&quot;&gt; DESIGNED BY LTD&lt;&#x2F;a&gt; 首页以及其他页面 - ejs 和内容为兄弟级别 1234&lt;body&gt; &lt;main class&#x3D;&quot;comp-root&quot;&gt;&lt;&#x2F;main&gt;&lt;%&#x3D; require(&#39;..&#x2F;..&#x2F;components&#x2F;webmap&#x2F;index.ejs&#39;)() %&gt;&lt;&#x2F;body&gt; 语法引入： 1&lt;%&#x3D; require(&#39;..&#x2F;..&#x2F;components&#x2F;webmap&#x2F;index.ejs&#39;)() %&gt;&#x2F;&#x2F;创建一个webmap组件文件进行引入，","categories":[{"name":"前端模块化脚手架","slug":"前端模块化脚手架","permalink":"https://a-lyc.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"tags":[{"name":"前端脚手架","slug":"前端脚手架","permalink":"https://a-lyc.github.io/tags/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"js基础","slug":"js/运算使用到的数组，字符串","date":"2020-03-22T13:39:43.000Z","updated":"2022-03-03T08:33:28.772Z","comments":true,"path":"2020/03/22/js/运算使用到的数组，字符串/","link":"","permalink":"https://a-lyc.github.io/2020/03/22/js/%E8%BF%90%E7%AE%97%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"运算符操符： 算数运算符： +、-、、/、% +：特殊是连接作用，两个都是数字运算，一个数字一个字符串拼接","text":"运算符操符： 算数运算符： +、-、、/、% +：特殊是连接作用，两个都是数字运算，一个数字一个字符串拼接 一元运算符： ++、– ++：累加 –：累减 （如果++在前面先自身+1，之后和后面的值进行运算， 如果++在后面，先运算完成之后在自身+1） 二元运算符（符合运算符）： +=、-=、=、/=、 例子：var a += b；//var a = a+b 关系运算符： &lt;、 &lt;=、 &gt; 、&gt;=、==(不严格)、 ===（类型和值都要一样）、 !=(不严格) 、!==（严格）：返回的值是一个boolean类型的 逻辑运算符： &amp;&amp;、||、！ ：&amp;&amp;如果有一个为false结果为flase ||:有一个为true返回true 赋值运算符： = 运算符的优先级别： 1：（）2：++ – ！3：+ - * / %4：&gt; &gt;= &lt; &lt;=5：== === != ！==6:先&amp;&amp; 后||7：= 获取值的相关信息.length 获取任何值的长度；用法（变量.length）this 这个元素本身 字符转换.toString() 转字符串.parseInt() 转整数（遇到字符会转字符之前的数字）.parseFloat() 转小数（遇到字符会转字符之前的数字）.Number() 转数字（严格模式）Boolean() 转布尔值（0、“”、null、undefined、为false其他为ture） 关键字：continue 循环中使用，遇到直接进行下一个循环brack 跳出循环return 函数中使用，返回值，遇到直接跳出函数 Maht方法：//静态对象：不需要创建，直接就是一个对象，方法（静态方法）直接通过这个对象名字调用的静态必须通过大写的名称调用Math.PI 是3.1415926Math.E 自然数的2底数2.17Math.abc(值) 数字的绝对值Math.ceil(值) 想上取余Math.floor(值) 向下取余Math.max() 最大值Math.max.apply(null,arr) 数组中最大值Math.min() 最大值Math.pow(x,y) x的y次方Math.sqrt()Math.random() 返回一个伪随机数 //总结date方法dt.getFullYear();//年dt.getMonth();//月dt.getDay();//日dt.getDate();//周dt.getHours();//时dt.getMinutes();//分dt.getSeconds();//秒dt.getDay();///日dt.toDateString();//英文时间dt.toLocaleDateString();//正常时间dt.toTimeString();//24小时制时间dt.toLocaleTimeString();//12小时制时间dt.valueOf()//毫秒 //DOM//docnment 文档element 元素node 节点root 根 获取文档中的标签//根据id获取getElementById(‘id属性’)//找到这个id的元素属性，返回这个属性 //根据标签 名称获取getElementByTagName(‘标签名称’)//返回这个标签名称的伪数组，不管是一个还是多个标签返回值就是一个数组,需要循环遍历出来 //根据类样式获取元素， document.getElementsByClassName(‘class标签名称’)反回的是是一个数组，一个伪数组，只要有这个calss的值，都会读取得到//–ie8以下不支持 //获取一个属性querySelector(“标签名，#1 #2 cls”)document.querySelectorAll(‘选择器名称’)//返回多个值，形成一个为数组 //自定义属性获取自定义属性的值getAttribute(‘自定义属性’)//需要在html上设置之后获取设置自定义属性的值setAttribute(“自定义属性”,“值”)//设置完之后需要上面方法获取移除自定义属性的值.removeAttribute(‘自定义属性’)//html中有自定义属性输入属性值可以 //创建一个元素标签docnment.wirte(‘标签的额代码内容’);创建元素有缺陷，如果加载完毕之后，此时通过这个方式创建元素，此时页面上创建的内容全部不存在了对象.innerHTML = “标签机代码内容”; document.createElement(“标签名字”);//创建之后需要追加父级元素.appendChild(标签名所对应的变量)appendChild(变量) 从前向后添加这个标签insertBefore(变量,参照的参数) 在参照参数后面添加replaceChild(变量，元素) 第一个变量/元素替换第二个元素/变量cloneNode(true/false) true：全部复制，包括标签属性，值。False：只复制标签 事件.onclick //点击事件.onmouseover //鼠标经过事件.onmouseout //鼠标移出事件.onfocus //获取焦点事件 .onblur //失去焦点事件.onkeyup //键盘抬起事件.onmousemove //鼠标移动事件（使用方法：.onmousemove = function(e){元素.offsetLeft = e.clientX+”px”; 元素.offsetLeft = e.clientY+”px”;可视区域的横纵坐标}）.onscroll //元素的滚动事件获取滚动的距离 对象点添加属性.innerHTML //带标签的文档（可不带）.innerText //不带标签.style.color //style样式classList.add(标签名称) //添加class类classList.remove(标签名称) //删除class类className //添加class类（有弊端，添加可能会把别的删除）addClass //添加class类（有弊端，添加可能会把别的删除）removeClass //删除class类（有弊端，删除可能会把别的删除）//设置元素样式的方式对象.style.属性 = 值;对象.calss.属性 = 值; 节点元素获取//获取父级节点console.log(ulObj.parentNode);//找到父级所有的节点 //获取父级元素console.log(ulObj.parentElement);//找到父级所有的标签 //获取子节点console.log(ulObj.childNodes);//找到子级标签和文本（空格换行算是文本） //获取子元素console.log(ulObj.children)//找到子级标签 //获取第一个子节点console.log(ulObj.firstChild)//可能是字或者空格换行，不是标签 //获取第一个子元素console.log(ulObj.firstElementChild)//是第一个标签 //获取最后一个子节点console.log(ulObj.lastChild)//最后一个文本空格换行。。。。。。 //获取最后一个子元素console.log(ulObj.lastElementChild)//是最后一个标签 //获取某个元素的前一个节点console.log(threebj.previousSibling)//前一个文本空格换行。。。。。。 //获取某个元素的前一个元素console.log(threebj.previousElementSibling)//前一个标签 //获取某个元素的后一个节点console.log(threebj.nextSibling)//后一个文本空格换行。。。。。。 //获取某个元素的后一个元素console.log(threebj.nextElementSibling)//后一个标签 节点属性：（可以使用标签–元素.出来；属性节点.出来，文本节点.出来）(下面是相互对应的) nodeType: 节点类型 标签；1， 属性；2： 3：文本nodeName: 节点名字 标签节点：大写的表标签名 属性节点：小写的属性名 文本节点：#textnodeValue: 节点的值 标签节点–null 属性节点：属性的值 文本节点：文本内容 为元素绑定事件1：addEventListener() //参数1：事件的类型，事件名称,没有on //参数2：是一个函数 //参数3：布尔类型对象.addEventListener(“事件类型”,事件处理函数,false)谷歌火狐ie11支持，ie8不支持对象.attachEvent(“事件类型”,事件处理函数）有on谷歌火狐不支持ie11不支持，ie8支持解绑事件 注意：用什么事件绑定事件就用对应的方式解绑事件 1：先绑定,后解除对象.on事件名称 = function(){}解绑对象.on事件名称 = null 2：绑定事件对象.addEventListener(“没有on的click”,命名函数,false)//ie8不支持解绑事件对象.removeEventListener(“click”,解绑的命名函数,flase) 3: 绑定事件对象.attachEvent(“on事件名称”,函数名称)//火狐谷歌不支持解绑事件对象.detachEvent(“on事件名称”,函数名称) //事件的三个阶段1.事件捕获阶段：从外向内2.事件目标阶段3.事件冒泡阶段：从里向外//为元素绑定事件addEventListener(“没有on的事件”,事件处理函数,控制事件阶段（布尔值）);事件触发过程中，会出现事件冒泡效果，如何阻止冒泡控制:addEventListener中的第三个参数是控制事件阶段的，获取:e.eventPhase 这个属性可以知道这个属性是当前的那个阶段，值1是捕获阶段 从外向内值2是目标阶段 唯一的值3是冒泡阶段 从里向外，一般是冒泡阶段 定时器：//参数1：函数 参数2：时间毫秒数1000毫秒就是1秒 //timeSet是定时器的id，不点击停止会一直执行 var timeSet = setInterval(函数,毫秒时间)//停止定时器clearInterval(timeSet);//定时器的id 获取元素 根据 介绍.getElementById(“btn”) 根据id获取这个标签(元素) 从文档中找到id值为btn的这个标签(元素)，document.getElementById(“id属性的值”);======&gt;返回的是一个元素对象.getElementsByTagName(“p”); .getElementsByTagName(“标签的名字”);返回的是一个伪数组, 无论获取的是一个标签,还是多个标签,最终都是在数组中存储的,这行代码的返回值就是一个数组.getElementsByClassName(“cls”); 根据类样式的名字来获取元素，返回的是一个伪数组, 无论获取的是一个标签,还是多个标签,最终都是在数组中存储的,这行代码的返回值就是一个数组.querySelectorAll(“.cls”) 根据选择器的方式获取元素 事件.onclick 注册鼠标点击事件.onmouseover 注册鼠标进入事件.onmouseout 注册鼠标离开事件.onfocus 注册获取焦点的事件.onblur 注册失去焦点的事件.onkeydow 注册键盘按下事件.onkeyup 注册键盘抬起事件.onload 页面加载完毕,这个事件就会触发.onmousemove 注册鼠标拖动事件 clientX，clientY，pageX，pageY 坐标轴.onscroll 注册滚动事件.onmousedown 注册鼠标按下.onmouseup 注册鼠标抬起document.onkeydown = function(e){console.log(e.keyCode);} 查看键盘按下的是哪个键，对应着数字 对象.addEventListener(“事件类型”,事件处理函数,false) 为元素绑定事件谷歌和火狐支持,IE8不支持my$(“btn”).removeEventListener(“click”,f1,false); 解绑事件的时候,需要在绑定事件的时候,使用命名函数对象.attachEvent(“有on的事件类型”,事件处理函数) 谷歌不支持,火狐不支持,IE8支持my$(“btn”).detachEvent(“onclick”,f1); 解绑事件的时候,需要在绑定事件的时候,使用命名函数 DOM方法.innerText innerHTML才是真正的获取标签中间的所有内容.textContent 设置标签中的文本内容.innerText 凡是成对的标签,中间的文本内容,设置的时候,都使用innerText这个属性的方式 document.getElementById(“p1”).innerText=”这是一个p”.style.width 凡是css中这个属性是多个单词的写法,在js代码中DOM操作的时候.把-干掉,后面的单词的首字母大写即可.className=”cls” 在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className.removeAttribute(“class”) 删除calss.classList.add(“类名称”) 添加css类.classList.remove(“类名称”) 删除css类 offset系列元素.offsetLeft（宽高上下左右） 样式在style标签中获取方法 :父级元素margin+父级元素padding+父级元素的border+自己的margin.offsetWidth: 获取元素的宽.offsetHeight: 获取元素的高.offsetLeft: 获取元素距离左边位置的值.offsetTop: 获取元素距离上面位置的值 scroll系列.scrollWidth 元素中内容的实际的宽.scrollHeight 元素中内容的实际的高.scrollTop 向上卷曲出去的距离.scrollLeft 向左卷曲出去的距离 client系列 可视区域.clientHeight 可视区域的高(没有边框),边框内部的高度.clientWidth 可视区域的宽(没有边框),边框内部的宽度.clientLeft 左边边框的宽度.clientTop 上面的边框的宽度.clientX 可视区域的横坐标（单机的位置距离X轴开始位置的坐标）.clientY 可视区域的纵坐标（单机的位置距离Y轴开始位置的坐标） 节点属性getAttribute(“score”) 在html标签中添加的自定义属性,如果想要获取这个属性的值,需要使用getAttribute(“自定义属性的名字”)才能获取这个属性的值 获取自定义属性的值setAttribute(“属性的名字”,”属性的值”) 设置自定义属性:setAttribute(“属性的名字”,”属性的值”); 设置自定义属性removeAttribute(“属性的名字”) 移除自定义属性:removeAttribute(“属性的名字”) 移除自定义属性nodeType: 节点的类型:1—-标签,2—属性,3—文本nodeName 节点的名字:标签节点—大写的标签名字,属性节点—小写的属性名字,文本节点—-#textnodeValue 节点的值:标签节点—null,属性节点—属性值,文本节点—文本内容parentNode 父级节点parentElement 父级元素childNodes 子节点children 子元素firstChild 第一个子节点firstElementChild 第一个子元素lastChild 最后一个子节点 IE8中是第一个子元素lastElementChild 最后一个子元素 IE8中不支持previousSibling 某个元素的前一个兄弟节点 IE8中是第一个子元素previousElementSibling 某个元素的前一个兄弟元素 IE8中不支持nextSibling 某个元素的后一个兄弟节点nextElementSibling 某个元素的后一个兄弟元素 .write(“标签的代码及内容”) 创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,那么页面上存在的所有的内容全部被干掉对象.innerHTML=”标签及代码” 对象.innerHTML=”标签代码及内容”document.createElement(“标签的名字”) document.createElement(“标签名字”);对象 “//把创建后的子元素追加到父级元素中 父级对象.appendChild(pObj);”父级元素.appendChild(子级元素对象) 追加元素父级元素.inerstBefore(新的子级对象,参照的子级对象) 把新的子元素插入到参考子元素的前面父级元素.removeChild(要干掉的子级元素对象) 移除父级元素中子级元素getComputedStyle 获取任意一个元素的任意一个样式属性的值 “兼容代码：function getStyle(element,attr) { //判断浏览器是否支持这个方法 return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]; }” 使用方法： console.log(getStyle(my$(“dv”),”top”))getComputedStyle(elenent,null) 传入一个对象和一个空值 功能排他功能阻止a跳转 阻止超链接的默认的跳转:return false location对象console.log(window.location.hash) 地址栏上#及后面的内容console.log(window.location.host) 主机名及端口号console.log(window.location.hostname) 主机名console.log(window.location.pathname) 文件的路径—相对路径console.log(window.location.port) 端口号console.log(window.location.protocol) 协议console.log(window.location.search) 搜索的内容location.href=”http://www.jd.com&quot; 设置跳转的页面的地址location.assign(“http://www.jd.com&quot;) 设置跳转的页面的地址location.reload() 重新加载–刷新location.replace(“http://www.jd.com&quot;) 没有历史记录 userAgentconsole.log(window.navigator.userAgent) 通过userAgent可以判断用户浏览器的类型console.log(window.navigator.platform) 通过platform可以判断浏览器所在的系统平台类型. client系列 可视区域.clientHeight 可视区域的高(没有边框),边框内部的高度.clientWidth 可视区域的宽(没有边框),边框内部的宽度.clientLeft 左边边框的宽度.clientTop 上面的边框的宽度 定时器var timeId = setInterval(function () {}, 1000); “参数1:函数参数2:时间—毫秒—1000毫秒–1秒执行过程:页面加载完毕后,过了1秒,执行一次函数的代码,又过了1秒再执行函数…..返回值就是定时器的id值”clearInterval(timeId); 参数:要清理的定时的id的值window.setTimeout(函数,时间); 另一个定时器——-一次性的定时clearTimeout(timeId); 参数:要清理的定时的id的值 事件冒泡控制:addEventListener中的第三个参数是控制事件阶段的， 事件触发过程中，会出现事件冒泡效果，如何阻止冒泡获取:e.eventPhase 这个属性可以知道这个属性是当前的那个阶段， window.enent.cancelBubble = true;//谷歌，ie支持，火狐不支持1是捕获阶段 从外向内 事件处理函数中的参数（e）.stopPropagation()//阻止事件冒泡//ie不支持，这是火狐的标准2是目标阶段 唯一的 事件参数e 在ie的浏览器不存在可以使用 window.enent来代替3是冒泡阶段 从里向外，一般是冒泡阶段 window.setSelection().removeAllRanges()||docnment.selection.empty() 知道三个值可根据比例来的出第四个值公式x/y = a/b 移项 ay = bx 求y = bx/a 不占空间的原型prototype 使用方法：自定义对象名称.prototype.自定义方法名称 = function(){} 或者一个值创建实例化对象 prototype使用这个创建里面的this认清 使用，举例子“ function 实例化对象名（首字母大写）(btnObj,dvObj,json) { this.btnObj = btnObj; this.dvObj = dvObj; this.json = json; } 实例化对象名.prototype.init = function(){ var than = this; this.btnObj.onclick = function(){ for(var key in json){ than.dvObj.style[key] = than.json[key]; }; }; };“ “ var json = { “”width””:””100px””, “”height””:””500px””, “”backgroundColor””:””yellow””, “”border””:””1px solid red”” } var sc = new Person(my$(“”btn””),my$(“”dv””),json); sc.init();” 重点function(){this}.bind(than)//函数中的this就是bind中的than（变量对象）比如定时器中的this是window，然后在函数中.bind(构造函数顶级this的变量名)，定时器中的this就是bind出来的变量名，bind改变了里面this的指向 函数中的继承问题 Proson.call(this,父级形参)没有继承方法 构造函数.call（当前对象this）function Person(name){this.name = name}function Student(name,exe){proson.call(this,name);this.exe = exe;}var stu = new Student(“小明”,10) 改变this的指向 当前对象就是想让这个this指向谁 调用的时候改变this的指向函数名/方法名.prototype/方法.call(当前对象,值，值…) f1.call(当前对象,值，值…)函数名/方法名.prototype/方法.apply(当前对象,[值，值，值，..]) f1.apply(当前对象,[值，值，值，..])改变this的指向，使用方法函数名.apply(对象,[参数1，参数2，参数3.。。。。])；函数名.call(对象,参数1,参数2,……)我想要使用其他对象的某个方法，其他对象.方法名.apply（当前对象，参数1…..）/call(当前对象，参数……)这个方法就会被当前的对象所用，同时这个方法中的this就是当前对象，在调用方法的时候改变了this的指向 复制一份的时候，把参数传入到函数中，第一个参数默认为window 可以穿this 是复制的时候改变了this的指向.bind();这个方法是复制的意思，参数可以在复制的时候传进去，也可以在复制之后调用的时候传进去 函数内的几个属性函数.name 返回值是函数的名字函数名.arguments 返回值是一个伪数组函数名.length 返回形参的个数函数名.caller 返回有谁调用了这个函数","categories":[{"name":"学习整理的前端","slug":"学习整理的前端","permalink":"https://a-lyc.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E7%9A%84%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jsES5-js单词","slug":"jsES5-js单词","permalink":"https://a-lyc.github.io/tags/jsES5-js%E5%8D%95%E8%AF%8D/"}]},{"title":"css3动画","slug":"css/css3动画","date":"2020-03-21T11:09:05.000Z","updated":"2022-03-03T08:33:28.768Z","comments":true,"path":"2020/03/21/css/css3动画/","link":"","permalink":"https://a-lyc.github.io/2020/03/21/css/css3%E5%8A%A8%E7%94%BB/","excerpt":"transform可以用来设置元素的形状改变、主要有几种：","text":"transform可以用来设置元素的形状改变、主要有几种： transform设置元素的形状改变transform可以用来设置元素的形状改变、主要有几种：rotata（旋转（单位deg））、scale（缩放）、skew（扭曲）、teanslate（移动）、marix（矩形变阵） 使用方法.类名称{transfrom：rotate（60deg） scale（.2） skew（） translate（X，Y） matrix（）；} transfrom-origin基点设置所有的变形都是基于基点，基点默认为元素的中心点。用法：transform-origin: (x, y)，其中 x 和 y 的值可以是百分比、rem 或者是 px 等等，也可以用表示位置的单词来表示例如：x 可以用left、center、right；y 可以用top、center、bottom。 使用方法.transform-class { transform-origin: (left, bottom);} rotate 旋转用法：rotate()；表示通过指定的角度对元素进行旋转变形，如果是正数则顺时针旋转，如果是负数则逆时针旋转，例如： .transform-rotate { transform: rotate(30deg);} scale 缩放它有三种用法：scale([, ])、scaleX()和scaleY()；分别代表水平和垂直方向同时缩放、水平方向的缩放以及垂直方向的缩放，入参代表水平或者垂直方向的缩放比例。缩放比例如果大于1则放大，反之则缩小，如果等于1代表原始大小。 .transform-scale { transform: scale(2,1.5);} .transform-scaleX { transform: scaleX(2);} .transform-scaleY { transform: scaleY(1.5);} translate 移动移动也分三种情况：translate([, ])、translateX()和translateY()；分别代表水平和垂直的移动、水平方向的移动以及垂直方向同时移动，移动单位是 CSS 中的长度单位：px、rem等; .transform-translate { transform: translate(400px, 20px);} .transform-translateX { transform: translateX(300px);} .transform-translateY { transform: translateY(20px);} skew 扭曲扭曲同样也有三种情况，skew([, ])、skewX()和skewY()；同样也是水平和垂直方向同时扭曲、水平方向的扭曲以及垂直方向的扭曲，单位为角度。 .transform-skew { transform: skew(30deg, 10deg);} .transform-skewX { transform: skewX(30deg);} .transform-skewY { transform: skewY(10deg);} transition一种状态变平滑过渡到另外一种状态transition是用来设置样式的属性值是如何从从一种状态变平滑过渡到另外一种状态，它有四个属性： transition-property（变换的属性，即那种形式的变换：大小、位置、扭曲等）；transition-duration（变换延续的时间）；transition-timing-function（变换的速率）transition-delay（变换的延时） .transition-class { transition ： [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt; [, [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt;]]*;} transition-property平滑过渡的效果它是用来设置哪些属性的改变会有这种平滑过渡的效果，主要有以下值： none；all；元素属性名：color；length；visibility；….transition-property { transition-property ： none | all | [ ] [ ‘,’ ]*;} transition-duration转换过程的持续时间它是用来设置转换过程的持续时间，单位是s或者ms，默认值为0； .transition-duration { transition-duration ： [, ]* ;} transition-timing-function渡效果的速率它是来设置过渡效果的速率，它有6种形式的速率： ease：逐渐变慢（默认），等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)；linear：匀速，等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)；ease-in：加速，等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)；ease-out：减速，等同于贝塞尔曲线(0, 0, 0.58, 1.0)；ease-in-out：先加速后减速，等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)；cubic-bezier：自定义贝塞尔曲线。.transition-timing { transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )]*;} 贝塞尔曲线transition-delay渡动画开始执行的时间它是来设置过渡动画开始执行的时间，单位是s或者ms，默认值为0； .transition-delay { transition-delay ： [, ]*;} transition它是transition-property、transition-duration、transition-timing-function、transition-delay的简写：.transition { transition ： ;} animationflash 中的逐帧动画animation比较类似于 flash 中的逐帧动画，逐帧动画就像电影的播放一样，表现非常细腻并且有非常大的灵活性。然而transition只是指定了开始和结束态，整个动画的过程也是由特定的函数控制。学习过 flash 的同学知道，这种逐帧动画是由关键帧组成，很多个关键帧连续的播放就组成了动画，在 CSS3 中是由属性keyframes来完成逐帧动画的。 @keyframes@keyframes animationName { from { properties: value; } percentage { properties: value; } to { properties: value; }}//or@keyframes animationName { 0% { properties: value; } percentage { properties: value; } 100% { properties: value; }} percentage：为百分比值，可以添加多个百分比值；properties：样式属性名称，例如：color、left、width等等。 animation设置动画的名称它是用来设置动画的名称，可以同时赋值多个动画名称用空格隔开： none：不改变默认行为。forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。both：向前和向后填充模式都被应用。 .animation { animation:name| none | IDENT[,none | IDENT]*; 例子:animation: name .5s forwards;} animation-duration设置动画的持续时间它是用来设置动画的持续时间，单位为s，默认值为0： .animation { animation-duration: [,]*;} animation-timing-function和transition-timing-function类似和transition-timing-function类似： .animation { animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )]*;} animation-delay设置动画的开始时间它是来设置动画的开始时间，单位是s或者ms，默认值为0： .animation { animation-delay: [,]*;} animation-iteration-count动画循环的次数它是来设置动画循环的次数，默认为1，infinite为无限次数的循环： .animation { animation-iteration-count:infinite | [, infinite | ]*;} animation-direction动画播放的方向它是来设置动画播放的方向，默认值为normal表示向前播放，alternate代表动画播放在第偶数次向前播放，第奇数次向反方向播放： .animation { animation-direction: normal | alternate [, normal | alternate]*;} animation-play-state控制动画的播放状态它主要是来控制动画的播放状态：running代表播放，而paused代表停止播放，running为默认值： .animation { animation-play-state:running | paused [, running | paused]*;} animation简写它是animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction的简写： .animation {animation:[ || || || || || ] [, [ || || || || || ] ]*;} 总结一下 关于 CSS3 的动画的三个属性transform、transition、animation我们都介绍完了，让我们回顾一下。transform我们可以理解为元素的几何变形，它是有规律可寻的，这种变形并不会产生动画效果仅仅是原有形状的改变；transition和animation它们很像 flash 中的补间动画和逐帧动画；transition是从一个状态变化到另外一种状态，当变化有了平滑的效果后就产生了动画，它是一个公式化的变化，在比较规则的动画效果中我们可以使用，例如：旋转的风车、行驶的汽车、颜色的渐变等等；animation的动画效果更加灵活，可以实现像影片一样的复杂无规则的动画","categories":[{"name":"css","slug":"css","permalink":"https://a-lyc.github.io/categories/css/"}],"tags":[{"name":"css效果","slug":"css效果","permalink":"https://a-lyc.github.io/tags/css%E6%95%88%E6%9E%9C/"}]},{"title":"全屏显示一侧颜色不同","slug":"css/全屏显示一侧颜色不同","date":"2020-03-21T11:04:24.000Z","updated":"2022-03-03T08:33:28.768Z","comments":true,"path":"2020/03/21/css/全屏显示一侧颜色不同/","link":"","permalink":"https://a-lyc.github.io/2020/03/21/css/%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA%E4%B8%80%E4%BE%A7%E9%A2%9C%E8%89%B2%E4%B8%8D%E5%90%8C/","excerpt":"这个是通过最大的100%父级有个溢出隐藏，之后在定宽内设置一个定位position-absol….之后左上对齐，可以一直延续到右直到浏览器外，因为最外面有个溢出隐藏所以看不到了","text":"这个是通过最大的100%父级有个溢出隐藏，之后在定宽内设置一个定位position-absol….之后左上对齐，可以一直延续到右直到浏览器外，因为最外面有个溢出隐藏所以看不到了 查入图片 内容以共享、参考、研究为目的,不存在任何商业目的。其版权属原作者所有,如有侵权,请与小编联系!情况属实本人将予以删除!","categories":[{"name":"css","slug":"css","permalink":"https://a-lyc.github.io/categories/css/"}],"tags":[{"name":"全屏侧边布局","slug":"全屏侧边布局","permalink":"https://a-lyc.github.io/tags/%E5%85%A8%E5%B1%8F%E4%BE%A7%E8%BE%B9%E5%B8%83%E5%B1%80/"}]},{"title":"Css边框阴影","slug":"css/Css边框阴影","date":"2020-03-20T16:00:00.000Z","updated":"2022-03-03T08:33:28.764Z","comments":true,"path":"2020/03/20/css/Css边框阴影/","link":"","permalink":"https://a-lyc.github.io/2020/03/20/css/Css%E8%BE%B9%E6%A1%86%E9%98%B4%E5%BD%B1/","excerpt":"ox-shadow是css3新增的一个属性。在W3School里，定义box-shadow是向框添加一个或者多个阴影的属性。","text":"ox-shadow是css3新增的一个属性。在W3School里，定义box-shadow是向框添加一个或者多个阴影的属性。 box-shadow一. box-shadow的定义和语法定义：box-shadow是css3新增的一个属性。在W3School里，定义box-shadow是向框添加一个或者多个阴影的属性。 语法：box-shadow: h-shadow v-shadow blur spread color inset. h-shadow: 阴影的水平位置 v-shadow：阴影的垂直位置 blur：阴影的模糊半经 spread：阴影的半径 color：阴影的颜色 inset：将外部阴影改成内部阴影 【outset反过来】 根据box-shadow的定义，我们可以为一个框设置一个阴影，也可以设置多个阴影。 当我们需要设置多个阴影时，中间需要将每个阴影用逗号隔开。 举个例子： /html代码/ /*对应的css代码*/ .test{ width: 100px; height: 100px; background: yellow; margin: 100px auto; border-radius: 50%; box-shadow: 10px 10px 20px 10px rgba(255,255,0,0.5), -10px 10px 10px 10px rgba(255,255,255,0.5) } 这里我们用border-radius属性设置了一个圆形，并且为这个圆形添加了一个浅黄色阴影和一个白色的阴影。 以第一个阴影：box-shadow: 10px 10px 20px 10px rgba(255,255,0,0.5)为例： 这段代码表示阴影的水平位置为右移10px； 垂直位置为下移10px； 第三个10px代表阴影的模糊程度blur，我们也将它设置成20px； 第四个10px是阴影半径的意思；最后一个规定了阴影的颜色为rgba(255,255,0,0.5)。 也就是说，我们为class为test的div元素添加了一个偏离框，并且向右距离为10px、向下距离为10px、模糊半径为10px、阴影半径为10px的浅黄色的阴影。 根据上面的CSS代码，我们看一下同时设置了两个阴影的效果： 查入图片 二. box-shadow属性值的详细解析根据前面的语法规则，box-shadow可以有六个值。接下来我们来聊一聊box-shadow属性里的每个值都怎么用 h-shadow【必需】这个值代表的是阴影在x轴上的阴影位置。可以是负值。 当它为正值的时候表示向右位移一定的距离【出现在元素的右边】，负值表示向左位移【出现在元素的左边】。这个距离的单位可以是px、em或者rem； 需要注意的是：h-shadow是必需的，不能省略！ box-shadow: 10px 0px 10px rgba(0,0,0,0.9) /阴影出现在元素的右侧/ box-shadow: -10px 0px 10px rgba(0,0,0,0.9) /阴影出现在元素的左侧/ 查入图片 v-shadow【必需】这个值表示阴影在y轴上的位置。也可以是负值。 当值为负的时候表示向上偏移一定的距离【出现在元素的上方】；值为正的时候表示向下偏移一定的距离【出现的元素的下方】 box-shadow: 0px -20px 10px rgba(0,0,0,0.9)/阴影出现在元素上方/ box-shadow: 0px 20px 10px rgba(0,0,0,0.9)/阴影出现在元素下方/ blur【可选】blur指的是阴影的模糊半径。这个值使得阴影部分的过渡看起来更柔和。我们可以试一试不同blur值对阴影效果的影响： box-shadow: 10px 10px 5px rgba(0,0,0,0.9) /blur值为5px/ box-shadow: 10px 10px 10px rgba(0,0,0,0.9)/blur值为10px/ box-shadow: 10px 10px 15px rgba(0,0,0,0.9)/blur值为15px/将blur值为5px、10px、15px 的效果图依次从左往右排列，可以看出来随着模糊半径数值的增大，阴影的模糊程度越高。 spread【可选】spread表示的是阴影的半径。我在网上看到有人对spread和blur的区别发出疑问，其实很简单：blur用于描述模糊半径，它的值决定了阴影的模糊程度；而spread是表示阴影所占区域的大小，这是两个不同的概念。 我们来试试其他属性值相同的情况下，spread不同时阴影的表现： box-shadow: 10px 10px 10px 5px rgba(0,0,0,0.9);/阴影半径为5px/box-shadow: 10px 10px 10px 15px rgba(0,0,0,0.9);/阴影半径为15px/box-shadow: 10px 10px 10px 25px rgba(0,0,0,0.9);/阴影半径为25px/将spread的值为5px、15px、25px的效果图依次 从左向右排列，很明显阴影在逐渐变大 color【可选】阴影的颜色可以用任何颜色单位来表示。当我们没有设置color值的时候，默认就是黑色。 box-shadow: 10px 10px 10px 5px rgba(0,0,0,0.9);/黑色阴影，用rgba表示，透明度为0.9/ box-shadow: 10px 10px 10px 5px rgb(255,0,0);/红色阴影，用rgb表示/ box-shadow: 10px 10px 10px 5px #afe;/浅蓝色阴影，用十六进制颜色表示法/ box-shadow: 10px 10px 10px 5px blue;/蓝色阴影，用颜色单词表示/ inset 【可选】默认情况下，我们设置的阴影都是外部阴影，而这个属性值的作用是将外部阴影转换成内部阴影。 box-shadow: 10px 10px 10px 5px blue; /默认为外部阴影/ box-shadow: 10px 10px 10px 5px blue inset;/将外部阴影切换为内部阴影/ 内容以共享、参考、研究为目的,不存在任何商业目的。其版权属原作者所有,如有侵权,请与小编联系!情况属实本人将予以删除!","categories":[{"name":"css","slug":"css","permalink":"https://a-lyc.github.io/categories/css/"}],"tags":[{"name":"css效果","slug":"css效果","permalink":"https://a-lyc.github.io/tags/css%E6%95%88%E6%9E%9C/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/categories/vue/"},{"name":"node","slug":"node","permalink":"https://a-lyc.github.io/categories/node/"},{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/categories/node%E5%85%A5%E9%97%A8/"},{"name":"js数组字符串方法","slug":"js数组字符串方法","permalink":"https://a-lyc.github.io/categories/js%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/categories/Nuxt/"},{"name":"vue服务器配置示例","slug":"vue服务器配置示例","permalink":"https://a-lyc.github.io/categories/vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/"},{"name":"域名,域名链接本地地址,egg配置","slug":"域名-域名链接本地地址-egg配置","permalink":"https://a-lyc.github.io/categories/%E5%9F%9F%E5%90%8D-%E5%9F%9F%E5%90%8D%E9%93%BE%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80-egg%E9%85%8D%E7%BD%AE/"},{"name":"egg后台开发","slug":"egg后台开发","permalink":"https://a-lyc.github.io/categories/egg%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"},{"name":"ts,ts面向对象","slug":"ts-ts面向对象","permalink":"https://a-lyc.github.io/categories/ts-ts%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"ts类型","slug":"ts类型","permalink":"https://a-lyc.github.io/categories/ts%E7%B1%BB%E5%9E%8B/"},{"name":"ts,ts快速入门","slug":"ts-ts快速入门","permalink":"https://a-lyc.github.io/categories/ts-ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"tweenmax","slug":"tweenmax","permalink":"https://a-lyc.github.io/categories/tweenmax/"},{"name":"老虎机插件文档","slug":"老虎机插件文档","permalink":"https://a-lyc.github.io/categories/%E8%80%81%E8%99%8E%E6%9C%BA%E6%8F%92%E4%BB%B6%E6%96%87%E6%A1%A3/"},{"name":"npm上传插件","slug":"npm上传插件","permalink":"https://a-lyc.github.io/categories/npm%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6/"},{"name":"定时器,","slug":"定时器","permalink":"https://a-lyc.github.io/categories/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"githup","slug":"githup","permalink":"https://a-lyc.github.io/categories/githup/"},{"name":"svga 动画 AE","slug":"svga-动画-AE","permalink":"https://a-lyc.github.io/categories/svga-%E5%8A%A8%E7%94%BB-AE/"},{"name":"资源 本地域名","slug":"资源-本地域名","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90-%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D/"},{"name":"css","slug":"css","permalink":"https://a-lyc.github.io/categories/css/"},{"name":"AE","slug":"AE","permalink":"https://a-lyc.github.io/categories/AE/"},{"name":"lubanH5","slug":"lubanH5","permalink":"https://a-lyc.github.io/categories/lubanH5/"},{"name":"微信云支付","slug":"微信云支付","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1%E4%BA%91%E6%94%AF%E4%BB%98/"},{"name":"uniapp云开发","slug":"uniapp云开发","permalink":"https://a-lyc.github.io/categories/uniapp%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/categories/%E5%BE%AE%E4%BF%A1/"},{"name":"原生ajax","slug":"原生ajax","permalink":"https://a-lyc.github.io/categories/%E5%8E%9F%E7%94%9Fajax/"},{"name":"node-express node入门","slug":"node-express-node入门","permalink":"https://a-lyc.github.io/categories/node-express-node%E5%85%A5%E9%97%A8/"},{"name":"nuxt使用layui","slug":"nuxt使用layui","permalink":"https://a-lyc.github.io/categories/nuxt%E4%BD%BF%E7%94%A8layui/"},{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/categories/ES6/"},{"name":"vue-api vue","slug":"vue-api-vue","permalink":"https://a-lyc.github.io/categories/vue-api-vue/"},{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/categories/uniapp/"},{"name":"资源,插件","slug":"资源-插件","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90-%E6%8F%92%E4%BB%B6/"},{"name":"前端模块化脚手架","slug":"前端模块化脚手架","permalink":"https://a-lyc.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"资源","slug":"资源","permalink":"https://a-lyc.github.io/categories/%E8%B5%84%E6%BA%90/"},{"name":"学习整理的前端","slug":"学习整理的前端","permalink":"https://a-lyc.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E7%9A%84%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue-element-admin","slug":"vue-element-admin","permalink":"https://a-lyc.github.io/tags/vue-element-admin/"},{"name":"vue","slug":"vue","permalink":"https://a-lyc.github.io/tags/vue/"},{"name":"vue3.0","slug":"vue3-0","permalink":"https://a-lyc.github.io/tags/vue3-0/"},{"name":"node","slug":"node","permalink":"https://a-lyc.github.io/tags/node/"},{"name":"node服务器，node插件","slug":"node服务器，node插件","permalink":"https://a-lyc.github.io/tags/node%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cnode%E6%8F%92%E4%BB%B6/"},{"name":"node入门","slug":"node入门","permalink":"https://a-lyc.github.io/tags/node%E5%85%A5%E9%97%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://a-lyc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://a-lyc.github.io/tags/mongoDB/"},{"name":"js 数组字符串方法 常用数组字符串api","slug":"js-数组字符串方法-常用数组字符串api","permalink":"https://a-lyc.github.io/tags/js-%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2api/"},{"name":"vue axios","slug":"vue-axios","permalink":"https://a-lyc.github.io/tags/vue-axios/"},{"name":"nuxt的使用 nuxt的基本组件安装","slug":"nuxt的使用-nuxt的基本组件安装","permalink":"https://a-lyc.github.io/tags/nuxt%E7%9A%84%E4%BD%BF%E7%94%A8-nuxt%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"vue服务器配置示例","slug":"vue服务器配置示例","permalink":"https://a-lyc.github.io/tags/vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/"},{"name":"域名,域名链接本地地址,egg配置","slug":"域名-域名链接本地地址-egg配置","permalink":"https://a-lyc.github.io/tags/%E5%9F%9F%E5%90%8D-%E5%9F%9F%E5%90%8D%E9%93%BE%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80-egg%E9%85%8D%E7%BD%AE/"},{"name":"egg后台开发","slug":"egg后台开发","permalink":"https://a-lyc.github.io/tags/egg%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"},{"name":"ts,ts面向对象","slug":"ts-ts面向对象","permalink":"https://a-lyc.github.io/tags/ts-ts%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"ts类型","slug":"ts类型","permalink":"https://a-lyc.github.io/tags/ts%E7%B1%BB%E5%9E%8B/"},{"name":"ts,ts快速入门","slug":"ts-ts快速入门","permalink":"https://a-lyc.github.io/tags/ts-ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"抽奖","slug":"抽奖","permalink":"https://a-lyc.github.io/tags/%E6%8A%BD%E5%A5%96/"},{"name":"tweenmax","slug":"tweenmax","permalink":"https://a-lyc.github.io/tags/tweenmax/"},{"name":"动画","slug":"动画","permalink":"https://a-lyc.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"老虎机插件","slug":"老虎机插件","permalink":"https://a-lyc.github.io/tags/%E8%80%81%E8%99%8E%E6%9C%BA%E6%8F%92%E4%BB%B6/"},{"name":"无限滚动老虎机","slug":"无限滚动老虎机","permalink":"https://a-lyc.github.io/tags/%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E8%80%81%E8%99%8E%E6%9C%BA/"},{"name":"npm","slug":"npm","permalink":"https://a-lyc.github.io/tags/npm/"},{"name":"老虎机","slug":"老虎机","permalink":"https://a-lyc.github.io/tags/%E8%80%81%E8%99%8E%E6%9C%BA/"},{"name":"定时器","slug":"定时器","permalink":"https://a-lyc.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"页面数据持久化","slug":"页面数据持久化","permalink":"https://a-lyc.github.io/tags/%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"setInterval","slug":"setInterval","permalink":"https://a-lyc.github.io/tags/setInterval/"},{"name":"setTimeout","slug":"setTimeout","permalink":"https://a-lyc.github.io/tags/setTimeout/"},{"name":"vue销毁时","slug":"vue销毁时","permalink":"https://a-lyc.github.io/tags/vue%E9%94%80%E6%AF%81%E6%97%B6/"},{"name":"githup","slug":"githup","permalink":"https://a-lyc.github.io/tags/githup/"},{"name":"svga 动画 AE","slug":"svga-动画-AE","permalink":"https://a-lyc.github.io/tags/svga-%E5%8A%A8%E7%94%BB-AE/"},{"name":"资源 本地域名","slug":"资源-本地域名","permalink":"https://a-lyc.github.io/tags/%E8%B5%84%E6%BA%90-%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D/"},{"name":"Flex布局","slug":"Flex布局","permalink":"https://a-lyc.github.io/tags/Flex%E5%B8%83%E5%B1%80/"},{"name":"AE","slug":"AE","permalink":"https://a-lyc.github.io/tags/AE/"},{"name":"vue 实时通讯","slug":"vue-实时通讯","permalink":"https://a-lyc.github.io/tags/vue-%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF/"},{"name":"lubanH5","slug":"lubanH5","permalink":"https://a-lyc.github.io/tags/lubanH5/"},{"name":"微信云支付","slug":"微信云支付","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E4%BA%91%E6%94%AF%E4%BB%98/"},{"name":"云开发","slug":"云开发","permalink":"https://a-lyc.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"uniapp云开发","slug":"uniapp云开发","permalink":"https://a-lyc.github.io/tags/uniapp%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"微信云开发","slug":"微信云开发","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"原生ajax","slug":"原生ajax","permalink":"https://a-lyc.github.io/tags/%E5%8E%9F%E7%94%9Fajax/"},{"name":"node-express node框架","slug":"node-express-node框架","permalink":"https://a-lyc.github.io/tags/node-express-node%E6%A1%86%E6%9E%B6/"},{"name":"nuxt使用layui","slug":"nuxt使用layui","permalink":"https://a-lyc.github.io/tags/nuxt%E4%BD%BF%E7%94%A8layui/"},{"name":"ES6","slug":"ES6","permalink":"https://a-lyc.github.io/tags/ES6/"},{"name":"vue-api","slug":"vue-api","permalink":"https://a-lyc.github.io/tags/vue-api/"},{"name":"nuxt单个裁切图片和多个裁切","slug":"nuxt单个裁切图片和多个裁切","permalink":"https://a-lyc.github.io/tags/nuxt%E5%8D%95%E4%B8%AA%E8%A3%81%E5%88%87%E5%9B%BE%E7%89%87%E5%92%8C%E5%A4%9A%E4%B8%AA%E8%A3%81%E5%88%87/"},{"name":"asyncData","slug":"asyncData","permalink":"https://a-lyc.github.io/tags/asyncData/"},{"name":"nuxt vue 使用富文本图片裁切以及element","slug":"nuxt-vue-使用富文本图片裁切以及element","permalink":"https://a-lyc.github.io/tags/nuxt-vue-%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%AC%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87%E4%BB%A5%E5%8F%8Aelement/"},{"name":"nuxt.js全局方法的使用 install","slug":"nuxt-js全局方法的使用-install","permalink":"https://a-lyc.github.io/tags/nuxt-js%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8-install/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://a-lyc.github.io/tags/Nuxt/"},{"name":"uniapp","slug":"uniapp","permalink":"https://a-lyc.github.io/tags/uniapp/"},{"name":"微信","slug":"微信","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"wxparse富文本插件","slug":"wxparse富文本插件","permalink":"https://a-lyc.github.io/tags/wxparse%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8F%92%E4%BB%B6/"},{"name":"微信小程序基础","slug":"微信小程序基础","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"},{"name":"微信小程序的异步请求-promise封装-async","slug":"微信小程序的异步请求-promise封装-async","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82-promise%E5%B0%81%E8%A3%85-async/"},{"name":"Vant-weapp","slug":"Vant-weapp","permalink":"https://a-lyc.github.io/tags/Vant-weapp/"},{"name":"vue 自定义指令-待完善","slug":"vue-自定义指令-待完善","permalink":"https://a-lyc.github.io/tags/vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/"},{"name":"vue 登录注册","slug":"vue-登录注册","permalink":"https://a-lyc.github.io/tags/vue-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"},{"name":"路由","slug":"路由","permalink":"https://a-lyc.github.io/tags/%E8%B7%AF%E7%94%B1/"},{"name":"vue 批量删除","slug":"vue-批量删除","permalink":"https://a-lyc.github.io/tags/vue-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4/"},{"name":"资源","slug":"资源","permalink":"https://a-lyc.github.io/tags/%E8%B5%84%E6%BA%90/"},{"name":"tinymce富文本编辑器","slug":"tinymce富文本编辑器","permalink":"https://a-lyc.github.io/tags/tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"插件","slug":"插件","permalink":"https://a-lyc.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"全局依赖注入","slug":"全局依赖注入","permalink":"https://a-lyc.github.io/tags/%E5%85%A8%E5%B1%80%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"name":"vue watch","slug":"vue-watch","permalink":"https://a-lyc.github.io/tags/vue-watch/"},{"name":"vue 插槽 slot","slug":"vue-插槽-slot","permalink":"https://a-lyc.github.io/tags/vue-%E6%8F%92%E6%A7%BD-slot/"},{"name":"vue 过滤器","slug":"vue-过滤器","permalink":"https://a-lyc.github.io/tags/vue-%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"vue get和set以及watch的router 本地缓存问题","slug":"vue-get和set以及watch的router-本地缓存问题","permalink":"https://a-lyc.github.io/tags/vue-get%E5%92%8Cset%E4%BB%A5%E5%8F%8Awatch%E7%9A%84router-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"},{"name":"微信小程序授权登录","slug":"微信小程序授权登录","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95/"},{"name":"axios基础使用","slug":"axios基础使用","permalink":"https://a-lyc.github.io/tags/axios%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"name":"微信发送数据请求","slug":"微信发送数据请求","permalink":"https://a-lyc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"},{"name":"vue $router","slug":"vue-router","permalink":"https://a-lyc.github.io/tags/vue-router/"},{"name":"jq","slug":"jq","permalink":"https://a-lyc.github.io/tags/jq/"},{"name":"使用vant-UI库","slug":"使用vant-UI库","permalink":"https://a-lyc.github.io/tags/%E4%BD%BF%E7%94%A8vant-UI%E5%BA%93/"},{"name":"前端脚手架","slug":"前端脚手架","permalink":"https://a-lyc.github.io/tags/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"跨域","slug":"跨域","permalink":"https://a-lyc.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"await async","slug":"await-async","permalink":"https://a-lyc.github.io/tags/await-async/"},{"name":"mixin混入","slug":"mixin混入","permalink":"https://a-lyc.github.io/tags/mixin%E6%B7%B7%E5%85%A5/"},{"name":"vue 基本生命周期","slug":"vue-基本生命周期","permalink":"https://a-lyc.github.io/tags/vue-%E5%9F%BA%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"vue axios封装基础","slug":"vue-axios封装基础","permalink":"https://a-lyc.github.io/tags/vue-axios%E5%B0%81%E8%A3%85%E5%9F%BA%E7%A1%80/"},{"name":"$router","slug":"router","permalink":"https://a-lyc.github.io/tags/router/"},{"name":"ref refs 组件传递","slug":"ref-refs-组件传递","permalink":"https://a-lyc.github.io/tags/ref-refs-%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92/"},{"name":"vue插件","slug":"vue插件","permalink":"https://a-lyc.github.io/tags/vue%E6%8F%92%E4%BB%B6/"},{"name":"vue 全局组件传递","slug":"vue-全局组件传递","permalink":"https://a-lyc.github.io/tags/vue-%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92/"},{"name":"零散资源","slug":"零散资源","permalink":"https://a-lyc.github.io/tags/%E9%9B%B6%E6%95%A3%E8%B5%84%E6%BA%90/"},{"name":"单位转换","slug":"单位转换","permalink":"https://a-lyc.github.io/tags/%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2/"},{"name":"vue插件 懒加载 移动端延迟","slug":"vue插件-懒加载-移动端延迟","permalink":"https://a-lyc.github.io/tags/vue%E6%8F%92%E4%BB%B6-%E6%87%92%E5%8A%A0%E8%BD%BD-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BB%B6%E8%BF%9F/"},{"name":"vue vsCoods快捷创建模板","slug":"vue-vsCoods快捷创建模板","permalink":"https://a-lyc.github.io/tags/vue-vsCoods%E5%BF%AB%E6%8D%B7%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF/"},{"name":"jsES5-js单词","slug":"jsES5-js单词","permalink":"https://a-lyc.github.io/tags/jsES5-js%E5%8D%95%E8%AF%8D/"},{"name":"css效果","slug":"css效果","permalink":"https://a-lyc.github.io/tags/css%E6%95%88%E6%9E%9C/"},{"name":"全屏侧边布局","slug":"全屏侧边布局","permalink":"https://a-lyc.github.io/tags/%E5%85%A8%E5%B1%8F%E4%BE%A7%E8%BE%B9%E5%B8%83%E5%B1%80/"}]}